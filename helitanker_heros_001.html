<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Helitanker Rescue - On Foot Mode</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the game environment */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1f2937; /* Dark background */
        }
        #gameCanvas {
            border: 2px solid #374151;
            background-color: #0b111a; /* Very dark background for the sky */
            display: block;
            margin: 0 auto;
        }
        .resource-bar {
            transition: width 0.3s ease-out;
        }
        .input-range {
            -webkit-appearance: none;
            width: 100%;
            height: 10px;
            border-radius: 5px;
            background: #4b5563;
            outline: none;
            opacity: 0.7;
            -webkit-transition: .2s;
            transition: opacity .2s;
        }
        .input-range::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            box-shadow: 0 0 5px #3b82f6;
        }
    </style>
</head>
<body>

<div id="app" class="p-4 sm:p-6 min-h-screen flex flex-col items-center">
    <h1 class="text-3xl font-bold text-yellow-400 mb-4 tracking-wider">HELITANKER RESCUE</h1>
    
    <!-- Start Screen -->
    <div id="start-screen" class="w-full max-w-sm bg-gray-800 p-8 rounded-xl shadow-2xl text-center text-white space-y-6">
        <h2 class="text-2xl font-semibold text-green-400">Mission Ready</h2>
        <button onclick="startGame()" class="w-full py-3 bg-green-600 hover:bg-green-700 rounded-lg text-lg font-bold shadow-md transition duration-200">
            Start Mission
        </button>
        <button onclick="showScreen('options')" class="w-full py-3 bg-blue-600 hover:bg-blue-700 rounded-lg text-lg font-bold shadow-md transition duration-200">
            Options
        </button>
        <p class="text-sm text-gray-400 pt-4">Controls: **W/Up** (Thrust), **A/D** (Lateral/Walk), **E** (Exit/Enter), **Space** (Water Drop/Squirt).</p>
    </div>

    <!-- Options Screen -->
    <div id="options-screen" class="w-full max-w-sm bg-gray-800 p-8 rounded-xl shadow-2xl text-white hidden">
        <h2 class="text-2xl font-semibold text-blue-400 mb-6 text-center">Game Options</h2>
        <div class="space-y-4">
            <!-- Gravity -->
            <div>
                <label for="opt-gravity" class="block text-sm font-medium text-gray-400 mb-1">Gravity Strength: <span id="gravity-value" class="text-yellow-300"></span></label>
                <input type="range" id="opt-gravity" min="0.01" max="0.3" step="0.01" class="input-range" oninput="document.getElementById('gravity-value').textContent = this.value">
            </div>
            <!-- Thrust Rate -->
            <div>
                <label for="opt-thrust" class="block text-sm font-medium text-gray-400 mb-1">Thrust Rate: <span id="thrust-value" class="text-yellow-300"></span></label>
                <input type="range" id="opt-thrust" min="0.05" max="0.3" step="0.01" class="input-range" oninput="document.getElementById('thrust-value').textContent = this.value">
            </div>
            <!-- Crash Speed -->
            <div>
                <label for="opt-crash-speed" class="block text-sm font-medium text-gray-400 mb-1">Max Safe Vertical Speed: <span id="crash-speed-value" class="text-yellow-300"></span></label>
                <input type="range" id="opt-crash-speed" min="0.5" max="2.5" step="0.1" class="input-range" oninput="document.getElementById('crash-speed-value').textContent = this.value">
            </div>
        </div>
        
        <div class="mt-8 flex justify-between space-x-4">
            <button onclick="showScreen('start')" class="flex-1 py-2 bg-gray-600 hover:bg-gray-700 rounded-lg font-semibold transition duration-200">
                Cancel
            </button>
            <button onclick="saveOptions()" class="flex-1 py-2 bg-green-600 hover:bg-green-700 rounded-lg font-bold shadow-md transition duration-200">
                Save & Back
            </button>
        </div>
    </div>

    <!-- Game Content (Status Panel and Canvas) -->
    <div id="game-content" class="w-full max-w-4xl flex flex-col items-center hidden">
        <!-- Game Status and Controls Display -->
        <div id="status-panel" class="w-full bg-gray-800 p-3 sm:p-4 rounded-xl shadow-2xl mb-4 text-white">
            <div id="game-message" class="text-center text-lg font-bold h-6 mb-2 text-green-400">Ready to Fly</div>
            
            <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-xs sm:text-sm">
                <!-- Mission Stage Display -->
                <div class="flex flex-col">
                    <span class="font-semibold text-gray-400">Mode: <span id="mode-display" class="text-cyan-400 font-bold">HELI</span></span>
                    <span class="font-semibold text-gray-400">Fires Remaining: <span id="fires-display" class="text-red-400 font-bold">0</span></span>
                </div>
                
                <!-- Fuel Status -->
                <div class="flex flex-col">
                    <span class="font-semibold text-gray-400">Fuel: <span id="fuel-display">100%</span></span>
                    <div class="w-full bg-gray-700 h-3 rounded-full overflow-hidden mt-1">
                        <div id="fuel-bar" class="resource-bar bg-green-500 h-full" style="width: 100%;"></div>
                    </div>
                </div>

                <!-- Water Status -->
                <div class="flex flex-col">
                    <span class="font-semibold text-gray-400">Water: <span id="water-display">100%</span></span>
                    <div class="w-full bg-gray-700 h-3 rounded-full overflow-hidden mt-1">
                        <div id="water-bar" class="resource-bar bg-blue-500 h-full" style="width: 100%;"></div>
                    </div>
                </div>

                <!-- Velocity Indicators -->
                <div class="flex flex-col">
                    <span class="font-semibold text-gray-400">H-Speed: <span id="vx-display" class="text-yellow-400">0.00</span></span>
                    <span class="font-semibold text-gray-400">V-Speed: <span id="vy-display" class="text-red-400">0.00</span></span>
                </div>
            </div>
        </div>

        <!-- Canvas Container -->
        <canvas id="gameCanvas" width="800" height="400" class="rounded-xl shadow-xl"></canvas>
    </div>
</div>

<script>
    // --- Constants and Configuration ---
    const CONFIG = {
        CANVAS_WIDTH: 800,
        CANVAS_HEIGHT: 400,
        WORLD_WIDTH: 4000,
        
        // Customizable Options (Defaults)
        GRAVITY: 0.05,
        THRUST_RATE: 0.1,
        CRASH_VELOCITY_Y: 1.0, 

        // Fixed/Derived Options
        SIDE_THRUST_RATE: 0.05,
        FUEL_BURN: 0.05,
        WATER_DROP_COST: 5,
        WATER_SQUIRT_COST: 1, // Less water used for ground squirt
        FUEL_PICKUP_AMOUNT: 20, // Fuel restored by barrel
        GROUND_SPEED: 2.0, // New constant for stick figure speed
        MAX_VELOCITY: 5.0,
        PLAYER_SIZE: 20, // Heli box size
        MAX_FUEL: 100,
        MAX_WATER: 100,
        FIRE_RANGE: 40,
        WATER_DAMAGE_PER_DROP: 15, 
        WATER_DAMAGE_PER_SQUIRT: 5, // Less damage from ground squirt
        SMALL_FIRE_LIFE: 15,
        LARGE_FIRE_LIFE: 60,
    };

    // --- DOM Element References ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const fuelBar = document.getElementById('fuel-bar');
    const waterBar = document.getElementById('water-bar');
    const fuelDisplay = document.getElementById('fuel-display');
    const waterDisplay = document.getElementById('water-display');
    const vxDisplay = document.getElementById('vx-display');
    const vyDisplay = document.getElementById('vy-display');
    const firesDisplay = document.getElementById('fires-display');
    const modeDisplay = document.getElementById('mode-display');
    const gameMessage = document.getElementById('game-message');
    
    // New Screen Refs
    const startScreen = document.getElementById('start-screen');
    const optionsScreen = document.getElementById('options-screen');
    const gameContent = document.getElementById('game-content');

    // --- Game State ---
    let game = {
        screen: 'start',
        isRunning: false,
        isLanded: false,
        isWin: false,
        isCrash: false,
        keys: {},
        terrain: [],
        fires: [],
        drops: [], 
        explosions: [], // NEW: Array to hold particle effects
        heli: null, 
        fuelBarrel: null, 
        cameraX: 0,
        missionStage: 1, 
        fireBaseCount: 4, 
        playerMode: 'heli', // State: 'heli' or 'ground'
        heliLandingPos: { x: 0, y: 0 }, // Stores the position of the abandoned heli
        
        // Pad Definitions (fixed world coordinates)
        padA: { x: 50, y: 0, width: 80, label: "Left Pad" }, 
        padB: { x: CONFIG.WORLD_WIDTH - 130, y: 0, width: 80, label: "Right Pad" }, 
        
        // Dynamic Pad Roles based on missionStage
        currentRefuelPad: null, 
        currentEndPad: null,
    };

    // --- Helitanker Object (Represents the player state, even when on ground) ---
    function HeliTanker() {
        this.x = 0; 
        this.y = 50;
        this.vx = 0; 
        this.vy = 0; 
        this.fuel = CONFIG.MAX_FUEL;
        this.water = CONFIG.MAX_WATER;
    }

    HeliTanker.prototype.update = function() {
        if (!game.isRunning || game.isCrash) return;

        if (game.playerMode === 'heli') {
            this.updateHeli();
        } else if (game.playerMode === 'ground') {
            this.updateStickFigure();
        }
    };
    
    // --- Helper to find ground Y position for current X ---
    function getGroundY(xPos) {
        let terrainY = CONFIG.CANVAS_HEIGHT; 
        for (let i = 0; i < game.terrain.length - 1; i++) {
            const p1 = game.terrain[i];
            const p2 = game.terrain[i+1];
            if (xPos > p1.x && xPos <= p2.x) {
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const ratio = (xPos - p1.x) / dx;
                terrainY = p1.y + dy * ratio; 
                break;
            }
        }
        return terrainY;
    }

    // --- Helicopter Mode Update ---
    HeliTanker.prototype.updateHeli = function() {
        let thrustApplied = false;
        const isThrustingUp = game.keys['w'] || game.keys['ArrowUp'];

        // 1. Vertical Thrust Check (Allows takeoff)
        if (isThrustingUp) {
            if (this.fuel > 0) {
                if (game.isLanded) {
                    game.isLanded = false; 
                }
                this.vy -= CONFIG.THRUST_RATE;
                this.fuel = Math.max(0, this.fuel - CONFIG.FUEL_BURN);
                thrustApplied = true;
            }
        }

        // 2. If landed and not thrusting up, stop movement and skip physics.
        if (game.isLanded) {
            this.vx = 0; 
            this.vy = 0; 
            return; 
        }

        // 3. Normal Flight Physics (Only runs if !game.isLanded)
        
        // Apply side thrust
        if (game.keys['a'] || game.keys['ArrowLeft']) {
            if (this.fuel > 0) {
                this.vx -= CONFIG.SIDE_THRUST_RATE;
                this.fuel = Math.max(0, this.fuel - CONFIG.FUEL_BURN * 0.5);
                thrustApplied = true;
            }
        }
        if (game.keys['d'] || game.keys['ArrowRight']) {
            if (this.fuel > 0) {
                this.vx += CONFIG.SIDE_THRUST_RATE;
                this.fuel = Math.max(0, this.fuel - CONFIG.FUEL_BURN * 0.5);
                thrustApplied = true;
            }
        }

        // Apply Gravity
        this.vy += CONFIG.GRAVITY;

        // Check fuel level
        if (this.fuel <= 0 && thrustApplied) {
            gameMessage.textContent = "CRITICAL: Out of Fuel! Gravity Pull.";
            gameMessage.className = "text-center text-lg font-bold h-6 mb-2 text-red-500";
        }

        // Apply velocity (Clamp velocity)
        this.vx = Math.max(-CONFIG.MAX_VELOCITY, Math.min(CONFIG.MAX_VELOCITY, this.vx));
        this.vy = Math.max(-CONFIG.MAX_VELOCITY, Math.min(CONFIG.MAX_VELOCITY, this.vy));
        
        this.x += this.vx;
        this.y += this.vy;
        
        // Prevent flying out of the world boundaries
        this.x = Math.max(CONFIG.PLAYER_SIZE / 2, Math.min(CONFIG.WORLD_WIDTH - CONFIG.PLAYER_SIZE / 2, this.x));
    };

    // --- Stick Figure Mode Update ---
    HeliTanker.prototype.updateStickFigure = function() {
        // Apply Gravity to the stick figure
        this.vy += CONFIG.GRAVITY;
        this.y += this.vy;

        // Walking movement
        if (game.keys['a'] || game.keys['ArrowLeft']) {
            this.x -= CONFIG.GROUND_SPEED;
            checkFuelPickup(); 
        }
        if (game.keys['d'] || game.keys['ArrowRight']) {
            this.x += CONFIG.GROUND_SPEED;
            checkFuelPickup(); 
        }

        // Boundary Check
        this.x = Math.max(1, Math.min(CONFIG.WORLD_WIDTH - 1, this.x));
        
        // Collision with terrain (Grounding the stick figure)
        const groundY = getGroundY(this.x);
        const playerBottomY = this.y + 10; // Stick figure is 20 units tall (head at Y, feet at Y+10)
        
        if (playerBottomY >= groundY) {
            this.y = groundY - 10; // Snap player's feet to the ground
            this.vy = 0;
        }

        // Reset landing state check 
        game.isLanded = true; 
    }


    // --- Drawing Functions ---

    HeliTanker.prototype.draw = function() {
        if (game.playerMode === 'heli') {
            this.drawHeli(this.x, this.y, 1.0); // Full opacity when controlled
        } else if (game.playerMode === 'ground') {
            this.drawStickFigure();
        }
    };
    
    // Unified Heli Drawing function (used for controlled heli and landed heli)
    HeliTanker.prototype.drawHeli = function(xPos, yPos, opacity) {
        const x = xPos - game.cameraX;
        const y = yPos;

        // Draw the main yellow block (Helitanker body)
        ctx.fillStyle = `rgba(250, 204, 21, ${opacity})`;
        ctx.fillRect(x - CONFIG.PLAYER_SIZE / 2, y - CONFIG.PLAYER_SIZE / 2, CONFIG.PLAYER_SIZE, CONFIG.PLAYER_SIZE);

        // Simple rotor effect (only wobble if full opacity, i.e., controlled)
        if (opacity > 0.9) {
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            const wobbleFactor = 0.5;
            const wobbleAmplitude = CONFIG.PLAYER_SIZE * 0.3;
            const wobbleOffset = Math.sin(Date.now() * 0.01 * wobbleFactor) * wobbleAmplitude; 
            
            const rotorY = y - CONFIG.PLAYER_SIZE / 2 - 5;
            const rotorSpan = CONFIG.PLAYER_SIZE * 1.5;
            
            ctx.moveTo(x - rotorSpan / 2 + wobbleOffset, rotorY);
            ctx.lineTo(x + rotorSpan / 2 + wobbleOffset, rotorY);
            
            ctx.stroke();
        } else {
            // Static rotor line for landed heli
            ctx.strokeStyle = '#9ca3af';
            ctx.lineWidth = 2;
            ctx.beginPath();
            const rotorY = y - CONFIG.PLAYER_SIZE / 2 - 5;
            const rotorSpan = CONFIG.PLAYER_SIZE * 1.5;
            ctx.moveTo(x - rotorSpan / 2, rotorY);
            ctx.lineTo(x + rotorSpan / 2, rotorY);
            ctx.stroke();
        }

        // Draw water payload indicator
        ctx.fillStyle = '#3b82f6';
        const waterHeight = CONFIG.PLAYER_SIZE * (this.water / CONFIG.MAX_WATER) * 0.5;
        ctx.fillRect(x - 5, y + CONFIG.PLAYER_SIZE / 2 - waterHeight, 10, waterHeight);
    };

    // Function to draw the inert helicopter at its fixed landing spot
    function drawLandedHeli() {
        if (game.heliLandingPos) {
            game.heli.drawHeli(game.heliLandingPos.x, game.heliLandingPos.y, 0.6); // 60% opacity
            
            // Draw helpful text
            const x = game.heliLandingPos.x - game.cameraX;
            const y = game.heliLandingPos.y;
            ctx.font = '10px Inter';
            ctx.fillStyle = '#9ca3af';
            ctx.textAlign = 'center';
            ctx.fillText("[LANDED HELI]", x, y - CONFIG.PLAYER_SIZE/2 - 10);
            ctx.textAlign = 'left'; // Reset
        }
    }

    HeliTanker.prototype.drawStickFigure = function() {
        const x = this.x - game.cameraX;
        const y = this.y; // Y is now the head/center of the body

        // Stick Figure size parameters
        const headRadius = 4;
        const bodyHeight = 10;
        const legLength = 6;
        const legWobble = Math.sin(Date.now() * 0.05) * 2; // Walking animation

        // Body color (Firefighter orange/red)
        ctx.strokeStyle = '#ef4444';
        ctx.lineWidth = 2;

        // 1. Head (circle)
        ctx.beginPath();
        ctx.arc(x, y - headRadius, headRadius, 0, Math.PI * 2);
        ctx.stroke();

        // 2. Body (line)
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x, y + bodyHeight);
        ctx.stroke();
        
        // 3. Legs
        ctx.beginPath();
        // Left Leg
        ctx.moveTo(x, y + bodyHeight);
        ctx.lineTo(x - legWobble, y + bodyHeight + legLength);
        // Right Leg
        ctx.moveTo(x, y + bodyHeight);
        ctx.lineTo(x + legWobble, y + bodyHeight + legLength);
        ctx.stroke();

        // 4. Firefighting Backpack (Water indicator)
        const backpackWidth = 8;
        const waterHeight = (this.water / CONFIG.MAX_WATER) * 10;
        ctx.fillStyle = '#1d4ed8'; // Blue backpack
        ctx.fillRect(x - backpackWidth/2, y, backpackWidth, -10); // Backpack sits behind body, high up
        
        // Water level on backpack
        ctx.fillStyle = '#3b82f6';
        ctx.fillRect(x - backpackWidth/2 + 1, y - waterHeight - 1, backpackWidth - 2, waterHeight);
    };
    
    // --- Water Drop/Squirt Mechanic ---

    function dropWater() {
        if (!game.heli || !game.isRunning || game.isLanded) return;
        if (game.heli.water < CONFIG.WATER_DROP_COST) {
            gameMessage.textContent = "Water Empty! Find the REFUEL pad.";
            gameMessage.className = "text-center text-lg font-bold h-6 mb-2 text-red-400";
            return;
        }

        // Heli drop logic (vertical)
        game.heli.water -= CONFIG.WATER_DROP_COST;
        const drop = {
            x: game.heli.x,
            y: game.heli.y + CONFIG.PLAYER_SIZE / 2,
            vx: game.heli.vx * 0.5, // Inherit some horizontal speed
            vy: 2,
            radius: 3,
            isSquirt: false
        };
        game.drops.push(drop);
    }

    function squirtWater() {
        if (!game.heli || !game.isRunning || game.playerMode !== 'ground') return;
        if (game.heli.water < CONFIG.WATER_SQUIRT_COST) {
            gameMessage.textContent = "Water Empty! Pick up fuel barrels or fly to the pad.";
            gameMessage.className = "text-center text-lg font-bold h-6 mb-2 text-red-400";
            return;
        }

        // Stick figure squirt logic (horizontal)
        game.heli.water -= CONFIG.WATER_SQUIRT_COST;
        
        // Determine direction based on last movement or default (right)
        let direction = 1; 
        if (game.keys['a'] || game.keys['ArrowLeft']) { direction = -1; } 
        else if (game.keys['d'] || game.keys['ArrowRight']) { direction = 1; }

        const squirt = {
            x: game.heli.x + direction * 5, // Start point near the figure
            y: game.heli.y + 5, // Waist height
            vx: direction * 5, // Fast horizontal velocity
            vy: 0,
            radius: 2,
            isSquirt: true,
            life: 50 // Squirt particles expire after this
        };
        game.drops.push(squirt);
    }

    // --- Drop Update Logic ---
    function updateDrops() {
        game.drops = game.drops.filter(drop => {
            if (drop.isSquirt) {
                // Ground squirt physics
                drop.x += drop.vx;
                drop.y += drop.vy;
                drop.life--;
                if (drop.life <= 0) return false;
            } else {
                // Heli drop physics
                drop.y += drop.vy;
            }

            // Fire Hit Check (Water damage is adjusted by drop type)
            let damage = drop.isSquirt ? CONFIG.WATER_DAMAGE_PER_SQUIRT : CONFIG.WATER_DAMAGE_PER_DROP;

            game.fires = game.fires.filter(fire => {
                const distSq = (fire.x - drop.x) ** 2 + (fire.y - drop.y) ** 2;
                if (distSq < (CONFIG.FIRE_RANGE * CONFIG.FIRE_RANGE)) {
                    fire.life -= damage; 
                    drop.isHit = true;
                    return fire.life > 0;
                }
                return true;
            });

            if (drop.isHit) return false;

            // Ground Collision Check
            const terrainY = getGroundY(drop.x);
            if (drop.y + drop.radius >= terrainY) {
                return false; 
            }
            return true;
        });
        
        firesDisplay.textContent = game.fires.length;
    }
    
    // --- Drop Drawing Logic ---
    function drawDrops() {
        game.drops.forEach(drop => {
            const x = drop.x - game.cameraX;
            const y = drop.y;
            ctx.fillStyle = drop.isSquirt ? '#60a5fa' : '#3b82f6'; // Light blue for squirt
            ctx.beginPath();
            ctx.arc(x, y, drop.radius, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    // --- Explosion Mechanics ---

    // Function to generate explosion particles
    function generateExplosion(x, y) {
        const numParticles = 80; // Increased particle count for a larger visual
        for (let i = 0; i < numParticles; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 8 + 2; // Increased speed for wider spread
            game.explosions.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed - 2, // Initial upward lift
                life: 150 + Math.random() * 50, // Increased life for longer duration (max 200 frames)
                radius: Math.random() * 4 + 3, // Slightly larger base radius
                // Alternate between orange and yellow for fire effect
                color: Math.random() < 0.5 ? 'rgba(255, 100, 0, ' : 'rgba(255, 255, 0, ', 
            });
        }
    }

    // Function to update explosion particles
    function updateExplosions() {
        game.explosions = game.explosions.filter(p => {
            p.vy += CONFIG.GRAVITY; // Apply gravity
            p.x += p.vx;
            p.y += p.vy;
            p.life--;
            return p.life > 0; // Remove particles when life runs out
        });
    }

    // Function to draw explosion particles
    function drawExplosions() {
        const MAX_PARTICLE_LIFE = 200; // Based on the new max life in generateExplosion
        game.explosions.forEach(p => {
            const opacity = p.life / MAX_PARTICLE_LIFE; // Slower fade out over time
            ctx.fillStyle = p.color + opacity + ')';
            
            ctx.beginPath();
            // Scale radius down as particle fades
            ctx.arc(p.x - game.cameraX, p.y, p.radius * opacity, 0, Math.PI * 2); 
            ctx.fill();
        });
    }

    // --- Pad and Barrel Interaction Helpers ---

    // UPDATED: Now checks player position (game.heli.x) against the saved heli landing spot (game.heliLandingPos.x)
    function isNearHeli() {
        const heliX = game.heliLandingPos.x;
        const playerX = game.heli.x; // Stick figure position

        const dx = Math.abs(heliX - playerX); 
        return dx < CONFIG.PLAYER_SIZE * 1.5; // Allow a wider margin for re-entry
    }
    
    function checkFuelPickup() {
        if (!game.fuelBarrel || !game.fuelBarrel.isAvailable) return;

        const barrel = game.fuelBarrel;
        const playerX = game.heli.x;

        // Simple bounding box check
        if (playerX > barrel.x - barrel.width && 
            playerX < barrel.x + barrel.width) 
        {
            game.heli.fuel = Math.min(CONFIG.MAX_FUEL, game.heli.fuel + CONFIG.FUEL_PICKUP_AMOUNT);
            barrel.isAvailable = false;
            gameMessage.textContent = `Fuel Barrel collected! +${CONFIG.FUEL_PICKUP_AMOUNT} Fuel.`;
            gameMessage.className = "text-center text-lg font-bold h-6 mb-2 text-yellow-500";
            
            // Barrel respawns after a delay
            setTimeout(() => {
                barrel.isAvailable = true;
                gameMessage.textContent = "Fuel Barrel is available again.";
            }, 10000); 
        }
    }

    // --- Terrain, Fire, Pad Drawing (Same as before, with Fuel Barrel added) ---

    function generateTerrain() {
        const worldPoints = [];
        const segmentLength = 50; 
        let variance = 0;

        // Simple Perlin-like noise generator for terrain
        for (let x = 0; x <= CONFIG.WORLD_WIDTH + segmentLength; x += segmentLength) {
            variance += Math.random() * 8 - 4; 
            variance = Math.max(-50, Math.min(50, variance)); 
            let y = CONFIG.CANVAS_HEIGHT * 0.8 + Math.sin(x / 300) * 40 + variance;
            worldPoints.push({ x: x, y: y });
        }
        game.terrain = worldPoints;
        
        // Update Pad Y positions based on terrain
        const findLandingY = (padX) => {
            for(let i=0; i < game.terrain.length - 1; i++) {
                if (game.terrain[i].x <= padX && game.terrain[i+1].x > padX) {
                    const dx = game.terrain[i+1].x - game.terrain[i].x;
                    const dy = game.terrain[i+1].y - game.terrain[i].y;
                    const ratio = (padX - game.terrain[i].x) / dx;
                    return game.terrain[i].y + dy * ratio;
                }
            }
            return CONFIG.CANVAS_HEIGHT * 0.8;
        }

        game.padA.y = findLandingY(game.padA.x);
        game.padB.y = findLandingY(game.padB.x);
    }
    
    function generateFires(count) {
        const newFires = [];
        const gap = (CONFIG.WORLD_WIDTH - 300) / count; 
        const findLandingY = getGroundY; // Use the dedicated helper
        
        for (let i = 0; i < count; i++) {
            const fireX = 150 + i * gap + (Math.random() * 50 - 25); 
            const life = i % 2 === 0 ? CONFIG.LARGE_FIRE_LIFE : CONFIG.SMALL_FIRE_LIFE;
            newFires.push({ 
                x: fireX, 
                y: findLandingY(fireX), 
                initialLife: life, 
                life: life 
            });
        }
        return newFires;
    }

    function drawTerrain() {
        ctx.fillStyle = '#4b5563'; // Gray-600 for terrain
        ctx.beginPath();
        
        ctx.moveTo(-game.cameraX, CONFIG.CANVAS_HEIGHT); 
        for (const point of game.terrain) {
            ctx.lineTo(point.x - game.cameraX, point.y);
        }
        ctx.lineTo(CONFIG.WORLD_WIDTH - game.cameraX, CONFIG.CANVAS_WIDTH);
        ctx.closePath();
        ctx.fill();

        // Draw pads dynamically
        [game.padA, game.padB].forEach(pad => {
            const isRefuel = pad === game.currentRefuelPad;
            const isEnd = pad === game.currentEndPad;
            
            ctx.fillStyle = isEnd ? '#dc2626' : (isRefuel ? '#22c55e' : '#4b5563'); // Red for End, Green for Refuel
            ctx.fillRect(pad.x - game.cameraX, pad.y, pad.width, 10);
            
            // Draw Pad Label
            ctx.fillStyle = '#ffffff';
            ctx.font = '12px Inter';
            const label = isEnd ? "END MISSION" : "START / REFUEL";
            ctx.fillText(label, pad.x + pad.width/2 - ctx.measureText(label).width/2 - game.cameraX, pad.y + 25);
        });

        // Draw Fuel Barrel
        if (game.fuelBarrel && game.fuelBarrel.isAvailable) {
            const barrel = game.fuelBarrel;
            const x = barrel.x - game.cameraX;
            const y = barrel.y;
            
            ctx.fillStyle = '#facc15'; // Yellow barrel
            ctx.fillRect(x - barrel.width/2, y - barrel.height, barrel.width, barrel.height);
            ctx.fillStyle = '#1f2937'; // Black stripes
            ctx.fillRect(x - barrel.width/2, y - barrel.height + 3, barrel.width, 2);
            ctx.fillRect(x - barrel.width/2, y - 5, barrel.width, 2);
            
            ctx.font = '10px Inter';
            ctx.fillStyle = '#facc15';
            ctx.fillText("FUEL", x - 10, y - barrel.height - 5);
        }

        // Draw fires
        game.fires.forEach(fire => {
            const x = fire.x - game.cameraX;
            const y = fire.y;
            const intensity = fire.life / fire.initialLife;

            ctx.fillStyle = `rgba(252, 165, 16, ${0.5 * intensity + (Math.random() * 0.3)})`;
            ctx.beginPath();
            ctx.arc(x, y - 10, 10 * intensity, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = `rgba(239, 68, 68, ${0.7 * intensity + (Math.random() * 0.2)})`;
            ctx.beginPath();
            ctx.arc(x, y - 5, 5 * intensity, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    // --- Collision Detection & Game Flow ---
    function checkCollisions() {
        const heli = game.heli;
        
        // Only run collision/landing checks if in heli mode
        if (game.playerMode === 'heli') {
            // 1. Terrain Collision Check
            const terrainY = getGroundY(heli.x);
            
            if (heli.y + CONFIG.PLAYER_SIZE / 2 >= terrainY) {
                // Ground hit!
                if (Math.abs(heli.vy) > CONFIG.CRASH_VELOCITY_Y) {
                    game.isCrash = true;
                    // NEW: Generate explosion on crash
                    if (game.explosions.length === 0) { 
                        generateExplosion(heli.x, heli.y);
                    }
                    endGame("CRASH LANDING! Vertical speed was too high.", 'text-red-600');
                } else {
                    // Safe landing
                    heli.vy = 0;
                    heli.vx *= 0.99;
                    heli.y = terrainY - CONFIG.PLAYER_SIZE / 2;
                    game.isLanded = true;
                }
            } else {
                game.isLanded = false;
            }

            // 2. Pad Interaction Check (only if landed safely and not crashed)
            if (game.isLanded && !game.isCrash) {
                const landedPad = [game.currentRefuelPad, game.currentEndPad].find(pad => 
                    heli.x >= pad.x && heli.x <= pad.x + pad.width
                );

                if (landedPad) {
                    if (landedPad === game.currentRefuelPad) {
                        // Refueling Pad Logic
                        if (heli.fuel < CONFIG.MAX_FUEL || heli.water < CONFIG.MAX_WATER) {
                            heli.fuel = Math.min(CONFIG.MAX_FUEL, heli.fuel + 0.5);
                            heli.water = Math.min(CONFIG.MAX_WATER, heli.water + 1.0);
                            gameMessage.textContent = "Refueling and Resupplying Water...";
                            gameMessage.className = "text-center text-lg font-bold h-6 mb-2 text-blue-400";
                        } else {
                            gameMessage.textContent = "Ready to fly. Land on the Red Pad to finish.";
                            gameMessage.className = "text-center text-lg font-bold h-6 mb-2 text-green-400";
                        }
                    } else if (landedPad === game.currentEndPad) {
                        // End Pad Logic 
                        if (game.fires.length === 0) {
                            // All fires are out - Trigger the next mission stage!
                            nextMission();
                        } else {
                            gameMessage.textContent = `Must extinguish ${game.fires.length} fires before finishing!`;
                            gameMessage.className = "text-center text-lg font-bold h-6 mb-2 text-red-400";
                        }
                    }
                } else {
                     gameMessage.textContent = "Landed safely on terrain. Take off (W) or Exit (E)!";
                     gameMessage.className = "text-center text-lg font-bold h-6 mb-2 text-green-400";
                }
            }
        }
    }


    // --- Mission Control Functions ---
    
    function setupMission(stage) {
        // Reset flight state
        game.isRunning = true;
        game.isCrash = false;
        game.playerMode = 'heli'; // Always start in the heli
        game.explosions = []; // Reset explosions array

        // 1. Determine Pad Roles based on Stage (The Swap)
        const [refuel, end] = stage === 1 
            ? [game.padA, game.padB] 
            : [game.padB, game.padA]; 

        game.currentRefuelPad = refuel;
        game.currentEndPad = end;
        
        // 2. Setup Heli (Reset position, fuel, and water)
        game.heli = new HeliTanker();
        
        // Set X to the center of the refuel pad
        game.heli.x = refuel.x + refuel.width / 2;
        // Set Y to sit directly on the pad (refuel.y is the terrain height)
        game.heli.y = refuel.y - CONFIG.PLAYER_SIZE / 2; 

        // Initialize landing pos to the starting pad
        game.heliLandingPos.x = game.heli.x;
        game.heliLandingPos.y = game.heli.y;

        game.heli.fuel = CONFIG.MAX_FUEL;
        game.heli.water = CONFIG.MAX_WATER;

        game.isLanded = true; // Start in a landed state

        // 3. Setup Fuel Barrel
        game.fuelBarrel = {
            x: refuel.x + refuel.width + 50,
            y: getGroundY(refuel.x + refuel.width + 50),
            width: 15,
            height: 20,
            isAvailable: true
        };

        // 4. Generate Fires (re-generate)
        game.fires = generateFires(game.fireBaseCount);
        game.drops = [];

        // 5. Update UI Messages
        const message = `Stage ${stage}: Extinguish ${game.fires.length} fires. Land on the Red Pad (End) to finish.`;
        gameMessage.textContent = message;
        gameMessage.className = "text-center text-lg font-bold h-6 mb-2 text-yellow-300";
    }

    function nextMission() {
        game.isRunning = false; 
        
        // 1. Advance Stage & Increase Fire Count (+2 more)
        game.missionStage = game.missionStage === 1 ? 2 : 1;
        game.fireBaseCount += 2; 

        // 2. Show Success Message and prepare for next stage
        gameMessage.textContent = `PHASE COMPLETE! Preparing Stage ${game.missionStage} with ${game.fireBaseCount} fires...`;
        gameMessage.className = "text-center text-lg font-bold h-6 mb-2 text-green-500";
        
        // 3. Wait 4 seconds then setup the next stage
        setTimeout(() => {
            setupMission(game.missionStage);
        }, 4000);
    }

    // --- Screen Management Functions ---

    function showScreen(screenName) {
        game.screen = screenName;

        startScreen.classList.add('hidden');
        optionsScreen.classList.add('hidden');
        gameContent.classList.add('hidden');
        
        if (screenName === 'start') {
            startScreen.classList.remove('hidden');
        } else if (screenName === 'options') {
            optionsScreen.classList.remove('hidden');
            loadOptions();
        } else if (screenName === 'game') {
            gameContent.classList.remove('hidden');
            initGame(); 
        }
    }

    function startGame() {
        showScreen('game');
    }
    
    function loadOptions() {
        document.getElementById('opt-gravity').value = CONFIG.GRAVITY;
        document.getElementById('gravity-value').textContent = CONFIG.GRAVITY.toFixed(2);
        document.getElementById('opt-thrust').value = CONFIG.THRUST_RATE;
        document.getElementById('thrust-value').textContent = CONFIG.THRUST_RATE.toFixed(2);
        document.getElementById('opt-crash-speed').value = CONFIG.CRASH_VELOCITY_Y;
        document.getElementById('crash-speed-value').textContent = CONFIG.CRASH_VELOCITY_Y.toFixed(1);
    }

    function saveOptions() {
        CONFIG.GRAVITY = parseFloat(document.getElementById('opt-gravity').value);
        CONFIG.THRUST_RATE = parseFloat(document.getElementById('opt-thrust').value);
        CONFIG.CRASH_VELOCITY_Y = parseFloat(document.getElementById('opt-crash-speed').value);
        showScreen('start');
    }

    // --- Game Loop and Render ---

    function updateCamera() {
        let targetCameraX = game.heli.x - CONFIG.CANVAS_WIDTH / 2;
        targetCameraX = Math.max(0, targetCameraX);
        targetCameraX = Math.min(CONFIG.WORLD_WIDTH - CONFIG.CANVAS_WIDTH, targetCameraX);
        game.cameraX += (targetCameraX - game.cameraX) * 0.1;
    }

    function updateUI() {
        const heli = game.heli;
        const fuelPercent = (heli.fuel / CONFIG.MAX_FUEL) * 100;
        const waterPercent = (heli.water / CONFIG.MAX_WATER) * 100;

        // Update Fuel Bar
        fuelBar.style.width = `${fuelPercent}%`;
        fuelDisplay.textContent = `${Math.round(fuelPercent)}%`;
        if (fuelPercent < 20) { fuelBar.className = "resource-bar bg-red-500 h-full"; } 
        else if (fuelPercent < 50) { fuelBar.className = "resource-bar bg-yellow-500 h-full"; } 
        else { fuelBar.className = "resource-bar bg-green-500 h-full"; }

        // Update Water Bar
        waterBar.style.width = `${waterPercent}%`;
        waterDisplay.textContent = `${Math.round(waterPercent)}%`;

        // Update other displays
        modeDisplay.textContent = game.playerMode.toUpperCase();
        vxDisplay.textContent = Math.abs(heli.vx).toFixed(2);
        vyDisplay.textContent = Math.abs(heli.vy).toFixed(2);
        firesDisplay.textContent = game.fires.length;
    }

    function gameLoop() {
        if (game.screen === 'game' && game.isRunning) {
            game.heli.update();
            updateDrops(); 
            checkCollisions();
            updateCamera();
            updateUI();
        } 
        
        // Always update explosions if we are in game screen (even if crashed)
        if (game.screen === 'game' && game.isCrash) {
             updateExplosions();
        }
        
        // Render
        if (game.screen === 'game') {
             ctx.clearRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
            
            drawTerrain();
            drawDrops(); 
            
            // Draw the landed helicopter FIRST if the player is on ground
            if (game.playerMode === 'ground') {
                drawLandedHeli();
            }

            if(game.heli) game.heli.draw(); // Draws the stick figure OR the flying heli
            
            drawExplosions(); // Draw explosion particles

            // Game Over/Win Overlay
            if (game.isCrash || game.isWin) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
                
                ctx.textAlign = 'center';
                ctx.font = '36px Inter';
                ctx.fillStyle = game.isCrash ? '#ef4444' : '#facc15';
                const message = game.isCrash ? 'MISSION FAILED' : 'ALL MISSIONS COMPLETE';
                ctx.fillText(message, CONFIG.CANVAS_WIDTH / 2, CONFIG.CANVAS_HEIGHT / 2 - 30);
                
                ctx.font = '18px Inter';
                ctx.fillStyle = '#ffffff';
                ctx.fillText(gameMessage.textContent, CONFIG.CANVAS_WIDTH / 2, CONFIG.CANVAS_HEIGHT / 2 + 10);
                
                ctx.font = '14px Inter';
                ctx.fillStyle = '#9ca3af';
                ctx.fillText('Press R to Restart', CONFIG.CANVAS_WIDTH / 2, CONFIG.CANVAS_HEIGHT / 2 + 40);
            }
        } else {
             ctx.clearRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
        }

        requestAnimationFrame(gameLoop);
    }

    function endGame(message, colorClass) {
        game.isRunning = false;
        gameMessage.textContent = message;
        gameMessage.className = `text-center text-lg font-bold h-6 mb-2 ${colorClass}`;
    }

    // --- Input Handlers ---
    function handleKeyDown(e) {
        const key = e.key.toLowerCase();
        
        if (game.screen === 'game') {
            game.keys[key] = true;
            
            if (key === ' ' || key === 'spacebar') {
                e.preventDefault();
                if (game.playerMode === 'heli') {
                    dropWater();
                } else if (game.playerMode === 'ground') {
                    squirtWater();
                }
            }
            
            if (key === 'e') {
                if (game.playerMode === 'heli' && game.isLanded && game.isRunning) {
                    // SAVE Heli position to landing spot
                    game.heliLandingPos.x = game.heli.x;
                    game.heliLandingPos.y = game.heli.y;

                    game.playerMode = 'ground';
                    // Stick figure starts near the heli
                    game.heli.y = getGroundY(game.heli.x) - 10; 
                    gameMessage.textContent = "Exited Helicopter. Use A/D to walk, E to re-enter.";
                    gameMessage.className = "text-center text-lg font-bold h-6 mb-2 text-cyan-400";
                } else if (game.playerMode === 'ground' && game.isRunning) {
                    if (isNearHeli()) {
                        game.playerMode = 'heli';
                        // RE-ENTER: Set player (heli) position to the saved landing spot
                        game.heli.x = game.heliLandingPos.x; 
                        game.heli.y = game.heliLandingPos.y; 
                        game.heli.vy = 0;
                        game.heli.vx = 0;
                        game.isLanded = true;
                        gameMessage.textContent = "Entered Helicopter. Ready for flight (W)!";
                        gameMessage.className = "text-center text-lg font-bold h-6 mb-2 text-cyan-400";
                    } else {
                        gameMessage.textContent = "Move closer to the landed helicopter to re-enter.";
                        gameMessage.className = "text-center text-lg font-bold h-6 mb-2 text-red-400";
                    }
                }
            }

            if (key === 'r' && (game.isCrash || game.isWin)) {
                game.missionStage = 1; 
                game.fireBaseCount = 4; 
                showScreen('start');
            }
        }
    }

    function handleKeyUp(e) {
        if (game.screen === 'game') {
            game.keys[e.key.toLowerCase()] = false;
        }
    }

    // --- Initialization ---

    function initGame() {
        canvas.width = CONFIG.CANVAS_WIDTH;
        canvas.height = CONFIG.CANVAS_HEIGHT;

        // Reset global game state for a clean start
        game.missionStage = 1;
        game.fireBaseCount = 4;
        game.isWin = false;
        game.isCrash = false;
        game.explosions = []; // Clear explosions on initialization

        generateTerrain(); 
        setupMission(game.missionStage);
        updateUI(); 
    }

    // Attach Event Listeners on load
    window.onload = function() {
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        
        showScreen('start');
        gameLoop();
    };

</script>

</body>
</html>
