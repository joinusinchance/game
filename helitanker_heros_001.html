<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Helitanker Lander - Multi-Stage</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the game environment */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1f2937; /* Dark background */
        }
        #gameCanvas {
            border: 2px solid #374151;
            background-color: #0b111a; /* Very dark background for the sky */
            display: block;
            margin: 0 auto;
        }
        .resource-bar {
            transition: width 0.3s ease-out;
        }
        .input-range {
            -webkit-appearance: none;
            width: 100%;
            height: 10px;
            border-radius: 5px;
            background: #4b5563;
            outline: none;
            opacity: 0.7;
            -webkit-transition: .2s;
            transition: opacity .2s;
        }
        .input-range::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            box-shadow: 0 0 5px #3b82f6;
        }
    </style>
</head>
<body>

<div id="app" class="p-4 sm:p-6 min-h-screen flex flex-col items-center">
    <h1 class="text-3xl font-bold text-yellow-400 mb-4 tracking-wider">HELITANKER RESCUE</h1>
    
    <!-- Start Screen -->
    <div id="start-screen" class="w-full max-w-sm bg-gray-800 p-8 rounded-xl shadow-2xl text-center text-white space-y-6">
        <h2 class="text-2xl font-semibold text-green-400">Mission Ready</h2>
        <button onclick="startGame()" class="w-full py-3 bg-green-600 hover:bg-green-700 rounded-lg text-lg font-bold shadow-md transition duration-200">
            Start Mission
        </button>
        <button onclick="showScreen('options')" class="w-full py-3 bg-blue-600 hover:bg-blue-700 rounded-lg text-lg font-bold shadow-md transition duration-200">
            Options
        </button>
        <p class="text-sm text-gray-400 pt-4">Press W/Up to fly, Space to drop water.</p>
    </div>

    <!-- Options Screen -->
    <div id="options-screen" class="w-full max-w-sm bg-gray-800 p-8 rounded-xl shadow-2xl text-white hidden">
        <h2 class="text-2xl font-semibold text-blue-400 mb-6 text-center">Game Options</h2>
        <div class="space-y-4">
            <!-- Gravity -->
            <div>
                <label for="opt-gravity" class="block text-sm font-medium text-gray-400 mb-1">Gravity Strength: <span id="gravity-value" class="text-yellow-300"></span></label>
                <input type="range" id="opt-gravity" min="0.01" max="0.3" step="0.01" class="input-range" oninput="document.getElementById('gravity-value').textContent = this.value">
            </div>
            <!-- Thrust Rate -->
            <div>
                <label for="opt-thrust" class="block text-sm font-medium text-gray-400 mb-1">Thrust Rate: <span id="thrust-value" class="text-yellow-300"></span></label>
                <input type="range" id="opt-thrust" min="0.05" max="0.3" step="0.01" class="input-range" oninput="document.getElementById('thrust-value').textContent = this.value">
            </div>
            <!-- Crash Speed -->
            <div>
                <label for="opt-crash-speed" class="block text-sm font-medium text-gray-400 mb-1">Max Safe Vertical Speed: <span id="crash-speed-value" class="text-yellow-300"></span></label>
                <input type="range" id="opt-crash-speed" min="0.5" max="2.5" step="0.1" class="input-range" oninput="document.getElementById('crash-speed-value').textContent = this.value">
            </div>
        </div>
        
        <div class="mt-8 flex justify-between space-x-4">
            <button onclick="showScreen('start')" class="flex-1 py-2 bg-gray-600 hover:bg-gray-700 rounded-lg font-semibold transition duration-200">
                Cancel
            </button>
            <button onclick="saveOptions()" class="flex-1 py-2 bg-green-600 hover:bg-green-700 rounded-lg font-bold shadow-md transition duration-200">
                Save & Back
            </button>
        </div>
    </div>

    <!-- Game Content (Status Panel and Canvas) -->
    <div id="game-content" class="w-full max-w-4xl flex flex-col items-center hidden">
        <!-- Game Status and Controls Display -->
        <div id="status-panel" class="w-full bg-gray-800 p-3 sm:p-4 rounded-xl shadow-2xl mb-4 text-white">
            <div id="game-message" class="text-center text-lg font-bold h-6 mb-2 text-green-400">Ready to Fly</div>
            
            <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-xs sm:text-sm">
                <!-- Mission Stage Display -->
                <div class="flex flex-col">
                    <span class="font-semibold text-gray-400">Mission Stage: <span id="stage-display" class="text-cyan-400 font-bold">1</span></span>
                    <span class="font-semibold text-gray-400">Fires Remaining: <span id="fires-display" class="text-red-400 font-bold">0</span></span>
                </div>
                
                <!-- Fuel Status -->
                <div class="flex flex-col">
                    <span class="font-semibold text-gray-400">Fuel: <span id="fuel-display">100%</span></span>
                    <div class="w-full bg-gray-700 h-3 rounded-full overflow-hidden mt-1">
                        <div id="fuel-bar" class="resource-bar bg-green-500 h-full" style="width: 100%;"></div>
                    </div>
                </div>

                <!-- Water Status -->
                <div class="flex flex-col">
                    <span class="font-semibold text-gray-400">Water: <span id="water-display">100%</span></span>
                    <div class="w-full bg-gray-700 h-3 rounded-full overflow-hidden mt-1">
                        <div id="water-bar" class="resource-bar bg-blue-500 h-full" style="width: 100%;"></div>
                    </div>
                </div>

                <!-- Velocity Indicators -->
                <div class="flex flex-col">
                    <span class="font-semibold text-gray-400">H-Speed: <span id="vx-display" class="text-yellow-400">0.00</span></span>
                    <span class="font-semibold text-gray-400">V-Speed: <span id="vy-display" class="text-red-400">0.00</span></span>
                </div>
            </div>
        </div>

        <!-- Canvas Container -->
        <canvas id="gameCanvas" width="800" height="400" class="rounded-xl shadow-xl"></canvas>
    </div>
</div>

<script>
    // --- Constants and Configuration ---
    const CONFIG = {
        CANVAS_WIDTH: 800,
        CANVAS_HEIGHT: 400,
        WORLD_WIDTH: 4000,
        
        // Customizable Options (Defaults)
        GRAVITY: 0.05,
        THRUST_RATE: 0.1,
        CRASH_VELOCITY_Y: 1.0, 

        // Fixed/Derived Options
        SIDE_THRUST_RATE: 0.05,
        FUEL_BURN: 0.05,
        WATER_DROP_COST: 5,
        MAX_VELOCITY: 5.0,
        PLAYER_SIZE: 20,
        MAX_FUEL: 100,
        MAX_WATER: 100,
        FIRE_RANGE: 40,
        WATER_DAMAGE_PER_DROP: 15, 
        SMALL_FIRE_LIFE: 15,
        LARGE_FIRE_LIFE: 60,
    };

    // --- DOM Element References ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const fuelBar = document.getElementById('fuel-bar');
    const waterBar = document.getElementById('water-bar');
    const fuelDisplay = document.getElementById('fuel-display');
    const waterDisplay = document.getElementById('water-display');
    const vxDisplay = document.getElementById('vx-display');
    const vyDisplay = document.getElementById('vy-display');
    const firesDisplay = document.getElementById('fires-display');
    const stageDisplay = document.getElementById('stage-display');
    const gameMessage = document.getElementById('game-message');
    
    // New Screen Refs
    const startScreen = document.getElementById('start-screen');
    const optionsScreen = document.getElementById('options-screen');
    const gameContent = document.getElementById('game-content');

    // --- Game State ---
    let game = {
        screen: 'start',
        isRunning: false,
        isLanded: false,
        isWin: false,
        isCrash: false,
        keys: {},
        terrain: [],
        fires: [],
        drops: [], 
        heli: null,
        cameraX: 0,
        missionStage: 1, // 1 or 2 (determines pad roles)
        fireBaseCount: 4, // Initial number of fires
        
        // Pad Definitions (fixed world coordinates)
        padA: { x: 50, y: 0, width: 80, label: "Left Pad" }, // Original Start Pad
        padB: { x: CONFIG.WORLD_WIDTH - 130, y: 0, width: 80, label: "Right Pad" }, // Original End Pad
        
        // Dynamic Pad Roles based on missionStage
        currentRefuelPad: null, 
        currentEndPad: null,
    };

    // --- Helitanker Object ---
    function HeliTanker() {
        // Position will be set dynamically in setupMission
        this.x = 0; 
        this.y = 50;
        this.vx = 0;
        this.vy = 0;
        this.fuel = CONFIG.MAX_FUEL;
        this.water = CONFIG.MAX_WATER;
    }

    HeliTanker.prototype.update = function() {
        // FIX: The early return when game.isLanded was preventing take-off thrust.
        // We now allow thrust input to be processed, which can unset game.isLanded.
        if (!game.isRunning || game.isCrash) return; 

        let thrustApplied = false;
        const isThrustingUp = game.keys['w'] || game.keys['ArrowUp'];

        // 1. Vertical Thrust Check (Allowed even when landed to initiate take-off)
        if (isThrustingUp) {
            if (this.fuel > 0) {
                // If landed and thrust is applied, we take off.
                if (game.isLanded) {
                    game.isLanded = false; 
                }
                this.vy -= CONFIG.THRUST_RATE;
                this.fuel = Math.max(0, this.fuel - CONFIG.FUEL_BURN);
                thrustApplied = true;
            }
        }

        // 2. If still landed (i.e., didn't press 'W' or 'Up'), stop movement and skip physics.
        if (game.isLanded) {
            this.vx = 0; 
            this.vy = 0; 
            return; 
        }

        // 3. Normal Flight Physics (Only runs if !game.isLanded)
        
        // Apply side thrust (A/Left and D/Right)
        if (game.keys['a'] || game.keys['ArrowLeft']) {
            if (this.fuel > 0) {
                this.vx -= CONFIG.SIDE_THRUST_RATE;
                this.fuel = Math.max(0, this.fuel - CONFIG.FUEL_BURN * 0.5);
                thrustApplied = true;
            }
        }
        if (game.keys['d'] || game.keys['ArrowRight']) {
            if (this.fuel > 0) {
                this.vx += CONFIG.SIDE_THRUST_RATE;
                this.fuel = Math.max(0, this.fuel - CONFIG.FUEL_BURN * 0.5);
                thrustApplied = true;
            }
        }

        // Apply Gravity (uses configurable GRAVITY)
        this.vy += CONFIG.GRAVITY;

        // Check fuel level
        if (this.fuel <= 0 && thrustApplied) {
            gameMessage.textContent = "CRITICAL: Out of Fuel! Gravity Pull.";
            gameMessage.className = "text-center text-lg font-bold h-6 mb-2 text-red-500";
        }

        // Apply velocity (Clamp velocity)
        this.vx = Math.max(-CONFIG.MAX_VELOCITY, Math.min(CONFIG.MAX_VELOCITY, this.vx));
        this.vy = Math.max(-CONFIG.MAX_VELOCITY, Math.min(CONFIG.MAX_VELOCITY, this.vy));
        
        this.x += this.vx;
        this.y += this.vy;
        
        // Prevent flying out of the world boundaries
        this.x = Math.max(CONFIG.PLAYER_SIZE / 2, Math.min(CONFIG.WORLD_WIDTH - CONFIG.PLAYER_SIZE / 2, this.x));
    };

    HeliTanker.prototype.draw = function() {
        const x = this.x - game.cameraX;
        const y = this.y;

        // Draw the main yellow block (Helitanker)
        ctx.fillStyle = '#facc15';
        ctx.fillRect(x - CONFIG.PLAYER_SIZE / 2, y - CONFIG.PLAYER_SIZE / 2, CONFIG.PLAYER_SIZE, CONFIG.PLAYER_SIZE);

        // Simple rotor effect (horizontal wobble)
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        const wobbleFactor = 0.5;
        const wobbleAmplitude = CONFIG.PLAYER_SIZE * 0.3;
        const wobbleOffset = Math.sin(Date.now() * 0.01 * wobbleFactor) * wobbleAmplitude; 
        
        const rotorY = y - CONFIG.PLAYER_SIZE / 2 - 5;
        const rotorSpan = CONFIG.PLAYER_SIZE * 1.5;
        
        ctx.moveTo(x - rotorSpan / 2 + wobbleOffset, rotorY);
        ctx.lineTo(x + rotorSpan / 2 + wobbleOffset, rotorY);
        
        ctx.stroke();

        // Draw water payload indicator
        ctx.fillStyle = '#3b82f6';
        const waterHeight = CONFIG.PLAYER_SIZE * (this.water / CONFIG.MAX_WATER) * 0.5;
        ctx.fillRect(x - 5, y + CONFIG.PLAYER_SIZE / 2 - waterHeight, 10, waterHeight);
    };

    // --- Water Drop Mechanic ---
    function dropWater() {
        if (!game.heli || !game.isRunning || game.isLanded) return;

        if (game.heli.water >= CONFIG.WATER_DROP_COST) {
            game.heli.water -= CONFIG.WATER_DROP_COST;
            
            const drop = {
                x: game.heli.x,
                y: game.heli.y + CONFIG.PLAYER_SIZE / 2,
                vy: 2,
                radius: 3,
                isHit: false
            };
            game.drops.push(drop);

        } else {
            gameMessage.textContent = "Water Empty! Find the REFUEL pad.";
            gameMessage.className = "text-center text-lg font-bold h-6 mb-2 text-red-400";
        }
    }
    
    // --- Drop Update Logic (Simplified for space) ---
    function updateDrops() {
        game.drops = game.drops.filter(drop => {
            if (drop.isHit) return false;
            drop.y += drop.vy;

            let hitFire = false;
            game.fires = game.fires.filter(fire => {
                const distSq = (fire.x - drop.x) ** 2 + (fire.y - drop.y) ** 2;
                if (distSq < (CONFIG.FIRE_RANGE * CONFIG.FIRE_RANGE)) {
                    fire.life -= CONFIG.WATER_DAMAGE_PER_DROP; 
                    hitFire = true;
                    drop.isHit = true;
                    return fire.life > 0;
                }
                return true;
            });

            if (hitFire) return false;

            // Check for ground hit 
            let terrainY = CONFIG.CANVAS_HEIGHT; 
            for (let i = 0; i < game.terrain.length - 1; i++) {
                const p1 = game.terrain[i];
                const p2 = game.terrain[i+1];
                if (drop.x >= p1.x && drop.x < p2.x) {
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const ratio = (drop.x - p1.x) / dx;
                    terrainY = p1.y + dy * ratio; 
                    break;
                }
            }

            if (drop.y + drop.radius >= terrainY) {
                return false; 
            }
            return true;
        });
        
        firesDisplay.textContent = game.fires.length;
    }
    
    // --- Drop Drawing Logic (FIX: Added missing function) ---
    function drawDrops() {
        game.drops.forEach(drop => {
            const x = drop.x - game.cameraX;
            const y = drop.y;
            ctx.fillStyle = '#3b82f6'; // Blue for water
            ctx.beginPath();
            ctx.arc(x, y, drop.radius, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    // --- Level Generation and Drawing ---

    function generateTerrain() {
        const worldPoints = [];
        const segmentLength = 50; 
        let variance = 0;

        // Simple Perlin-like noise generator for terrain
        for (let x = 0; x <= CONFIG.WORLD_WIDTH + segmentLength; x += segmentLength) {
            variance += Math.random() * 8 - 4; 
            variance = Math.max(-50, Math.min(50, variance)); 
            let y = CONFIG.CANVAS_HEIGHT * 0.8 + Math.sin(x / 300) * 40 + variance;
            worldPoints.push({ x: x, y: y });
        }
        game.terrain = worldPoints;
        
        // Update Pad Y positions based on terrain
        const findLandingY = (padX) => {
            for(let i=0; i < game.terrain.length - 1; i++) {
                if (game.terrain[i].x <= padX && game.terrain[i+1].x > padX) {
                    const dx = game.terrain[i+1].x - game.terrain[i].x;
                    const dy = game.terrain[i+1].y - game.terrain[i].y;
                    const ratio = (padX - game.terrain[i].x) / dx;
                    return game.terrain[i].y + dy * ratio;
                }
            }
            return CONFIG.CANVAS_HEIGHT * 0.8;
        }

        game.padA.y = findLandingY(game.padA.x);
        game.padB.y = findLandingY(game.padB.x);
    }
    
    function generateFires(count) {
        const newFires = [];
        const gap = (CONFIG.WORLD_WIDTH - 300) / count; // Spread fires across the middle of the map
        const findLandingY = (x) => {
            // Re-finding Y for fire placement
            for(let i=0; i < game.terrain.length - 1; i++) {
                if (game.terrain[i].x <= x && game.terrain[i+1].x > x) {
                    const dx = game.terrain[i+1].x - game.terrain[i].x;
                    const dy = game.terrain[i+1].y - game.terrain[i].y;
                    const ratio = (x - game.terrain[i].x) / dx;
                    return game.terrain[i].y + dy * ratio;
                }
            }
            return CONFIG.CANVAS_HEIGHT * 0.8;
        }

        for (let i = 0; i < count; i++) {
            const fireX = 150 + i * gap + (Math.random() * 50 - 25); // Add some randomness
            const life = i % 2 === 0 ? CONFIG.LARGE_FIRE_LIFE : CONFIG.SMALL_FIRE_LIFE;
            newFires.push({ 
                x: fireX, 
                y: findLandingY(fireX), 
                initialLife: life, 
                life: life 
            });
        }
        return newFires;
    }

    function drawTerrain() {
        ctx.fillStyle = '#4b5563'; // Gray-600 for terrain
        ctx.beginPath();
        
        ctx.moveTo(-game.cameraX, CONFIG.CANVAS_HEIGHT); 
        for (const point of game.terrain) {
            ctx.lineTo(point.x - game.cameraX, point.y);
        }
        ctx.lineTo(CONFIG.WORLD_WIDTH - game.cameraX, CONFIG.CANVAS_WIDTH);
        ctx.closePath();
        ctx.fill();

        // Draw pads dynamically
        [game.padA, game.padB].forEach(pad => {
            const isRefuel = pad === game.currentRefuelPad;
            const isEnd = pad === game.currentEndPad;
            
            ctx.fillStyle = isEnd ? '#dc2626' : (isRefuel ? '#22c55e' : '#4b5563'); // Red for End, Green for Refuel
            ctx.fillRect(pad.x - game.cameraX, pad.y, pad.width, 10);
            
            // Draw Pad Label
            ctx.fillStyle = '#ffffff';
            ctx.font = '12px Inter';
            const label = isEnd ? "END MISSION" : "START / REFUEL";
            ctx.fillText(label, pad.x + pad.width/2 - ctx.measureText(label).width/2 - game.cameraX, pad.y + 25);
        });

        // Draw fires
        game.fires.forEach(fire => {
            const x = fire.x - game.cameraX;
            const y = fire.y;
            const intensity = fire.life / fire.initialLife;

            ctx.fillStyle = `rgba(252, 165, 16, ${0.5 * intensity + (Math.random() * 0.3)})`;
            ctx.beginPath();
            ctx.arc(x, y - 10, 10 * intensity, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = `rgba(239, 68, 68, ${0.7 * intensity + (Math.random() * 0.2)})`;
            ctx.beginPath();
            ctx.arc(x, y - 5, 5 * intensity, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    // --- Collision Detection & Game Flow ---
    function checkCollisions() {
        const heli = game.heli;
        
        // 1. Terrain Collision Check (simplified terrain lookup)
        let terrainY = CONFIG.CANVAS_HEIGHT; 
        for (let i = 0; i < game.terrain.length - 1; i++) {
            const p1 = game.terrain[i];
            const p2 = game.terrain[i+1];
            if (heli.x > p1.x - 50 && heli.x < p2.x + 50) {
                const dx = p2.x - p1.x;
                const ratio = dx > 0 ? (heli.x - p1.x) / dx : 0;
                terrainY = p1.y + (p2.y - p1.y) * ratio;
                break;
            }
        }
        
        if (heli.y + CONFIG.PLAYER_SIZE / 2 >= terrainY) {
            // Ground hit!
            if (Math.abs(heli.vy) > CONFIG.CRASH_VELOCITY_Y) {
                game.isCrash = true;
                endGame("CRASH LANDING! Vertical speed was too high.", 'text-red-600');
            } else {
                // Safe landing
                heli.vy = 0;
                heli.vx *= 0.99;
                heli.y = terrainY - CONFIG.PLAYER_SIZE / 2;
                game.isLanded = true;
            }
        } else {
            game.isLanded = false;
        }

        // 2. Pad Interaction Check (only if landed safely and not crashed)
        if (game.isLanded && !game.isCrash) {
            const landedPad = [game.currentRefuelPad, game.currentEndPad].find(pad => 
                heli.x >= pad.x && heli.x <= pad.x + pad.width
            );

            if (landedPad) {
                if (landedPad === game.currentRefuelPad) {
                    // Refueling Pad Logic
                    if (heli.fuel < CONFIG.MAX_FUEL || heli.water < CONFIG.MAX_WATER) {
                        heli.fuel = Math.min(CONFIG.MAX_FUEL, heli.fuel + 0.5);
                        heli.water = Math.min(CONFIG.MAX_WATER, heli.water + 1.0);
                        gameMessage.textContent = "Refueling and Resupplying Water...";
                        gameMessage.className = "text-center text-lg font-bold h-6 mb-2 text-blue-400";
                    } else {
                        gameMessage.textContent = "Ready to fly. Land on the Red Pad to finish.";
                        gameMessage.className = "text-center text-lg font-bold h-6 mb-2 text-green-400";
                    }
                } else if (landedPad === game.currentEndPad) {
                    // End Pad Logic (BUG FIX & Next Stage Trigger)
                    if (game.fires.length === 0) {
                        // All fires are out - Trigger the next mission stage!
                        nextMission();
                    } else {
                        gameMessage.textContent = `Must extinguish ${game.fires.length} fires before finishing!`;
                        gameMessage.className = "text-center text-lg font-bold h-6 mb-2 text-red-400";
                    }
                }
            } else {
                 gameMessage.textContent = "Landed safely on terrain. Take off to move!";
                 gameMessage.className = "text-center text-lg font-bold h-6 mb-2 text-green-400";
            }
        }
    }


    // --- Mission Control Functions ---
    
    function setupMission(stage) {
        // Reset flight state
        game.isRunning = true;
        game.isLanded = false;
        game.isCrash = false;

        // 1. Determine Pad Roles based on Stage (The Swap)
        const [refuel, end] = stage === 1 
            ? [game.padA, game.padB] // Stage 1: Left is Refuel, Right is End
            : [game.padB, game.padA]; // Stage 2: Right is Refuel, Left is End

        game.currentRefuelPad = refuel;
        game.currentEndPad = end;
        
        // 2. Setup Heli (Reset position, fuel, and water)
        game.heli = new HeliTanker();
        game.heli.x = refuel.x + refuel.width / 2;
        game.heli.fuel = CONFIG.MAX_FUEL;
        game.heli.water = CONFIG.MAX_WATER;

        // 3. Generate Fires (re-generate)
        game.fires = generateFires(game.fireBaseCount);
        game.drops = [];

        // 4. Update UI Messages
        const message = `Stage ${stage}: Extinguish ${game.fires.length} fires. Head to the Red Pad (End) to finish.`;
        gameMessage.textContent = message;
        gameMessage.className = "text-center text-lg font-bold h-6 mb-2 text-yellow-300";
    }

    function nextMission() {
        game.isRunning = false; // Pause briefly
        
        // 1. Advance Stage & Increase Fire Count (+2 more)
        game.missionStage = game.missionStage === 1 ? 2 : 1;
        game.fireBaseCount += 2; 

        // 2. Show Success Message and prepare for next stage
        gameMessage.textContent = `PHASE COMPLETE! Preparing Stage ${game.missionStage} with ${game.fireBaseCount} fires...`;
        gameMessage.className = "text-center text-lg font-bold h-6 mb-2 text-green-500";
        
        // 3. Wait 4 seconds then setup the next stage
        setTimeout(() => {
            setupMission(game.missionStage);
        }, 4000);
    }

    // --- Screen Management Functions ---

    function showScreen(screenName) {
        game.screen = screenName;

        startScreen.classList.add('hidden');
        optionsScreen.classList.add('hidden');
        gameContent.classList.add('hidden');
        
        if (screenName === 'start') {
            startScreen.classList.remove('hidden');
        } else if (screenName === 'options') {
            optionsScreen.classList.remove('hidden');
            loadOptions();
        } else if (screenName === 'game') {
            gameContent.classList.remove('hidden');
            initGame(); // Initialize the game state when transitioning to the game screen
        }
    }

    function startGame() {
        showScreen('game');
    }
    
    // (loadOptions and saveOptions remain unchanged from previous response)
    function loadOptions() {
        document.getElementById('opt-gravity').value = CONFIG.GRAVITY;
        document.getElementById('gravity-value').textContent = CONFIG.GRAVITY.toFixed(2);
        document.getElementById('opt-thrust').value = CONFIG.THRUST_RATE;
        document.getElementById('thrust-value').textContent = CONFIG.THRUST_RATE.toFixed(2);
        document.getElementById('opt-crash-speed').value = CONFIG.CRASH_VELOCITY_Y;
        document.getElementById('crash-speed-value').textContent = CONFIG.CRASH_VELOCITY_Y.toFixed(1);
    }

    function saveOptions() {
        CONFIG.GRAVITY = parseFloat(document.getElementById('opt-gravity').value);
        CONFIG.THRUST_RATE = parseFloat(document.getElementById('opt-thrust').value);
        CONFIG.CRASH_VELOCITY_Y = parseFloat(document.getElementById('opt-crash-speed').value);
        showScreen('start');
    }

    // --- Game Loop and Render ---

    function updateCamera() {
        let targetCameraX = game.heli.x - CONFIG.CANVAS_WIDTH / 2;
        targetCameraX = Math.max(0, targetCameraX);
        targetCameraX = Math.min(CONFIG.WORLD_WIDTH - CONFIG.CANVAS_WIDTH, targetCameraX);
        game.cameraX += (targetCameraX - game.cameraX) * 0.1;
    }

    function updateUI() {
        const heli = game.heli;
        const fuelPercent = (heli.fuel / CONFIG.MAX_FUEL) * 100;
        const waterPercent = (heli.water / CONFIG.MAX_WATER) * 100;

        // Update Fuel Bar
        fuelBar.style.width = `${fuelPercent}%`;
        fuelDisplay.textContent = `${Math.round(fuelPercent)}%`;
        if (fuelPercent < 20) { fuelBar.className = "resource-bar bg-red-500 h-full"; } 
        else if (fuelPercent < 50) { fuelBar.className = "resource-bar bg-yellow-500 h-full"; } 
        else { fuelBar.className = "resource-bar bg-green-500 h-full"; }

        // Update Water Bar
        waterBar.style.width = `${waterPercent}%`;
        waterDisplay.textContent = `${Math.round(waterPercent)}%`;

        // Update other displays
        vxDisplay.textContent = Math.abs(heli.vx).toFixed(2);
        vyDisplay.textContent = Math.abs(heli.vy).toFixed(2);
        firesDisplay.textContent = game.fires.length;
        stageDisplay.textContent = game.missionStage;
    }

    function gameLoop() {
        if (game.screen === 'game' && game.isRunning) {
            game.heli.update();
            updateDrops(); 
            checkCollisions();
            updateCamera();
            updateUI();
        }
        
        // Render
        if (game.screen === 'game') {
             ctx.clearRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
            
            drawTerrain();
            drawDrops(); // This function call now correctly points to the added drawDrops function.
            if(game.heli) game.heli.draw();

            // Game Over/Win Overlay
            if (game.isCrash || game.isWin) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
                
                ctx.textAlign = 'center';
                ctx.font = '36px Inter';
                ctx.fillStyle = game.isCrash ? '#ef4444' : '#facc15';
                const message = game.isCrash ? 'MISSION FAILED' : 'ALL MISSIONS COMPLETE';
                ctx.fillText(message, CONFIG.CANVAS_WIDTH / 2, CONFIG.CANVAS_HEIGHT / 2 - 30);
                
                ctx.font = '18px Inter';
                ctx.fillStyle = '#ffffff';
                ctx.fillText(gameMessage.textContent, CONFIG.CANVAS_WIDTH / 2, CONFIG.CANVAS_HEIGHT / 2 + 10);
                
                ctx.font = '14px Inter';
                ctx.fillStyle = '#9ca3af';
                ctx.fillText('Press R to Restart', CONFIG.CANVAS_WIDTH / 2, CONFIG.CANVAS_HEIGHT / 2 + 40);
            }
        } else {
             ctx.clearRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
        }

        requestAnimationFrame(gameLoop);
    }

    function endGame(message, colorClass) {
        game.isRunning = false;
        gameMessage.textContent = message;
        gameMessage.className = `text-center text-lg font-bold h-6 mb-2 ${colorClass}`;
    }

    // --- Input Handlers ---
    function handleKeyDown(e) {
        const key = e.key.toLowerCase();
        
        if (game.screen === 'game') {
            game.keys[key] = true;
            if (key === ' ' || key === 'spacebar') {
                e.preventDefault();
                dropWater();
            }

            if (key === 'r' && (game.isCrash || game.isWin)) {
                game.missionStage = 1; // Reset stage for restart
                game.fireBaseCount = 4; // Reset fire count
                showScreen('start');
            }
        }
    }

    function handleKeyUp(e) {
        if (game.screen === 'game') {
            game.keys[e.key.toLowerCase()] = false;
        }
    }

    // --- Initialization ---

    function initGame() {
        canvas.width = CONFIG.CANVAS_WIDTH;
        canvas.height = CONFIG.CANVAS_HEIGHT;

        // Reset global game state for a clean start
        game.missionStage = 1;
        game.fireBaseCount = 4;
        game.isWin = false;
        game.isCrash = false;

        generateTerrain(); // Only need to generate terrain once
        setupMission(game.missionStage);
        updateUI(); 
    }

    // Attach Event Listeners on load
    window.onload = function() {
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        
        showScreen('start');
        gameLoop();
    };

</script>

</body>
</html>
