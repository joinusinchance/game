<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wordga</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght%40400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --cell-size: 10vw;
        }
        @media (min-width: 640px) {
            :root {
                --cell-size: 50px;
            }
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
            color: #1f2937;
        }
        .grid-cell {
            width: var(--cell-size);
            height: var(--cell-size);
            line-height: var(--cell-size);
            font-size: 5vw;
            text-transform: uppercase;
            font-weight: 700;
            border: 1px solid #d1d5db;
            transition: all 0.1s ease-in-out;
            cursor: pointer;
            user-select: none;
            text-align: center;
        }
        @media (min-width: 640px) {
            .grid-cell {
                font-size: 24px;
            }
        }
        .filled-cell {
            background-color: #e5e7eb;
            color: #1f2937;
        }
        .start-cell {
            background-color: #fcd34d !important; /* Amber-400 */
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(252, 211, 77, 0.8);
        }
        .possible-cell {
            background-color: #6ee7b7; /* Emerald-300 */
        }
        .placement-valid {
            background-color: #34d399 !important; /* Emerald-400 - Used for non-scoring overwrites */
        }
        .overlap-cell {
            background-color: #f97316 !important; /* Orange-600 for scoring overlap */
            color: white !important;
        }
        .message-box {
            min-height: 3rem; /* Reduced height for compactness */
            line-height: 1.25;
        }
        .button-confirm {
            transition: background-color 0.2s, transform 0.1s;
        }
        .button-confirm:hover:not(:disabled) {
            background-color: #059669;
        }
        .button-confirm:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        /* Word selection buttons */
        .word-btn {
            padding: 0.5rem 0.75rem; /* Reduced padding */
            font-size: 0.875rem; /* Reduced font size */
            font-weight: 600;
            text-transform: uppercase;
            border-radius: 9999px; /* Pill shape */
            transition: all 0.15s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            cursor: pointer;
            border: 2px solid transparent;
        }
        .word-btn:hover {
            opacity: 0.8;
        }
        .word-btn-default {
            background-color: #3b82f6; /* Blue-500 */
            color: white;
        }
        .word-btn-selected {
            background-color: #10b981; /* Emerald-500 */
            color: white;
            border-color: #fcd34d; /* Amber border */
            transform: scale(1.05);
            box-shadow: 0 0 8px rgba(16, 185, 129, 0.5);
        }
    </style>
</head>
<body class="p-3 flex flex-col items-center min-h-screen">

    <div class="max-w-xl w-full">
        <h1 class="text-2xl font-bold text-center mb-3 text-gray-800">Wordga</h1>

        <!-- Stats Row: Level | Score | Target -->
        <div class="flex justify-between items-center text-center mb-3 p-3 bg-white rounded-xl shadow-md border border-gray-100">
            <!-- Current Level -->
            <div>
                <p class="text-xs text-gray-500 font-medium">Level</p>
                <p id="current-level" class="text-xl font-extrabold text-yellow-700">1</p>
            </div>
            <!-- Current Score -->
            <div>
                <p class="text-xs text-gray-500 font-medium">Score</p>
                <p id="score" class="text-xl font-extrabold text-indigo-600">0</p>
            </div>
            <!-- Target Score -->
            <div>
                <p class="text-xs text-gray-500 font-medium">Target</p>
                <p id="target-score" class="text-xl font-extrabold text-red-600">25</p>
            </div>
        </div>
        
        <!-- Word Selection Buttons -->
        <div class="bg-white p-2 rounded-xl shadow-lg mb-3 flex flex-col border border-gray-200">
            <p class="text-center text-xs text-gray-500 font-medium mb-2">Select a Word to Place:</p>
            <div id="word-list-container" class="flex flex-wrap justify-center gap-2">
                <!-- Words will go here -->
            </div>
        </div>

        <!-- Game Grid -->
        <div id="game-grid" class="grid grid-cols-8 border border-gray-300 rounded-lg overflow-hidden shadow-2xl mb-3 mx-auto">
            <!-- Cells generated by JavaScript -->
        </div>

        <!-- Messaging & Controls (Combined for Mobile) -->
        <div class="bg-white p-3 rounded-xl shadow-lg border border-gray-200 relative">
            <div id="status-message-controls" class="relative">
                <!-- Message Box -->
                <div id="message-box" class="message-box text-center text-sm text-gray-700 mb-3 font-semibold">
                    Please select a word from the list above to begin placement.
                </div>

                <!-- 1. Standard Controls (Selecting/Placing - Default view) -->
                <div id="standard-controls" class="flex justify-between items-stretch space-x-1 sm:space-x-2">
                    
                    <!-- Left Group: Debug/Levels -->
                    <button id="open-debug-btn" class="bg-gray-600 text-white font-bold py-2 px-1 rounded-lg shadow-md hover:bg-gray-700 text-[10px] sm:text-sm whitespace-nowrap min-w-[18%]">
                        Levels
                    </button>
                    
                    <!-- Center Group: Undo / Reset -->
                    <div class="flex space-x-1 sm:space-x-2">
                        <button id="undo-btn" class="bg-red-400 text-white font-bold py-2 px-1 rounded-lg text-[10px] sm:text-sm shadow-md hover:bg-red-500" disabled>
                            Undo
                        </button>
                        <button id="reset-btn" class="bg-gray-400 text-white font-bold py-2 px-1 rounded-lg text-[10px] sm:text-sm shadow-md hover:bg-gray-500 hidden">
                            Reset
                        </button>
                    </div>
                    
                    <!-- Right Group: Confirm -->
                    <button id="confirm-btn" class="button-confirm bg-emerald-500 text-white font-bold py-2 px-2 rounded-lg text-xs sm:text-base shadow-md hover:shadow-lg flex-grow min-w-[45%]" disabled>
                        Place Word (+0)
                    </button>
                </div>
                
                <!-- 2. Game Over (Failure/Final Victory) Control -->
                <div id="game-over-failure" class="hidden">
                    <button id="try-again-btn" class="bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg shadow-lg hover:bg-indigo-700 text-base w-full">
                        Unsuccessful, try again?
                    </button>
                </div>

                <!-- 3. Level Success Controls -->
                <div id="level-success-controls" class="flex justify-center space-x-3 hidden">
                    <button id="share-success-btn" class="bg-yellow-500 text-white font-bold py-3 px-4 rounded-lg shadow-lg hover:bg-yellow-600 text-sm flex-1">
                        Share Score
                    </button>
                    <button id="next-level-btn" class="bg-emerald-600 text-white font-bold py-3 px-4 rounded-lg shadow-lg hover:bg-emerald-700 text-sm flex-1">
                        Next Level
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Debug Modal Overlay (minimal changes needed here, just updating button classes for consistency) -->
        <div id="debug-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center hidden">
            <!-- Modal Content -->
            <div class="bg-white p-6 rounded-xl shadow-2xl max-w-lg w-full m-4">
                <h2 class="text-2xl font-bold mb-4 text-indigo-600">Debug & Level Settings</h2>
                
                <!-- Level Selector -->
                <div class="mb-4">
                    <label for="level-select" class="block text-sm font-medium text-gray-700 mb-1">Select Level to Edit/Play:</label>
                    <select id="level-select" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500"></select>
                </div>

                <!-- Word Editor -->
                <div class="mb-4">
                    <label for="level-words" class="block text-sm font-medium text-gray-700 mb-1">Words (Comma Separated, Uppercase):</label>
                    <textarea id="level-words" rows="3" class="w-full p-2 border border-gray-300 rounded-lg font-mono text-sm"></textarea>
                    <p class="text-xs text-gray-500 mt-1">Example: WORD1,WORD2,LONGWORD (Max 8 letters each)</p>
                </div>

                <!-- Min Score Editor -->
                <div class="mb-6">
                    <label for="min-score" class="block text-sm font-medium text-gray-700 mb-1">Minimum Score to Pass:</label>
                    <input type="number" id="min-score" class="w-full p-2 border border-gray-300 rounded-lg" min="0">
                </div>

                <!-- Actions -->
                <div class="flex flex-col sm:flex-row justify-between space-y-3 sm:space-y-0 sm:space-x-3">
                    <button id="add-level-btn" class="bg-blue-500 text-white font-bold py-2 rounded-lg hover:bg-blue-600 transition flex-1 text-sm">
                        Add New Level
                    </button>
                    <button id="save-level-btn" class="bg-green-500 text-white font-bold py-2 rounded-lg hover:bg-green-600 transition flex-1 text-sm">
                        Save Changes
                    </button>
                    <button id="start-level-btn" class="bg-indigo-500 text-white font-bold py-2 rounded-lg hover:bg-indigo-600 transition flex-1 text-sm">
                        Start Selected Level
                    </button>
                    <button id="close-debug-btn" class="bg-gray-300 text-gray-800 font-bold py-2 rounded-lg hover:bg-gray-400 transition flex-1 text-sm">
                        Close
                    </button>
                </div>
                <p id="debug-message" class="text-center mt-3 text-sm font-medium hidden"></p>
            </div>
        </div>
    </div>

    <script>
        // --- Game Setup ---
        const GRID_SIZE = 8;
        const OVERLAP_BONUS = 5; 
        const BASE_SCORE_PER_LETTER = 0; 

        // Levels 1-9
        const LEVELS = [
            {
                level: 1,
                words: ["JUMBLE", "SCORE", "REUSE", "WORDS"],
                minScore: 25, 
            },
            {
                level: 2,
                words: ["QUANTUM", "PUZZLE", "BONUS", "MOBILE"],
                minScore: 25, 
            },
            {
                level: 3,
                words: ["OVERLAP", "WORDGRID", "CHALLENGE"],
                minScore: 20, 
            },
            {
                level: 4,
                words: ["GRID", "PUZZLE", "PLAY", "HIGH"],
                minScore: 15, 
            },
            {
                level: 5,
                words: ["CHESS", "ROOK", "KING", "QUEEN", "PAWN"],
                minScore: 30, 
            },
            {
                level: 6,
                words: ["HERES", "LOOKING", "AT", "YOU", "KID"],
                minScore: 25,
            },
            {
                level: 7,
                words: ["CALL", "ME", "ISHMAEL", "WHALE", "STORY"],
                minScore: 30,
            },
            {
                level: 8,
                words: ["MAY", "THE", "FORCE", "BE", "WITH", "YOU"],
                minScore: 25,
            },
            {
                level: 9,
                words: ["BEST", "WORST", "TIMES", "WAS", "CITIES", "TALE"],
                minScore: 40,
            }
        ];

        // Global State
        let grid = [];
        let score = 0;
        let wordsToPlace = [];
        let currentWord = '';
        // Added 'level_success' state
        let gameState = 'selecting_start'; // 'selecting_start', 'selecting_direction', 'review_placement', 'game_over', 'level_success'
        let currentLevelIndex = 0;
        let minScoreTarget = 0;

        let startPos = null;
        let endPos = null;
        let calculatedDirection = null;
        let placementResult = null;
        let placementHistory = [];

        // --- DOM Elements ---
        const gridContainer = document.getElementById('game-grid');
        const scoreDisplay = document.getElementById('score');
        const messageBox = document.getElementById('message-box');
        const confirmBtn = document.getElementById('confirm-btn');
        const resetBtn = document.getElementById('reset-btn');
        const undoBtn = document.getElementById('undo-btn');
        const openDebugBtn = document.getElementById('open-debug-btn');
        const currentLevelDisplay = document.getElementById('current-level');
        const targetScoreDisplay = document.getElementById('target-score');
        const wordListContainer = document.getElementById('word-list-container');
        
        // New/Updated Control Elements
        const standardControls = document.getElementById('standard-controls');
        const gameOverFailure = document.getElementById('game-over-failure');
        const tryAgainBtn = document.getElementById('try-again-btn'); // Replaces old new-game-btn
        const levelSuccessControls = document.getElementById('level-success-controls');
        const shareSuccessBtn = document.getElementById('share-success-btn');
        const nextLevelBtn = document.getElementById('next-level-btn');
        
        // Debug Modal Elements
        const debugModal = document.getElementById('debug-modal');
        const closeDebugBtn = document.getElementById('close-debug-btn');
        const levelSelect = document.getElementById('level-select');
        const levelWordsInput = document.getElementById('level-words');
        const minScoreInput = document.getElementById('min-score');
        const addLevelBtn = document.getElementById('add-level-btn'); 
        const saveLevelBtn = document.getElementById('save-level-btn');
        const startLevelBtn = document.getElementById('start-level-btn');
        const debugMessage = document.getElementById('debug-message');


        // --- Utility Functions ---

        /** Utility function to wrap coordinates (for toroidal grid). */
        function wrapCoord(coord) {
            const size = GRID_SIZE;
            return (coord % size + size) % size;
        }

        /**
         * Calculates the wrapped direction component (-1, 0, or 1) for a single axis.
         * Returns null if the move is not adjacent (wrapped or unwrapped).
         * @param {number} rawDiff - The raw difference between end and start coordinates (e.g., endR - startR).
         * @returns {number | null} - The wrapped direction component (-1, 0, 1) or null if invalid.
         */
        function getWrappedDirectionComponent(rawDiff) {
            const N = GRID_SIZE;
            
            if (rawDiff >= -1 && rawDiff <= 1) return rawDiff;
            
            if (rawDiff === (N - 1)) return -1;
            if (rawDiff === -(N - 1)) return 1; 
            
            return null;
        }


        // --- Core Functions ---

        /** Initializes the game state and UI. */
        function initGame() {
            grid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(''));
            score = 0;
            currentLevelIndex = 0; 
            currentWord = '';
            loadLevel(currentLevelIndex);
            gameState = 'selecting_start';
            placementHistory = [];
            renderGrid(); 
            renderUI();
            updateUndoButtonState();
            showMessage('Welcome! **Select a word** from the list above to begin placement.');
        }
        
        /** Loads the words and target score for a specific level. */
        function loadLevel(index) {
            if (index >= LEVELS.length) {
                gameState = 'game_over';
                showMessage(`You have completed all levels! Final Score: ${score}`);
                return;
            }
            
            const levelData = LEVELS[index];
            minScoreTarget = levelData.minScore;
            
            // Reset grid for a new level
            if (index > 0 || score === 0) { 
                grid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(''));
            }
            
            wordsToPlace = [...levelData.words].sort(() => 0.5 - Math.random());
            currentWord = '';
        }
        
        /** Renders the list of words available for placement, making them clickable. */
        function renderWordList() {
            wordListContainer.innerHTML = '';

            wordsToPlace.forEach(word => {
                const btn = document.createElement('button');
                btn.textContent = word;
                btn.classList.add('word-btn');

                if (word === currentWord) {
                    btn.classList.add('word-btn-selected');
                } else {
                    btn.classList.add('word-btn-default');
                    btn.addEventListener('click', () => selectWord(word));
                }

                wordListContainer.appendChild(btn);
            });
        }
        
        /** Selects a word for placement. */
        function selectWord(word) {
            startPos = null;
            endPos = null;
            calculatedDirection = null;
            placementResult = null;

            currentWord = word;
            gameState = 'selecting_start';
            showMessage(`Word **${currentWord}** selected. **Step 1:** Click any cell on the grid to choose the starting position.`);
            
            renderGrid();
            renderUI();
        }

        /** Renders the current state of the grid. */
        function renderGrid() {
            gridContainer.innerHTML = '';
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell flex items-center justify-center rounded-sm';
                    cell.id = `cell-${r}-${c}`;
                    cell.textContent = grid[r][c];

                    if (grid[r][c]) {
                        cell.classList.add('filled-cell');
                    } else {
                        cell.classList.remove('filled-cell');
                    }

                    if (gameState !== 'level_success' && gameState !== 'game_over') {
                        // Highlight placement based on game state
                        if (startPos && startPos.r === r && startPos.c === c) {
                            cell.classList.add('start-cell');
                        } else if (gameState === 'review_placement' && placementResult && placementResult.placements.some(p => p.r === r && p.c === c)) {
                            const placement = placementResult.placements.find(p => p.r === r && p.c === c);
                            if (placement.isOverlap) {
                                cell.classList.add('overlap-cell');
                            } else {
                                cell.classList.add('placement-valid');
                            }
                        } else if (gameState === 'selecting_direction' && startPos) {
                            const drRaw = r - startPos.r;
                            const dcRaw = c - startPos.c;
                            const dr = getWrappedDirectionComponent(drRaw);
                            const dc = getWrappedDirectionComponent(dcRaw);

                            const isDirectionValid = dr !== null && dc !== null && (dr === 0 || dc === 0) && (dr !== 0 || dc !== 0);

                            if (isDirectionValid) {
                                 cell.classList.add('possible-cell');
                            }
                        }
                    }

                    cell.addEventListener('click', () => handleCellClick(r, c));
                    gridContainer.appendChild(cell);
                }
            }
        }

        /** Updates non-grid UI elements and controls based on game state. */
        function renderUI() {
            scoreDisplay.textContent = score;

            const currentLevelData = LEVELS[currentLevelIndex];
            if (currentLevelData) {
                currentLevelDisplay.textContent = currentLevelData.level;
                targetScoreDisplay.textContent = currentLevelData.minScore;
            } else {
                 currentLevelDisplay.textContent = 'MAX';
                 targetScoreDisplay.textContent = '---';
            }

            renderWordList();

            // Control Visibility Logic
            gameOverFailure.classList.add('hidden');
            levelSuccessControls.classList.add('hidden');
            standardControls.classList.add('hidden');
            
            confirmBtn.disabled = true;
            resetBtn.classList.add('hidden');
            openDebugBtn.classList.remove('hidden'); // Default visible

            if (gameState === 'selecting_start' || gameState === 'selecting_direction') {
                standardControls.classList.remove('hidden');
                confirmBtn.textContent = `Place Word (+0)`;
            } else if (gameState === 'review_placement' && placementResult) {
                standardControls.classList.remove('hidden');
                confirmBtn.textContent = `Place Word (+${placementResult.totalScore})`;
                confirmBtn.disabled = false;
                resetBtn.classList.remove('hidden');
                openDebugBtn.classList.add('hidden');
            } else if (gameState === 'level_success') {
                levelSuccessControls.classList.remove('hidden');
                openDebugBtn.classList.add('hidden');
            } else if (gameState === 'game_over') { 
                gameOverFailure.classList.remove('hidden');
                openDebugBtn.classList.add('hidden');

                // Check for final victory vs. mid-level failure
                const isFinalVictory = currentLevelIndex >= LEVELS.length;

                if (isFinalVictory) {
                    tryAgainBtn.textContent = "Start New Game";
                } else {
                    tryAgainBtn.textContent = "Unsuccessful, try again?";
                }
            }
            
            updateUndoButtonState();
        }
        
        /** Updates the disabled state of the Undo button based on history. */
        function updateUndoButtonState() {
            // Undo is only available in standard placement modes
            const isPlacementMode = gameState === 'selecting_start' || gameState === 'selecting_direction' || gameState === 'review_placement';
            undoBtn.disabled = placementHistory.length === 0 || !isPlacementMode;
        }


        /**
         * Checks if a word placement is valid and calculates the score.
         * @returns {object} { isValid: boolean, totalScore: number, overlapCount: number, placements: array }
         */
        function checkPlacement(word, startR, startC, direction) {
            const length = word.length;
            const [dr, dc] = direction;
            let isValid = true; 
            let overlapCount = 0;
            let totalScore = 0;
            const placements = [];

            for (let i = 0; i < length; i++) {
                const rRaw = startR + i * dr;
                const cRaw = startC + i * dc;

                const r = wrapCoord(rRaw);
                const c = wrapCoord(cRaw);
                
                const letter = word[i];
                const existingLetter = grid[r][c] || '';

                let isOverlap = false;
                if (existingLetter) {
                    if (existingLetter === letter) {
                        isOverlap = true;
                        overlapCount++;
                        totalScore += OVERLAP_BONUS;
                    }
                } else {
                    totalScore += BASE_SCORE_PER_LETTER; 
                }

                placements.push({ r, c, letter, isOverlap });
            }

            return { isValid, totalScore, overlapCount, placements };
        }

        /** Checks if the level minimum score has been met and handles transitions. */
        function checkLevelCompletion() {
            const currentLevel = LEVELS[currentLevelIndex];
            
            if (score >= currentLevel.minScore) {
                // Level success - transition to success state 
                gameState = 'level_success';
                showMessage(`Level ${currentLevel.level} Passed! Score ${score} / Target ${currentLevel.minScore}. <span class="text-green-600 font-bold">CONGRATULATIONS!</span>`);
            } else {
                // Level failure
                gameState = 'game_over';
                showMessage(`<span class="text-red-600 font-bold">Level ${currentLevel.level} Failed!</span> You scored ${score} but needed ${currentLevel.minScore}.`);
            }
        }


        /** Updates the grid and score with the placed word. */
        function placeWord() {
            if (!placementResult || !placementResult.isValid) return;

            // 1. SAVE STATE FOR UNDO
            const savedGrid = grid.map(row => [...row]); 
            const savedWordsToPlace = [...wordsToPlace]; 
            const savedCurrentWord = currentWord;
            const savedScore = score;
            
            placementHistory.push({
                grid: savedGrid,
                score: savedScore,
                wordsToPlace: savedWordsToPlace,
                currentWord: savedCurrentWord,
                currentLevelIndex: currentLevelIndex,
            });
            
            const placedScore = placementResult.totalScore; 

            // 2. APPLY PLACEMENT
            placementResult.placements.forEach(p => {
                grid[p.r][p.c] = p.letter;
            });

            score += placedScore;

            // 3. CHECK NEXT WORD / LEVEL COMPLETION
            const placedWordIndex = wordsToPlace.indexOf(currentWord);
            if (placedWordIndex > -1) {
                wordsToPlace.splice(placedWordIndex, 1);
            }
            
            currentWord = '';

            if (wordsToPlace.length > 0) {
                gameState = 'selecting_start';
                startPos = null;
                endPos = null;
                calculatedDirection = null;
                
                showMessage(`Great move! Score +${placedScore}. Now, **select your next word** from the list below.`); 
                
                placementResult = null;
            } else {
                // All words for the current level are placed
                checkLevelCompletion(); 
            }

            renderGrid();
            renderUI();
        }
        
        /** Reverts the game state to the state before the last successful word placement. */
        function undoLastPlacement() {
            if (placementHistory.length === 0) return;

            const lastState = placementHistory.pop();
            
            grid = lastState.grid;
            score = lastState.score;
            wordsToPlace = lastState.wordsToPlace;
            currentWord = lastState.currentWord;
            currentLevelIndex = lastState.currentLevelIndex;
            minScoreTarget = LEVELS[currentLevelIndex].minScore;
            
            startPos = null;
            endPos = null;
            calculatedDirection = null;
            placementResult = null;
            
            gameState = 'selecting_start';
            
            const messageWord = currentWord ? currentWord : 'a word';
            showMessage(`Undo successful! Please **select ${messageWord}** to re-place.`);
            
            renderGrid();
            renderUI();
        }


        /**
         * Handles sharing the score via the Web Share API with a clipboard fallback.
         */
        async function shareScore() {
            const level = LEVELS[currentLevelIndex].level;
            // Message format: "I scored X on level Y in wordga can you beat my score?"
            const shareText = `I scored ${score} on level ${level} in Wordga. Can you beat my score?`;
            const shareUrl = window.location.href;

            const shareData = {
                title: 'Wordga Score Challenge!',
                text: shareText,
                url: shareUrl
            };

            if (navigator.share) {
                try {
                    await navigator.share(shareData);
                    showMessage(`Score successfully shared!`);
                } catch (error) {
                    // Check if the error is due to the user simply closing the dialog (AbortError)
                    if (error.name === 'AbortError') {
                        showMessage('Sharing <span class="text-yellow-600">cancelled</span> by user.');
                    } else {
                        console.error('Error sharing score:', error);
                        showMessage(`Sharing failed: <span class="text-red-600">${error.message}</span>`);
                    }
                }
            } else {
                // Clipboard Fallback (if navigator.share is not supported)
                const fallbackMessage = `${shareText} Play the game here: ${shareUrl}`;

                if (navigator.clipboard) {
                    navigator.clipboard.writeText(fallbackMessage).then(() => {
                        showMessage(`Web Share not supported. Score message copied to clipboard!`);
                    }).catch(() => {
                        // Older document.execCommand fallback
                        document.execCommand('copy', false, fallbackMessage); 
                        showMessage(`Web Share not supported. Score message copied to clipboard (fallback)!`);
                    });
                } else {
                    // Final fallback using document.execCommand
                    document.execCommand('copy', false, fallbackMessage); 
                    showMessage(`Web Share not supported. Score message copied to clipboard (manual)!`);
                }
            }
        }


        /** Advances to the next level. */
        function goToNextLevel() {
            // Check if user is at max level
            if (currentLevelIndex + 1 >= LEVELS.length) {
                // Final level was passed
                currentLevelIndex++; // Increment to exceed max index
                gameState = 'game_over'; // Transition to final victory state
                showMessage(`Fantastic! You beat all levels! Final Score: ${score}`);
            } else {
                currentLevelIndex++;
                loadLevel(currentLevelIndex);
                gameState = 'selecting_start';
                placementHistory = []; // Reset history for new grid
                showMessage(`Starting Level ${LEVELS[currentLevelIndex].level}! Score from previous levels persists.`);
            }
            renderGrid();
            renderUI();
        }


        /** Handles the click on any grid cell, driving the state machine. */
        function handleCellClick(r, c) {
            if (gameState !== 'selecting_start' && gameState !== 'selecting_direction') return;

            if (gameState === 'selecting_start') {
                if (!currentWord) {
                     showMessage('Please **select a word** from the list above before choosing a starting cell.');
                     return;
                }
                
                startPos = { r, c };
                gameState = 'selecting_direction';
                showMessage(`**Step 2:** Select an **adjacent cell** (H or V) to set the direction for the remaining letters of **${currentWord}**.`);
            } else if (gameState === 'selecting_direction') {
                endPos = { r, c };

                const drRaw = endPos.r - startPos.r;
                const dcRaw = endPos.c - startPos.c;

                const dr = getWrappedDirectionComponent(drRaw);
                const dc = getWrappedDirectionComponent(dcRaw);
                
                const isDirectionValid = dr !== null && dc !== null && (dr === 0 || dc === 0) && (dr !== 0 || dc !== 0);
                
                if (!isDirectionValid) {
                    const errorMessage = 'Invalid direction! You must select a cell that is **immediately adjacent** (horizontally or vertically) to the start cell, including wrap-around.';
                    showMessage(`<span class="text-red-600 font-bold">Placement Failed:</span> ${errorMessage}`);
                    return;
                }
                
                calculatedDirection = [dr, dc];
                placementResult = checkPlacement(currentWord, startPos.r, startPos.c, [dr, dc]);

                gameState = 'review_placement';
                showMessage(`Placement ready. Overlaps: <span class="text-orange-600 font-bold">${placementResult.overlapCount}</span>. Total score: <span class="text-emerald-600 font-bold"> +${placementResult.totalScore}</span>. Press 'Place Word' to confirm.`);
                
            }

            renderGrid();
            renderUI();
        }

        /** Resets the current word placement attempt. */
        function resetPlacement() {
            startPos = null;
            endPos = null;
            calculatedDirection = null;
            placementResult = null;
            gameState = 'selecting_start';
            showMessage(`Placement reset. Select a starting cell for the word: <span class="text-indigo-600">${currentWord}</span>`);
            renderGrid();
            renderUI();
        }

        /** Displays a message in the message box. */
        function showMessage(htmlText) {
            messageBox.innerHTML = htmlText;
        }

        // --- Debug / Level Setting Functions ---
        
        function displayDebugMessage(message, isError) {
             debugMessage.textContent = message;
             debugMessage.classList.remove('hidden', 'text-red-500', 'text-green-500');
             debugMessage.classList.add(isError ? 'text-red-500' : 'text-green-500');
        }

        function populateLevelSelector() {
            levelSelect.innerHTML = '';
            LEVELS.sort((a, b) => a.level - b.level).forEach(levelData => {
                const option = document.createElement('option');
                option.value = levelData.level;
                option.textContent = `Level ${levelData.level}`;
                levelSelect.appendChild(option);
            });
        }

        function loadLevelDataToEditor(levelNumber) {
            const levelData = LEVELS.find(l => l.level === parseInt(levelNumber));
            if (levelData) {
                levelWordsInput.value = levelData.words.join(', ');
                minScoreInput.value = levelData.minScore;
            } else {
                levelWordsInput.value = '';
                minScoreInput.value = '';
            }
            debugMessage.classList.add('hidden');
        }
        
        function addNewLevel() {
            const newLevelNumber = LEVELS.length > 0 ? Math.max(...LEVELS.map(l => l.level)) + 1 : 1;
            
            const newLevelData = {
                level: newLevelNumber,
                words: ["NEW", "LEVEL", "EDIT", "ME"],
                minScore: 10,
            };
            
            LEVELS.push(newLevelData);
            
            populateLevelSelector();
            
            levelSelect.value = newLevelNumber;
            loadLevelDataToEditor(newLevelNumber);
            
            displayDebugMessage(`New Level ${newLevelNumber} created. Edit the words/score and press 'Save Changes'.`, false);
        }

        function saveLevelChanges() {
            const levelNumber = parseInt(levelSelect.value);
            const levelIndex = LEVELS.findIndex(l => l.level === levelNumber);
            
            if (levelIndex === -1) return;

            const newWords = levelWordsInput.value.split(',')
                .map(w => w.trim().toUpperCase())
                .filter(w => w.length > 0 && w.length <= GRID_SIZE);
            
            const newMinScore = parseInt(minScoreInput.value);

            if (newWords.length === 0) {
                 displayDebugMessage("Error: Word list cannot be empty or words are too long (max 8 letters).", true);
                 return;
            }
            if (isNaN(newMinScore) || newMinScore < 0) {
                 displayDebugMessage("Error: Minimum score must be a non-negative number.", true);
                 return;
            }
            
            LEVELS[levelIndex].words = newWords;
            LEVELS[levelIndex].minScore = newMinScore;
            
            displayDebugMessage(`Level ${levelNumber} updated successfully!`, false);
            renderUI(); 
        }

        function startSelectedLevel() {
            const levelNumber = parseInt(levelSelect.value);
            const levelIndex = LEVELS.findIndex(l => l.level === levelNumber);

            if (levelIndex !== -1) {
                saveLevelChanges();

                score = 0; 
                currentLevelIndex = levelIndex;
                loadLevel(currentLevelIndex); 
                gameState = 'selecting_start';
                placementHistory = [];
                closeDebugScreen();
                renderGrid();
                renderUI();
                showMessage(`Debug: Starting game at **Level ${levelNumber}** with target score **${LEVELS[levelIndex].minScore}**.`);
            }
        }

        function openDebugScreen() {
            debugModal.classList.remove('hidden');
            populateLevelSelector();
            
            const levelToLoad = LEVELS[currentLevelIndex] ? LEVELS[currentLevelIndex].level : (LEVELS[0] ? LEVELS[0].level : 1); 
            
            if (LEVELS.length === 0) {
                addNewLevel();
            } else {
                 levelSelect.value = levelToLoad; 
                 loadLevelDataToEditor(levelToLoad);
            }
        }

        function closeDebugScreen() {
            debugModal.classList.add('hidden');
        }


        // --- Event Listeners ---
        confirmBtn.addEventListener('click', () => {
            if (gameState === 'review_placement') {
                placeWord();
            }
        });

        resetBtn.addEventListener('click', resetPlacement);
        undoBtn.addEventListener('click', undoLastPlacement);
        
        // New/Updated Control Listeners
        tryAgainBtn.addEventListener('click', initGame); // Used for both failure and final victory
        nextLevelBtn.addEventListener('click', goToNextLevel);
        shareSuccessBtn.addEventListener('click', shareScore);

        // Debug Controls
        openDebugBtn.addEventListener('click', openDebugScreen);
        closeDebugBtn.addEventListener('click', closeDebugScreen);
        levelSelect.addEventListener('change', (e) => loadLevelDataToEditor(e.target.value));
        addLevelBtn.addEventListener('click', addNewLevel); 
        saveLevelBtn.addEventListener('click', saveLevelChanges);
        startLevelBtn.addEventListener('click', startSelectedLevel);


        // --- Start Game on Load ---
        window.onload = initGame;
    </script>
</body>
</html>
