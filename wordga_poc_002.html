
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wordga Challenge</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght%40400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --cell-size: 10vw;
        }
        @media (min-width: 640px) {
            :root {
                --cell-size: 50px;
            }
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
            color: #1f2937;
        }
        .grid-cell {
            width: var(--cell-size);
            height: var(--cell-size);
            line-height: var(--cell-size);
            font-size: 5vw;
            text-transform: uppercase;
            font-weight: 700;
            border: 1px solid #d1d5db;
            transition: all 0.1s ease-in-out;
            cursor: pointer;
            user-select: none;
            text-align: center;
        }
        @media (min-width: 640px) {
            .grid-cell {
                font-size: 24px;
            }
        }
        .filled-cell {
            background-color: #e5e7eb;
            color: #1f2937;
        }
        .start-cell {
            background-color: #fcd34d !important; /* Amber-400 */
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(252, 211, 77, 0.8);
        }
        .possible-cell {
            background-color: #6ee7b7; /* Emerald-300 */
        }
        .placement-valid {
            background-color: #34d399 !important; /* Emerald-400 - Used for non-scoring overwrites */
        }
        .overlap-cell {
            background-color: #f97316 !important; /* Orange-600 for scoring overlap */
            color: white !important;
        }
        .message-box {
            min-height: 3rem; 
            line-height: 1.25;
        }
        .button-confirm {
            transition: background-color 0.2s, transform 0.1s;
        }
        .button-confirm:hover:not(:disabled) {
            background-color: #059669;
        }
        .button-confirm:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        /* Word selection buttons */
        .word-btn {
            padding: 0.5rem 0.75rem; 
            font-size: 0.875rem; 
            font-weight: 600;
            text-transform: uppercase;
            border-radius: 9999px; 
            transition: all 0.15s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            cursor: pointer;
            border: 2px solid transparent;
        }
        .word-btn:hover {
            opacity: 0.8;
        }
        .word-btn-default {
            background-color: #3b82f6; 
            color: white;
        }
        .word-btn-selected {
            background-color: #10b981; 
            color: white;
            border-color: #fcd34d; 
            transform: scale(1.05);
            box-shadow: 0 0 8px rgba(16, 185, 129, 0.5);
        }
    </style>
</head>
<body class="p-3 flex flex-col items-center min-h-screen">

    <!-- --- MAIN GAME VIEW --- -->
    <div id="main-game-view" class="max-w-xl w-full">
        
        <!-- Combined Navigation and Stats Header -->
        <div class="flex justify-between items-center mb-4 p-2 bg-white rounded-xl shadow-lg border border-gray-100">
            
            <!-- 1. About Button -->
            <!-- Desktop button (text) -->
            <button id="about-btn" class="bg-gray-200 text-gray-700 font-bold py-2 px-4 rounded-full shadow-md hover:bg-gray-300 text-sm transition hidden sm:block">
                About
            </button>
            <!-- Mobile button (icon) -->
            <button id="about-btn-mobile" class="sm:hidden bg-gray-200 text-gray-700 font-bold p-2 rounded-full shadow-md hover:bg-gray-300 transition text-sm flex items-center justify-center w-8 h-8">
                i
            </button>

            <!-- 2. Stats Block (Level | Score | Target) -->
            <div class="flex justify-around items-center text-center flex-grow mx-2">
                 <!-- Current Level -->
                <div class="min-w-[20%]">
                    <p class="text-[10px] sm:text-xs text-gray-500 font-medium">LEVEL</p>
                    <p id="current-level" class="text-base sm:text-xl font-extrabold text-yellow-700">1</p>
                </div>
                <!-- Current Score -->
                <div class="min-w-[30%]">
                    <p class="text-[10px] sm:text-xs text-gray-500 font-medium">SCORE</p>
                    <p id="score" class="text-base sm:text-xl font-extrabold text-indigo-600">0</p>
                </div>
                <!-- Target Score -->
                <div class="min-w-[20%]">
                    <p class="text-[10px] sm:text-xs text-gray-500 font-medium">TARGET</p>
                    <p id="target-score" class="text-base sm:text-xl font-extrabold text-red-600">25</p>
                </div>
            </div>

            <!-- 3. Settings Button -->
            <button id="settings-btn" class="bg-indigo-500 text-white font-bold py-2 px-3 rounded-full shadow-md hover:bg-indigo-600 transition text-sm flex items-center justify-center w-10 h-10">
                <!-- Gear Icon SVG -->
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-settings"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.39a2 2 0 0 0 .73 2.73l.15.08a2 2 0 0 1 1 1.73v.5a2 2 0 0 1-1 1.73l-.15.08a2 2 0 0 0-.73 2.73l.22.39a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.73v-.5a2 2 0 0 1 1-1.73l.15-.08a2 2 0 0 0 .73-2.73l-.22-.39a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>
            </button>
        </div>

        <!-- Main Status Display -->
        <div id="main-status-display" class="message-box bg-white p-3 rounded-xl shadow-md mb-3 text-center text-sm font-semibold text-gray-700 border border-gray-100">
            <!-- Initial message placed by JavaScript -->
        </div>

        <!-- Word Selection Buttons -->
        <div class="bg-white p-2 rounded-xl shadow-lg mb-3 flex flex-col border border-gray-200">
            <div id="word-list-container" class="flex flex-wrap justify-center gap-2">
                <!-- Words will go here -->
            </div>
        </div>

        <!-- Game Grid -->
        <div id="game-grid" class="grid grid-cols-8 border border-gray-300 rounded-lg overflow-hidden shadow-2xl mb-3 mx-auto">
            <!-- Cells generated by JavaScript -->
        </div>
        
        <!-- Controls -->
        <div class="bg-white p-3 rounded-xl shadow-lg border border-gray-200 relative">
            <div id="status-message-controls" class="relative">
                
                <!-- 1. Standard Controls (Selecting/Placing - Default view) -->
                <div id="standard-controls" class="flex justify-center items-stretch space-x-1 sm:space-x-2">
                    <!-- Daily Challenge Button (Visible only in Free Play) -->
                    <button id="daily-challenge-btn" class="bg-purple-600 text-white font-bold py-2 px-4 rounded-lg text-sm shadow-md hover:bg-purple-700 hidden">
                        Level a Day
                    </button>

                    <!-- Centered Undo Button -->
                    <button id="undo-btn" class="bg-red-400 text-white font-bold py-2 px-4 rounded-lg text-sm shadow-md hover:bg-red-500" disabled>
                        Undo Last Step
                    </button>
                </div>
                
                <!-- 2. Game Over (Failure/Final Victory) Control -->
                <div id="game-over-failure" class="flex justify-center space-x-3 hidden">
                    <button id="share-failure-btn" class="bg-yellow-500 text-white font-bold py-3 px-4 rounded-lg shadow-lg hover:bg-yellow-600 text-sm flex-1">
                        Share Score
                    </button>
                    <button id="try-again-btn" class="bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg shadow-lg hover:bg-indigo-700 text-base flex-1">
                        Try Again
                    </button>
                </div>

                <!-- 3. Level Success Controls -->
                <div id="level-success-controls" class="flex justify-center space-x-3 hidden">
                    <button id="share-success-btn" class="bg-yellow-500 text-white font-bold py-3 px-4 rounded-lg shadow-lg hover:bg-yellow-600 text-sm flex-1">
                        Share Score
                    </button>
                    <!-- Button text dynamically changed by JS -->
                    <button id="next-level-btn" class="bg-emerald-600 text-white font-bold py-3 px-4 rounded-lg shadow-lg hover:bg-emerald-700 text-sm flex-1">
                        Next Level
                    </button>
                </div>
            </div>
        </div>
    </div>


    <!-- --- ABOUT VIEW --- -->
    <div id="about-view" class="max-w-xl w-full p-4 bg-white rounded-xl shadow-2xl hidden">
        <h1 class="text-3xl font-bold text-center mb-4 text-indigo-600">The Worga Challenge</h1>
        <p class="text-gray-700 mb-4">Worga is a strategy word-placement game where your goal is to place a set of words onto an 8x8 grid to achieve a target score.</p>
        
        <h2 class="text-xl font-semibold mb-2 text-gray-800 border-b pb-1">How Scoring Works</h2>
        <ul class="list-disc list-inside space-y-2 mb-6 text-gray-700">
            <li>**Overlap Bonus:** You earn **5 points** for every letter in your word that is placed on top of an existing, matching letter on the grid. This is the primary way to score!</li>
            <li>**Placement:** Words must be placed horizontally or vertically.</li>
            <li>**Toroidal Grid:** The grid wraps around. A word placed on the edge can continue on the opposite side (e.g., from row 7 to row 0).</li>
        </ul>

        <h2 class="text-xl font-semibold mb-2 text-gray-800 border-b pb-1">Game Flow</h2>
        <ol class="list-decimal list-inside space-y-2 mb-6 text-gray-700">
            <li>Select one of your available words.</li>
            <li>Click a cell to set the **start position**. (Highlighted in <span class="text-yellow-600 font-bold">yellow</span>)</li>
            <li>Click an **adjacent** cell (H or V) to set the **direction**. (Possible cells are <span class="text-emerald-500 font-bold">green</span>). The word is automatically placed after this step.</li>
            <li>Use the **Undo Last Step** button to revert your last word placement or clear your current start position.</li>
            <li>Complete all words to meet the target score and advance!</li>
        </ol>

        <button id="back-from-about-btn" class="w-full bg-indigo-600 text-white font-bold py-3 mt-6 rounded-lg shadow-lg hover:bg-indigo-700 transition">
            Back to Game
        </button>
    </div>


    <!-- --- SETTINGS/LEVEL EDITOR VIEW --- -->
    <div id="settings-view" class="max-w-xl w-full p-4 bg-white rounded-xl shadow-2xl hidden">
        <h2 class="text-3xl font-bold mb-4 text-indigo-600 text-center">Settings & Level Editor (Free Play)</h2>
        <p class="text-sm text-gray-600 mb-4 text-center">Manage standard Free Play levels, words, and minimum scores, or generate a custom URL.</p>
        
        <!-- Level Selector -->
        <div class="mb-4">
            <label for="level-select" class="block text-sm font-medium text-gray-700 mb-1">Select Free Play Level to Edit/Play:</label>
            <select id="level-select" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500"></select>
        </div>

        <!-- Word Editor -->
        <div class="mb-4">
            <label for="level-words" class="block text-sm font-medium text-gray-700 mb-1">Words (Comma Separated, Uppercase):</label>
            <textarea id="level-words" rows="3" class="w-full p-2 border border-gray-300 rounded-lg font-mono text-sm"></textarea>
            <p class="text-xs text-gray-500 mt-1">Max 8 letters per word.</p>
        </div>

        <!-- Min Score Editor -->
        <div class="mb-6">
            <label for="min-score" class="block text-sm font-medium text-gray-700 mb-1">Minimum Score to Pass:</label>
            <input type="number" id="min-score" class="w-full p-2 border border-gray-300 rounded-lg" min="0">
        </div>

        <!-- Actions -->
        <div class="flex flex-col sm:flex-row justify-between space-y-3 sm:space-y-0 sm:space-x-3">
            <button id="add-level-btn" class="bg-blue-500 text-white font-bold py-2 rounded-lg hover:bg-blue-600 transition flex-1 text-sm">
                Add New Level
            </button>
            <button id="save-level-btn" class="bg-green-500 text-white font-bold py-2 rounded-lg hover:bg-green-600 transition flex-1 text-sm">
                Save Changes
            </button>
            <button id="start-level-btn" class="bg-indigo-500 text-white font-bold py-2 rounded-lg hover:bg-indigo-600 transition flex-1 text-sm">
                Start Selected Level
            </button>
            <button id="generate-url-btn" class="bg-purple-500 text-white font-bold py-2 rounded-lg hover:bg-purple-600 transition flex-1 text-sm">
                Generate Share Link
            </button>
        </div>
        
        <p id="debug-message" class="text-center mt-3 text-sm font-medium hidden"></p>

        <button id="back-from-settings-btn" class="w-full bg-gray-400 text-gray-800 font-bold py-3 mt-6 rounded-lg shadow-md hover:bg-gray-500 transition">
            Back to Current Game
        </button>
    </div>

    <script>
        // --- Game Setup ---
        const GRID_SIZE = 8;
        const OVERLAP_BONUS = 5; 
        const BASE_SCORE_PER_LETTER = 0; 

        // Define the master list of levels (Free Play Levels)
        const FREE_PLAY_LEVELS = [
            { id: 1, level: 1, words: ["JUMBLE", "SCORE", "REUSE", "WORDS"], minScore: 25 },
            { id: 2, level: 2, words: ["QUANTUM", "PUZZLE", "BONUS", "MOBILE"], minScore: 25 },
            { id: 3, level: 3, words: ["OVERLAP", "WORDGRID", "CHALLENGE"], minScore: 20 },
            { id: 4, level: 4, words: ["GRID", "PUZZLE", "PLAY", "HIGH"], minScore: 15 },
            { id: 5, level: 5, words: ["CHESS", "ROOK", "KING", "QUEEN", "PAWN"], minScore: 30 },
            { id: 6, level: 6, words: ["HERES", "LOOKING", "AT", "YOU", "KID"], minScore: 25 },
            { id: 7, level: 7, words: ["CALL", "ME", "ISHMAEL", "WHALE", "STORY"], minScore: 30 },
            { id: 8, level: 8, words: ["MAY", "THE", "FORCE", "BE", "WITH", "YOU"], minScore: 25 },
            { id: 9, level: 9, words: ["BEST", "WORST", "TIMES", "WAS", "CITIES", "TALE"], minScore: 40 },
            { id: 10, level: 10, words: ["BREAKFAST", "LUNCH", "BRUNCH", "SMOKE", "FOG", "SMOG"], minScore: 40 },
            { id: 11, level: 11, words: ["PARADE", "DRAPES", "SPAR", "READ"], minScore: 35 },
            { id: 12, level: 12, words: ["STRESSED", "DESSERTS", "RECALL", "LACKER"], minScore: 45 },
            { id: 13, level: 13, words: ["CENTRAL", "LETTER", "WORDS", "AXIS"], minScore: 30 },
            { id: 14, level: 14, words: ["ROPE", "OLIVE", "PIECES", "EVES", "CORE"], minScore: 50 }
        ];

        // Global State
        let grid = [];
        let score = 0;
        let wordsToPlace = [];
        let currentWord = '';
        let gameState = 'selecting_start'; // 'selecting_start', 'selecting_direction', 'game_over', 'level_success'
        let currentLevelIndex = 0; // Index into the current LEVELS array
        let minScoreTarget = 0;
        
        // This array will hold the level(s) currently being played.
        // It could be all 14 Free Play levels, a single Daily level, or a single Custom level.
        let LEVELS = [...FREE_PLAY_LEVELS]; 
        let gameMode = 'free_play'; // 'free_play', 'daily_challenge', 'custom'

        let startPos = null;
        let endPos = null;
        let calculatedDirection = null;
        let placementResult = null;
        let placementHistory = [];

        // --- DOM Elements ---
        const mainGameView = document.getElementById('main-game-view');
        const aboutView = document.getElementById('about-view');
        const settingsView = document.getElementById('settings-view');

        const gridContainer = document.getElementById('game-grid');
        const scoreDisplay = document.getElementById('score');
        const messageBox = document.getElementById('main-status-display'); 
        
        // Navigation Buttons
        const aboutBtn = document.getElementById('about-btn'); 
        const aboutBtnMobile = document.getElementById('about-btn-mobile');
        const settingsBtn = document.getElementById('settings-btn'); 
        
        const currentLevelDisplay = document.getElementById('current-level');
        const targetScoreDisplay = document.getElementById('target-score');
        const wordListContainer = document.getElementById('word-list-container');
        
        // Controls
        const standardControls = document.getElementById('standard-controls');
        const undoBtn = document.getElementById('undo-btn');
        const dailyChallengeBtn = document.getElementById('daily-challenge-btn'); 
        
        const gameOverFailure = document.getElementById('game-over-failure');
        const tryAgainBtn = document.getElementById('try-again-btn');
        const shareFailureBtn = document.getElementById('share-failure-btn');
        
        const levelSuccessControls = document.getElementById('level-success-controls');
        const shareSuccessBtn = document.getElementById('share-success-btn');
        const nextLevelBtn = document.getElementById('next-level-btn'); // Will become "Go to Free Play" in daily mode
        
        // Settings View Elements
        const backFromAboutBtn = document.getElementById('back-from-about-btn');
        const backFromSettingsBtn = document.getElementById('back-from-settings-btn');
        const levelSelect = document.getElementById('level-select');
        const levelWordsInput = document.getElementById('level-words');
        const minScoreInput = document.getElementById('min-score');
        const addLevelBtn = document.getElementById('add-level-btn'); 
        const saveLevelBtn = document.getElementById('save-level-btn');
        const startLevelBtn = document.getElementById('start-level-btn');
        const debugMessage = document.getElementById('debug-message');
        const generateUrlBtn = document.getElementById('generate-url-btn'); 


        // --- Navigation Function ---

        /** Switches the currently visible view. */
        function navigateTo(viewId) {
            const views = [mainGameView, aboutView, settingsView];
            views.forEach(view => view.classList.add('hidden'));

            const targetView = document.getElementById(viewId);
            if (targetView) {
                targetView.classList.remove('hidden');
            }
            
            // Special initialization for settings view
            if (viewId === 'settings-view') {
                openSettingsScreen();
            }
        }


        // --- Utility Functions ---
        
        /** Displays a temporary message in the main status display. */
        function showMessage(message) {
            if (messageBox) {
                // Remove any pre-existing text color classes for general messages
                messageBox.classList.remove('text-red-600', 'text-green-600', 'font-bold'); 
                
                // Use innerHTML to allow for simple inline formatting (like **bold** or <span class="text-green-600">)
                messageBox.innerHTML = message;
            } else {
                console.error("Message box element (main-status-display) not found.");
            }
        }

        /** Utility function to wrap coordinates (for toroidal grid). */
        function wrapCoord(coord) {
            const size = GRID_SIZE;
            return (coord % size + size) % size;
        }

        /** Calculates the wrapped direction component (-1, 0, or 1) for a single axis. */
        function getWrappedDirectionComponent(rawDiff) {
            const N = GRID_SIZE;
            
            if (rawDiff >= -1 && rawDiff <= 1) return rawDiff;
            
            if (rawDiff === (N - 1)) return -1;
            if (rawDiff === -(N - 1)) return 1; 
            
            return null;
        }
        
        /** Deterministically gets a level index from FREE_PLAY_LEVELS based on the day of the year. */
        function getDailyLevelIndex() {
            const today = new Date();
            // Get day of the year (1 to 366)
            const start = new Date(today.getFullYear(), 0, 1);
            const diff = today - start;
            const oneDay = 1000 * 60 * 60 * 24;
            const dayOfYear = Math.floor(diff / oneDay);

            // Use modulo to cycle through the available free play levels
            return dayOfYear % FREE_PLAY_LEVELS.length;
        }

        /** Parses URL parameters for custom level data (target score & words). 
         * If found and valid, it sets up the LEVELS array for custom mode.
         * @returns {boolean} True if a custom level was loaded.
         */
        function loadCustomLevelFromURL() {
            const params = new URLSearchParams(window.location.search);
            const urlTarget = params.get('target');
            const urlWords = params.get('words');

            if (urlTarget && urlWords) {
                const minScore = parseInt(urlTarget);
                const wordList = urlWords.split(',')
                    .map(w => decodeURIComponent(w).trim().toUpperCase())
                    .filter(w => w.length > 0 && w.length <= GRID_SIZE);

                if (isNaN(minScore) || minScore < 0 || wordList.length === 0) {
                    console.error("Invalid custom level parameters found in URL. Loading default Free Play.");
                    return false;
                }

                // Set up for custom mode
                LEVELS = [{
                    level: 'Custom', 
                    words: wordList,
                    minScore: minScore
                }];
                currentLevelIndex = 0;
                gameMode = 'custom';
                
                setTimeout(() => {
                    showMessage(`Loaded **Custom Challenge**! Target: ${minScore}. Words: ${wordList.join(', ')}. Play the challenge!`);
                }, 100);

                return true;
            }
            return false;
        }

        /** Helper function to copy link to clipboard (used in Settings view fallback). */
        function copyLinkToClipboard(text, message) {
            const el = document.createElement('textarea');
            el.value = text;
            el.setAttribute('readonly', '');
            el.style.position = 'absolute';
            el.style.left = '-9999px';
            document.body.appendChild(el);
            el.select();
            document.execCommand('copy');
            document.body.removeChild(el);
            displayDebugMessage(message, false);
        }

        // --- Core Functions ---

        /** Initializes the game state and UI for a specific mode. */
        function initGame(mode = 'free_play', startLevelIndex = 0) {
            // 1. Check for custom level in URL (Highest priority, only on initial load)
            if (window.location.search.includes('target=') && window.location.search.includes('words=') && LEVELS.length !== 1) {
                if (loadCustomLevelFromURL()) {
                    // Custom level loaded, gameMode is set to 'custom' and LEVELS is set.
                }
            }
            
            if (gameMode !== 'custom') {
                gameMode = mode;
                if (mode === 'daily_challenge') {
                    const dailyIndex = getDailyLevelIndex();
                    // LEVELS will contain only the daily level
                    LEVELS = [FREE_PLAY_LEVELS[dailyIndex]];
                    currentLevelIndex = 0;
                } else {
                    // Set up for Free Play (all levels)
                    LEVELS = [...FREE_PLAY_LEVELS];
                    currentLevelIndex = startLevelIndex;
                }
            }

            // Continue initialization
            grid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(''));
            score = 0; 
            
            loadLevel(currentLevelIndex);
            gameState = 'selecting_start';
            placementHistory = [];
            renderGrid(); 
            renderUI();
            updateUndoButtonState();
            navigateTo('main-game-view'); 
            
            if (gameMode === 'free_play') {
                 showMessage('Welcome! **Select a word** from the list above to begin placement, or try the Daily Challenge!');
            } else if (gameMode === 'daily_challenge') {
                 showMessage('Starting the **Level A Day** challenge! Achieve the target score to win.');
            } else if (gameMode === 'custom') {
                 // Message already handled by loadCustomLevelFromURL
            } else {
                 showMessage('Game Ready. Select a word to start!');
            }
        }
        
        /** Starts the Daily Challenge mode. */
        function startDailyChallenge() {
            initGame('daily_challenge');
        }
        
        /** Switches the game to Free Play mode starting at Level 1. */
        function goToFreePlay() {
            initGame('free_play', 0);
            showMessage(`Welcome back to **Free Play** mode! Select a word to start Level 1.`);
        }

        
        /** Loads the words and target score for a specific level. */
        function loadLevel(index) {
            if (index >= LEVELS.length) {
                gameState = 'game_over';
                showMessage(`You have completed all levels! Final Score: ${score}`);
                return;
            }
            
            const levelData = LEVELS[index];
            minScoreTarget = levelData.minScore;
            
            // Always reset the grid when loading a new level configuration
            grid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(''));
            
            wordsToPlace = [...levelData.words].sort(() => 0.5 - Math.random());
            currentWord = '';
        }
        
        /** Renders the list of words available for placement, making them clickable. */
        function renderWordList() {
            wordListContainer.innerHTML = '';

            wordsToPlace.forEach(word => {
                const btn = document.createElement('button');
                btn.textContent = word;
                btn.classList.add('word-btn');

                if (word === currentWord) {
                    btn.classList.add('word-btn-selected');
                } else {
                    btn.classList.add('word-btn-default');
                    btn.addEventListener('click', () => selectWord(word));
                }

                wordListContainer.appendChild(btn);
            });
        }
        
        /** Selects a word for placement. */
        function selectWord(word) {
            startPos = null;
            endPos = null;
            calculatedDirection = null;
            placementResult = null;

            currentWord = word;
            gameState = 'selecting_start';
            showMessage(`Word **${currentWord}** selected. **Step 1:** Click any cell on the grid to choose the starting position.`);
            
            renderGrid();
            renderUI();
        }

        /** Renders the current state of the grid. */
        function renderGrid() {
            gridContainer.innerHTML = '';
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell flex items-center justify-center rounded-sm';
                    cell.id = `cell-${r}-${c}`;
                    cell.textContent = grid[r][c];

                    if (grid[r][c]) {
                        cell.classList.add('filled-cell');
                    } else {
                        cell.classList.remove('filled-cell');
                    }

                    if (gameState !== 'level_success' && gameState !== 'game_over') {
                        // Highlight placement based on game state
                        if (startPos && startPos.r === r && startPos.c === c) {
                            cell.classList.add('start-cell');
                        } else if (gameState === 'selecting_direction' && startPos) {
                            const drRaw = r - startPos.r;
                            const dcRaw = c - startPos.c;
                            const dr = getWrappedDirectionComponent(drRaw);
                            const dc = getWrappedDirectionComponent(dcRaw);

                            const isDirectionValid = dr !== null && dc !== null && (dr === 0 || dc === 0) && (dr !== 0 || dc !== 0);

                            if (isDirectionValid) {
                                 cell.classList.add('possible-cell');
                            }
                        }
                    }

                    cell.addEventListener('click', () => handleCellClick(r, c));
                    gridContainer.appendChild(cell);
                }
            }
        }

        /** Updates non-grid UI elements and controls based on game state. */
        function renderUI() {
            scoreDisplay.textContent = score;

            const currentLevelData = LEVELS[currentLevelIndex];
            
            if (currentLevelData) {
                const levelDisplay = gameMode === 'daily_challenge' ? 'Daily' : (gameMode === 'custom' ? 'Custom' : currentLevelData.level);
                currentLevelDisplay.textContent = levelDisplay;
                targetScoreDisplay.textContent = currentLevelData.minScore;
            } else {
                 currentLevelDisplay.textContent = 'MAX';
                 targetScoreDisplay.textContent = '---';
            }

            renderWordList();

            // Control Visibility Logic
            gameOverFailure.classList.add('hidden');
            levelSuccessControls.classList.add('hidden');
            standardControls.classList.add('hidden');
            dailyChallengeBtn.classList.add('hidden');

            if (gameState === 'selecting_start' || gameState === 'selecting_direction') {
                standardControls.classList.remove('hidden');
                if (gameMode === 'free_play') {
                    dailyChallengeBtn.classList.remove('hidden');
                }
            } else if (gameState === 'level_success') {
                levelSuccessControls.classList.remove('hidden');
                if (gameMode === 'daily_challenge' || gameMode === 'custom') {
                    nextLevelBtn.textContent = 'Go to Free Play';
                    nextLevelBtn.removeEventListener('click', goToNextLevel);
                    nextLevelBtn.addEventListener('click', goToFreePlay);
                } else {
                    nextLevelBtn.textContent = 'Next Level';
                    nextLevelBtn.removeEventListener('click', goToFreePlay);
                    nextLevelBtn.addEventListener('click', goToNextLevel);
                }
            } else if (gameState === 'game_over') { 
                gameOverFailure.classList.remove('hidden');

                const isFinalVictory = currentLevelIndex >= LEVELS.length;

                if (isFinalVictory && gameMode === 'free_play') {
                    tryAgainBtn.textContent = "Start New Game";
                } else if (gameMode === 'daily_challenge' || gameMode === 'custom') {
                    tryAgainBtn.textContent = "Try Free Play";
                    tryAgainBtn.removeEventListener('click', initGame);
                    tryAgainBtn.addEventListener('click', goToFreePlay);
                } else {
                    tryAgainBtn.textContent = "Try Again";
                    tryAgainBtn.removeEventListener('click', goToFreePlay);
                    tryAgainBtn.addEventListener('click', initGame);
                }
            }
            
            updateUndoButtonState();
        }
        
        /** Updates the disabled state of the Undo button based on history. */
        function updateUndoButtonState() {
            const canUndoStep = startPos !== null; // Can undo if a start position is set
            const canUndoWord = placementHistory.length > 0; // Can undo a word if history exists
            undoBtn.disabled = !(canUndoStep || canUndoWord);
        }

        /**
         * Checks if a word placement is valid and calculates the score.
         * @returns {object} { isValid: boolean, totalScore: number, overlapCount: number, placements: array }
         */
        function checkPlacement(word, startR, startC, direction) {
            const length = word.length;
            const [dr, dc] = direction;
            let isValid = true; 
            let overlapCount = 0;
            let totalScore = 0;
            const placements = [];

            for (let i = 0; i < length; i++) {
                const rRaw = startR + i * dr;
                const cRaw = startC + i * dc;

                const r = wrapCoord(rRaw);
                const c = wrapCoord(cRaw);
                
                const letter = word[i];
                const existingLetter = grid[r][c] || '';

                let isOverlap = false;
                if (existingLetter) {
                    if (existingLetter === letter) {
                        isOverlap = true;
                        overlapCount++;
                        totalScore += OVERLAP_BONUS;
                    }
                } else {
                    totalScore += BASE_SCORE_PER_LETTER; 
                }

                placements.push({ r, c, letter, isOverlap });
            }

            return { isValid, totalScore, overlapCount, placements };
        }

        /** Checks if the level minimum score has been met and handles transitions. */
        function checkLevelCompletion() {
            const currentLevel = LEVELS[currentLevelIndex];
            const levelName = currentLevel.level === 'Custom' ? 'Custom Challenge' : (gameMode === 'daily_challenge' ? 'Daily Level' : `Level ${currentLevel.level}`);
            
            if (score >= currentLevel.minScore) {
                gameState = 'level_success';
                showMessage(`${levelName} Passed! Score ${score} / Target ${currentLevel.minScore}. <span class="text-green-600 font-bold">CONGRATULATIONS!</span>`);
            } else {
                gameState = 'game_over';
                showMessage(`<span class="text-red-600 font-bold">${levelName} Failed!</span> You scored ${score} but needed ${currentLevel.minScore}.`);
            }
        }


        /** Updates the grid and score with the placed word. */
        function placeWord() {
            if (!placementResult || !placementResult.isValid) return;

            // 1. SAVE STATE FOR UNDO
            const savedGrid = grid.map(row => [...row]); 
            const savedWordsToPlace = [...wordsToPlace]; 
            const savedCurrentWord = currentWord;
            const savedScore = score;
            const savedGameMode = gameMode;
            
            placementHistory.push({
                grid: savedGrid,
                score: savedScore,
                wordsToPlace: savedWordsToPlace,
                currentWord: savedCurrentWord,
                currentLevelIndex: currentLevelIndex,
                gameMode: savedGameMode
            });
            
            const placedScore = placementResult.totalScore; 

            // 2. APPLY PLACEMENT
            placementResult.placements.forEach(p => {
                grid[p.r][p.c] = p.letter;
            });

            score += placedScore;

            // 3. CHECK NEXT WORD / LEVEL COMPLETION
            const placedWordIndex = wordsToPlace.indexOf(currentWord);
            if (placedWordIndex > -1) {
                wordsToPlace.splice(placedWordIndex, 1);
            }
            
            currentWord = '';

            if (wordsToPlace.length > 0) {
                gameState = 'selecting_start';
                startPos = null;
                endPos = null;
                calculatedDirection = null;
                
                showMessage(`**${savedCurrentWord}** placed! Score +${placedScore}. Now, **select your next word**.`); 
                
                placementResult = null;
            } else {
                checkLevelCompletion(); 
            }

            renderGrid();
            renderUI();
        }
        
        /** Reverts the game state to the state before the last successful word placement, or undoes the current step. */
        function undoLastStep() {
            // Case 1: Undo the current step (clear start position if one is selected)
            if (gameState === 'selecting_direction' && startPos) {
                startPos = null;
                endPos = null;
                calculatedDirection = null;
                placementResult = null;
                // If a word was selected, return to selecting_start, otherwise don't change state.
                if (currentWord) {
                    gameState = 'selecting_start';
                    showMessage(`Step undone. Word **${currentWord}** still selected. Click any cell to choose a new starting position.`);
                } else {
                    showMessage(`Start position cleared. Select a word to begin.`);
                }
            } 
            // Case 2: Undo the last successfully placed word
            else if (placementHistory.length > 0) {
                const lastState = placementHistory.pop();
                
                grid = lastState.grid;
                score = lastState.score;
                wordsToPlace = lastState.wordsToPlace;
                currentWord = lastState.currentWord;
                currentLevelIndex = lastState.currentLevelIndex;
                gameMode = lastState.gameMode;
                minScoreTarget = LEVELS[currentLevelIndex].minScore;
                
                startPos = null;
                endPos = null;
                calculatedDirection = null;
                placementResult = null;
                
                gameState = 'selecting_start';
                
                const messageWord = currentWord ? currentWord : 'a word';
                showMessage(`Word undo successful. Please **select ${messageWord}** to re-place.`);
            } else {
                 // Nothing to undo
                 return;
            }

            renderGrid();
            renderUI();
        }

        /**
         * Handles sharing the score via the Web Share API with a clipboard fallback.
         */
        async function shareScore() {
            const levelType = gameMode === 'daily_challenge' ? 'Daily Challenge' : (gameMode === 'custom' ? 'Custom Challenge' : `Level ${LEVELS[currentLevelIndex].level}`);
            const shareText = `I scored ${score} on the ${levelType} in Wordga. Can you beat my score?`;
            
            // Use the current URL, which includes custom level parameters if present
            const shareUrl = window.location.href; 

            const shareData = {
                title: 'Wordga Score Challenge!',
                text: shareText,
                url: shareUrl
            };

            if (navigator.share) {
                try {
                    await navigator.share(shareData);
                    showMessage(`Score successfully shared!`);
                } catch (error) {
                    if (error.name === 'AbortError') {
                        showMessage('Sharing <span class="text-yellow-600">cancelled</span> by user.');
                    } else {
                        console.error('Error sharing score:', error);
                        // Fallback to clipboard if Web Share API fails for technical reasons
                        const fallbackMessage = `${shareText} Play the game here: ${shareUrl}`;
                        copyLinkToClipboard(fallbackMessage, `Sharing failed. Score message copied to clipboard!`);
                    }
                }
            } else {
                const fallbackMessage = `${shareText} Play the game here: ${shareUrl}`;
                copyLinkToClipboard(fallbackMessage, `Web Share not supported. Score message copied to clipboard!`);
            }
        }


        /** Advances to the next level in Free Play or switches to Free Play from Daily/Custom. */
        function goToNextLevel() {
            if (gameMode === 'daily_challenge' || gameMode === 'custom') {
                goToFreePlay();
                return;
            }

            // Free Play Logic
            if (currentLevelIndex + 1 >= LEVELS.length) {
                currentLevelIndex++;
                gameState = 'game_over';
                showMessage(`Fantastic! You beat all Free Play levels! Final Score: ${score}`);
            } else {
                currentLevelIndex++;
                score = 0; // Reset score for the new level
                loadLevel(currentLevelIndex);
                gameState = 'selecting_start';
                placementHistory = [];
                showMessage(`Starting Free Play Level ${LEVELS[currentLevelIndex].level}! Your new challenge begins now.`);
            }
            renderGrid();
            renderUI();
        }


        /** Handles the click on any grid cell, driving the state machine. */
        function handleCellClick(r, c) {
            if (gameState !== 'selecting_start' && gameState !== 'selecting_direction') return;

            if (gameState === 'selecting_start') {
                if (!currentWord) {
                     showMessage('Please **select a word** from the list above before choosing a starting cell.');
                     return;
                }
                
                startPos = { r, c };
                gameState = 'selecting_direction';
                showMessage(`**Step 2:** Select an **adjacent cell** (H or V) to set the direction for the remaining letters of **${currentWord}**.`);
                
                renderGrid();
                renderUI();
                return;

            } else if (gameState === 'selecting_direction') {
                endPos = { r, c };

                const drRaw = endPos.r - startPos.r;
                const dcRaw = endPos.c - startPos.c;

                const dr = getWrappedDirectionComponent(drRaw);
                const dc = getWrappedDirectionComponent(dcRaw);
                
                const isDirectionValid = dr !== null && dc !== null && (dr === 0 || dc === 0) && (dr !== 0 || dc !== 0);
                
                if (!isDirectionValid) {
                    const errorMessage = 'Invalid direction! You must select a cell that is **immediately adjacent** (horizontally or vertically) to the start cell, including wrap-around.';
                    showMessage(`<span class="text-red-600 font-bold">Placement Failed:</span> ${errorMessage}`);
                    return;
                }
                
                calculatedDirection = [dr, dc];
                placementResult = checkPlacement(currentWord, startPos.r, startPos.c, [dr, dc]);

                // Auto-place word instead of going to review state
                placeWord();
                return;
                
            }
        }


        // --- Settings / Level Setting Functions ---
        
        function displayDebugMessage(message, isError) {
             debugMessage.textContent = message;
             debugMessage.classList.remove('hidden', 'text-red-500', 'text-green-500');
             debugMessage.classList.add(isError ? 'text-red-500' : 'text-green-500');
        }

        function populateLevelSelector() {
            // Use FREE_PLAY_LEVELS for the editor
            levelSelect.innerHTML = '';
            FREE_PLAY_LEVELS.sort((a, b) => a.level - b.level).forEach(levelData => {
                const option = document.createElement('option');
                option.value = levelData.level;
                option.textContent = `Level ${levelData.level}`;
                levelSelect.appendChild(option);
            });
        }

        function loadLevelDataToEditor(levelNumber) {
            // Use FREE_PLAY_LEVELS for the editor
            const levelData = FREE_PLAY_LEVELS.find(l => l.level === parseInt(levelNumber));
            if (levelData) {
                levelWordsInput.value = levelData.words.join(', ');
                minScoreInput.value = levelData.minScore;
            } else {
                levelWordsInput.value = '';
                minScoreInput.value = '';
            }
            debugMessage.classList.add('hidden');
        }
        
        function addNewLevel() {
            const newLevelNumber = FREE_PLAY_LEVELS.length > 0 ? Math.max(...FREE_PLAY_LEVELS.map(l => l.level)) + 1 : 1;
            
            const newLevelData = {
                level: newLevelNumber,
                words: ["NEW", "LEVEL", "EDIT", "ME"],
                minScore: 10,
            };
            
            FREE_PLAY_LEVELS.push(newLevelData);
            
            populateLevelSelector();
            
            levelSelect.value = newLevelNumber;
            loadLevelDataToEditor(newLevelNumber);
            
            displayDebugMessage(`New Level ${newLevelNumber} created. Edit the words/score and press 'Save Changes'.`, false);
        }

        function saveLevelChanges(silent = false) {
            const levelNumber = parseInt(levelSelect.value);
            const levelIndex = FREE_PLAY_LEVELS.findIndex(l => l.level === levelNumber);
            
            if (levelIndex === -1) return;

            const newWords = levelWordsInput.value.split(',')
                .map(w => w.trim().toUpperCase())
                .filter(w => w.length > 0 && w.length <= GRID_SIZE);
            
            const newMinScore = parseInt(minScoreInput.value);

            if (newWords.length === 0) {
                 if (!silent) displayDebugMessage("Error: Word list cannot be empty or words are too long (max 8 letters).", true);
                 return;
            }
            if (isNaN(newMinScore) || newMinScore < 0) {
                 if (!silent) displayDebugMessage("Error: Minimum score must be a non-negative number.", true);
                 return;
            }
            
            FREE_PLAY_LEVELS[levelIndex].words = newWords;
            FREE_PLAY_LEVELS[levelIndex].minScore = newMinScore;
            
            if (!silent) {
                displayDebugMessage(`Free Play Level ${levelNumber} updated successfully!`, false);
            }
            renderUI(); 
        }

        function startSelectedLevel() {
            const levelNumber = parseInt(levelSelect.value);
            const levelIndex = FREE_PLAY_LEVELS.findIndex(l => l.level === levelNumber);

            if (levelIndex !== -1) {
                saveLevelChanges(true); // Save changes silently before starting

                // Start Free Play mode at the selected index
                initGame('free_play', levelIndex);
                showMessage(`Settings: Starting **Free Play** game at **Level ${levelNumber}** with target score **${FREE_PLAY_LEVELS[levelIndex].minScore}**.`);
            }
        }

        function openSettingsScreen() {
            populateLevelSelector();
            
            // Find the level index based on the current level number (for Free Play mode)
            const currentLevelNumber = LEVELS.length > 0 ? LEVELS[currentLevelIndex].level : 1; 
            const levelToLoad = FREE_PLAY_LEVELS.find(l => l.level === currentLevelNumber);
            
            if (FREE_PLAY_LEVELS.length === 0) {
                addNewLevel();
            } else {
                 levelSelect.value = levelToLoad ? levelToLoad.level : FREE_PLAY_LEVELS[0].level; 
                 loadLevelDataToEditor(levelSelect.value);
            }
        }
        
        /** Generates a shareable URL for the currently edited level, and attempts to share it. */
        async function generateShareLink() {
            const levelNumber = parseInt(levelSelect.value);
            const levelData = FREE_PLAY_LEVELS.find(l => l.level === levelNumber);
            
            if (!levelData) {
                displayDebugMessage("Error: Could not find current level data.", true);
                return;
            }

            // 1. Ensure latest changes are saved before generating the link
            saveLevelChanges(true); // Save silently

            const wordsParam = encodeURIComponent(levelData.words.join(','));
            const targetParam = levelData.minScore;
            
            // Construct the shareable URL
            const baseUrl = window.location.origin + window.location.pathname;
            const shareUrl = `${baseUrl}?target=${targetParam}&words=${wordsParam}`;
            
            const shareData = {
                title: 'Wordga Custom Challenge!',
                text: `Try to beat my custom Wordga level (Target: ${targetParam}, Words: ${levelData.words.length}).`,
                url: shareUrl
            };
            
            // 2. Attempt to use navigator.share (primary method)
            if (navigator.share) {
                try {
                    await navigator.share(shareData);
                    displayDebugMessage("Custom Challenge link shared successfully!", false);
                } catch (error) {
                    if (error.name === 'AbortError') {
                        displayDebugMessage("Sharing cancelled by user.", false);
                    } else {
                        // Technical failure, fall back to clipboard
                        console.error('Error sharing link via Web Share:', error);
                        copyLinkToClipboard(shareUrl, "Failed to use Web Share. Link copied to clipboard instead.");
                    }
                }
            } else {
                // 3. Fallback to clipboard
                copyLinkToClipboard(shareUrl, "Web Share not supported. Link copied to clipboard!");
            }
        }


        // --- Event Listeners ---
        undoBtn.addEventListener('click', undoLastStep);
        dailyChallengeBtn.addEventListener('click', startDailyChallenge);
        
        // Game Over Controls
        tryAgainBtn.addEventListener('click', initGame); // Handled dynamically in renderUI
        nextLevelBtn.addEventListener('click', goToNextLevel); // Handled dynamically in renderUI
        shareSuccessBtn.addEventListener('click', shareScore);
        shareFailureBtn.addEventListener('click', shareScore);

        // Navigation Controls
        aboutBtn.addEventListener('click', () => navigateTo('about-view'));
        aboutBtnMobile.addEventListener('click', () => navigateTo('about-view')); 
        settingsBtn.addEventListener('click', () => navigateTo('settings-view'));
        backFromAboutBtn.addEventListener('click', () => navigateTo('main-game-view'));
        backFromSettingsBtn.addEventListener('click', () => navigateTo('main-game-view'));

        // Settings Controls
        levelSelect.addEventListener('change', (e) => loadLevelDataToEditor(e.target.value));
        addLevelBtn.addEventListener('click', addNewLevel); 
        saveLevelBtn.addEventListener('click', () => saveLevelChanges(false));
        startLevelBtn.addEventListener('click', startSelectedLevel);
        generateUrlBtn.addEventListener('click', generateShareLink);


        // --- Start Game on Load ---
        window.onload = () => initGame(); 
    </script>
</body>
</html>
