<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wordga Challenge</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght%40400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --cell-size: 10vw;
        }
        @media (min-width: 640px) {
            :root {
                --cell-size: 50px;
            }
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
            color: #1f2937;
        }
        .grid-cell {
            width: var(--cell-size);
            height: var(--cell-size);
            line-height: var(--cell-size);
            font-size: 5vw;
            text-transform: uppercase;
            font-weight: 700;
            border: 1px solid #d1d5db;
            transition: all 0.1s ease-in-out;
            cursor: pointer;
            user-select: none;
            text-align: center;
        }
        @media (min-width: 640px) {
            .grid-cell {
                font-size: 24px;
            }
        }
        .filled-cell {
            background-color: #e5e7eb;
            color: #1f2937;
        }
        .start-cell {
            background-color: #fcd34d !important; /* Amber-400 */
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(252, 211, 77, 0.8);
        }
        .possible-cell {
            background-color: #6ee7b7; /* Emerald-300 */
        }
        .placement-valid {
            background-color: #34d399 !important; /* Emerald-400 - Used for non-scoring overwrites */
        }
        .overlap-cell {
            background-color: #f97316 !important; /* Orange-600 for scoring overlap */
            color: white !important;
        }
        .message-box {
            min-height: 3rem; 
            line-height: 1.25;
        }
        .button-confirm {
            transition: background-color 0.2s, transform 0.1s;
        }
        .button-confirm:hover:not(:disabled) {
            background-color: #059669;
        }
        .button-confirm:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        /* Word selection buttons */
        .word-btn {
            padding: 0.5rem 0.75rem; 
            font-size: 0.875rem; 
            font-weight: 600;
            text-transform: uppercase;
            border-radius: 9999px; 
            transition: all 0.15s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            cursor: pointer;
            border: 2px solid transparent;
        }
        .word-btn:hover {
            opacity: 0.8;
        }
        .word-btn-default {
            background-color: #3b82f6; 
            color: white;
        }
        .word-btn-selected {
            background-color: #10b981; 
            color: white;
            border-color: #fcd34d; 
            transform: scale(1.05);
            box-shadow: 0 0 8px rgba(16, 185, 129, 0.5);
        }
    </style>
</head>
<body class="p-3 flex flex-col items-center min-h-screen">

    <!-- --- MAIN GAME VIEW --- -->
    <div id="main-game-view" class="max-w-xl w-full">
        
        <!-- Combined Navigation and Stats Header -->
        <div class="flex justify-between items-center mb-4 p-2 bg-white rounded-xl shadow-lg border border-gray-100">
            
            <!-- 1. About Button -->
            <!-- Desktop button (text) -->
            <button id="about-btn" class="bg-gray-200 text-gray-700 font-bold py-2 px-4 rounded-full shadow-md hover:bg-gray-300 text-sm transition hidden sm:block">
                About
            </button>
            <!-- Mobile button (icon) -->
            <button id="about-btn-mobile" class="sm:hidden bg-gray-200 text-gray-700 font-bold p-2 rounded-full shadow-md hover:bg-gray-300 transition text-sm flex items-center justify-center w-8 h-8">
                i
            </button>

            <!-- 2. Stats Block (Level | Score | Target) -->
            <div class="flex justify-around items-center text-center flex-grow mx-2">
                 <!-- Current Level -->
                <div class="min-w-[20%]">
                    <p class="text-[10px] sm:text-xs text-gray-500 font-medium">LEVEL</p>
                    <p id="current-level" class="text-base sm:text-xl font-extrabold text-yellow-700">1</p>
                </div>
                <!-- Current Score -->
                <div class="min-w-[30%]">
                    <p class="text-[10px] sm:text-xs text-gray-500 font-medium">SCORE</p>
                    <p id="score" class="text-base sm:text-xl font-extrabold text-indigo-600">0</p>
                </div>
                <!-- Target Score -->
                <div class="min-w-[20%]">
                    <p class="text-[10px] sm:text-xs text-gray-500 font-medium">TARGET</p>
                    <p id="target-score" class="text-base sm:text-xl font-extrabold text-red-600">25</p>
                </div>
            </div>

            <!-- 3. Settings Button -->
            <button id="settings-btn" class="bg-indigo-500 text-white font-bold py-2 px-3 rounded-full shadow-md hover:bg-indigo-600 transition text-sm flex items-center justify-center w-10 h-10">
                <!-- Gear Icon SVG -->
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-settings"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.39a2 2 0 0 0 .73 2.73l.15.08a2 2 0 0 1 1 1.73v.5a2 2 0 0 1-1 1.73l-.15.08a2 2 0 0 0-.73 2.73l.22.39a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.73v-.5a2 2 0 0 1 1-1.73l.15-.08a2 2 0 0 0 .73-2.73l-.22-.39a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>
            </button>
        </div>

        <!-- Main Status Display -->
        <div id="main-status-display" class="message-box bg-white p-3 rounded-xl shadow-md mb-3 text-center text-sm font-semibold text-gray-700 border border-gray-100">
            <!-- Initial message placed by JavaScript -->
        </div>

        <!-- Word Selection Buttons -->
        <div class="bg-white p-2 rounded-xl shadow-lg mb-3 flex flex-col border border-gray-200">
            <div id="word-list-container" class="flex flex-wrap justify-center gap-2">
                <!-- Words will go here -->
            </div>
        </div>

        <!-- Game Grid -->
        <div id="game-grid" class="grid grid-cols-8 border border-gray-300 rounded-lg overflow-hidden shadow-2xl mb-3 mx-auto">
            <!-- Cells generated by JavaScript -->
        </div>
        
        <!-- Controls -->
        <div class="bg-white p-3 rounded-xl shadow-lg border border-gray-200 relative">
            <div id="status-message-controls" class="relative">
                
                <!-- 1. Standard Controls (Selecting/Placing - Default view) -->
                <div id="standard-controls" class="flex justify-between items-stretch space-x-1 sm:space-x-2">
                    
                    <!-- Left Group: Reserved Space -->
                    <div class="w-[18%] hidden sm:block"></div>
                    
                    <!-- Center Group: Undo / Reset -->
                    <div class="flex space-x-1 sm:space-x-2">
                        <button id="undo-btn" class="bg-red-400 text-white font-bold py-2 px-1 rounded-lg text-[10px] sm:text-sm shadow-md hover:bg-red-500" disabled>
                            Undo
                        </button>
                        <button id="reset-btn" class="bg-gray-400 text-white font-bold py-2 px-1 rounded-lg text-[10px] sm:text-sm shadow-md hover:bg-gray-500 hidden">
                            Reset
                        </button>
                    </div>
                    
                    <!-- Right Group: Confirm -->
                    <button id="confirm-btn" class="button-confirm bg-emerald-500 text-white font-bold py-2 px-2 rounded-lg text-xs sm:text-base shadow-md hover:shadow-lg flex-grow min-w-[45%]" disabled>
                        Place Word (+0)
                    </button>
                </div>
                
                <!-- 2. Game Over (Failure/Final Victory) Control -->
                <div id="game-over-failure" class="flex justify-center space-x-3 hidden">
                    <button id="share-failure-btn" class="bg-yellow-500 text-white font-bold py-3 px-4 rounded-lg shadow-lg hover:bg-yellow-600 text-sm flex-1">
                        Share Score
                    </button>
                    <button id="try-again-btn" class="bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg shadow-lg hover:bg-indigo-700 text-base flex-1">
                        Try Again
                    </button>
                </div>

                <!-- 3. Level Success Controls -->
                <div id="level-success-controls" class="flex justify-center space-x-3 hidden">
                    <button id="share-success-btn" class="bg-yellow-500 text-white font-bold py-3 px-4 rounded-lg shadow-lg hover:bg-yellow-600 text-sm flex-1">
                        Share Score
                    </button>
                    <button id="next-level-btn" class="bg-emerald-600 text-white font-bold py-3 px-4 rounded-lg shadow-lg hover:bg-emerald-700 text-sm flex-1">
                        Next Level
                    </button>
                </div>
            </div>
        </div>
    </div>


    <!-- --- ABOUT VIEW --- -->
    <div id="about-view" class="max-w-xl w-full p-4 bg-white rounded-xl shadow-2xl hidden">
        <h1 class="text-3xl font-bold text-center mb-4 text-indigo-600">The Worga Challenge</h1>
        <p class="text-gray-700 mb-4">Worga is a strategy word-placement game where your goal is to place a set of words onto an 8x8 grid to achieve a target score.</p>
        
        <h2 class="text-xl font-semibold mb-2 text-gray-800 border-b pb-1">How Scoring Works</h2>
        <ul class="list-disc list-inside space-y-2 mb-6 text-gray-700">
            <li>**Overlap Bonus:** You earn **5 points** for every letter in your word that is placed on top of an existing, matching letter on the grid. This is the primary way to score!</li>
            <li>**Placement:** Words must be placed horizontally or vertically.</li>
            <li>**Toroidal Grid:** The grid wraps around. A word placed on the edge can continue on the opposite side (e.g., from row 7 to row 0).</li>
        </ul>

        <h2 class="text-xl font-semibold mb-2 text-gray-800 border-b pb-1">Game Flow</h2>
        <ol class="list-decimal list-inside space-y-2 mb-6 text-gray-700">
            <li>Select one of your available words.</li>
            <li>Click a cell to set the **start position**. (Highlighted in <span class="text-yellow-600 font-bold">yellow</span>)</li>
            <li>Click an **adjacent** cell (up, down, left, or right) to set the **direction**. (Possible cells are <span class="text-emerald-500 font-bold">green</span>)</li>
            <li>Review the placement. Overlapping letters are highlighted in <span class="text-orange-600 font-bold">orange</span>.</li>
            <li>Press **Place Word** to confirm and add the score.</li>
            <li>Complete all words to meet the target score and advance!</li>
        </ol>

        <button id="back-from-about-btn" class="w-full bg-indigo-600 text-white font-bold py-3 mt-6 rounded-lg shadow-lg hover:bg-indigo-700 transition">
            Back to Game
        </button>
    </div>


    <!-- --- SETTINGS/LEVEL EDITOR VIEW --- -->
    <div id="settings-view" class="max-w-xl w-full p-4 bg-white rounded-xl shadow-2xl hidden">
        <h2 class="text-3xl font-bold mb-4 text-indigo-600 text-center">Settings & Level Editor</h2>
        <p class="text-sm text-gray-600 mb-4 text-center">Manage game levels, words, and minimum scores, or generate a custom URL.</p>
        
        <!-- Level Selector -->
        <div class="mb-4">
            <label for="level-select" class="block text-sm font-medium text-gray-700 mb-1">Select Level to Edit/Play:</label>
            <select id="level-select" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500"></select>
        </div>

        <!-- Word Editor -->
        <div class="mb-4">
            <label for="level-words" class="block text-sm font-medium text-gray-700 mb-1">Words (Comma Separated, Uppercase):</label>
            <textarea id="level-words" rows="3" class="w-full p-2 border border-gray-300 rounded-lg font-mono text-sm"></textarea>
            <p class="text-xs text-gray-500 mt-1">Max 8 letters per word. Words longer than 8 letters are ignored.</p>
        </div>

        <!-- Min Score Editor -->
        <div class="mb-6">
            <label for="min-score" class="block text-sm font-medium text-gray-700 mb-1">Minimum Score to Pass:</label>
            <input type="number" id="min-score" class="w-full p-2 border border-gray-300 rounded-lg" min="0">
        </div>

        <!-- Actions -->
        <div class="flex flex-col sm:flex-row justify-between space-y-3 sm:space-y-0 sm:space-x-3">
            <button id="add-level-btn" class="bg-blue-500 text-white font-bold py-2 rounded-lg hover:bg-blue-600 transition flex-1 text-sm">
                Add New Level
            </button>
            <button id="save-level-btn" class="bg-green-500 text-white font-bold py-2 rounded-lg hover:bg-green-600 transition flex-1 text-sm">
                Save Changes
            </button>
            <button id="start-level-btn" class="bg-indigo-500 text-white font-bold py-2 rounded-lg hover:bg-indigo-600 transition flex-1 text-sm">
                Start Selected Level
            </button>
            <button id="generate-url-btn" class="bg-purple-500 text-white font-bold py-2 rounded-lg hover:bg-purple-600 transition flex-1 text-sm">
                Generate Share Link
            </button>
        </div>
        
        <p id="debug-message" class="text-center mt-3 text-sm font-medium hidden"></p>

        <button id="back-from-settings-btn" class="w-full bg-gray-400 text-gray-800 font-bold py-3 mt-6 rounded-lg shadow-md hover:bg-gray-500 transition">
            Back to Current Game
        </button>
    </div>

    <script>
        // --- Game Setup ---
        const GRID_SIZE = 8;
        const OVERLAP_BONUS = 5; 
        const BASE_SCORE_PER_LETTER = 0; 

        // Default Levels Array - Will be overwritten if custom URL is present
        let LEVELS = [
            { level: 1, words: ["JUMBLE", "SCORE", "REUSE", "WORDS"], minScore: 25 },
            { level: 2, words: ["QUANTUM", "PUZZLE", "BONUS", "MOBILE"], minScore: 25 },
            { level: 3, words: ["OVERLAP", "WORDGRID", "CHALLENGE"], minScore: 20 },
            { level: 4, words: ["GRID", "PUZZLE", "PLAY", "HIGH"], minScore: 15 },
            { level: 5, words: ["CHESS", "ROOK", "KING", "QUEEN", "PAWN"], minScore: 30 },
            { level: 6, words: ["HERES", "LOOKING", "AT", "YOU", "KID"], minScore: 25 },
            { level: 7, words: ["CALL", "ME", "ISHMAEL", "WHALE", "STORY"], minScore: 30 },
            { level: 8, words: ["MAY", "THE", "FORCE", "BE", "WITH", "YOU"], minScore: 25 },
            { level: 9, words: ["BEST", "WORST", "TIMES", "WAS", "CITIES", "TALE"], minScore: 40 },
            { level: 10, words: ["BREAKFAST", "LUNCH", "BRUNCH", "SMOKE", "FOG", "SMOG"], minScore: 40 },
            { level: 11, words: ["PARADE", "DRAPES", "SPAR", "READ"], minScore: 35 },
            { level: 12, words: ["STRESSED", "DESSERTS", "RECALL", "LACKER"], minScore: 45 },
            { level: 13, words: ["CENTRAL", "LETTER", "WORDS", "AXIS"], minScore: 30 },
            { level: 14, words: ["ROPE", "OLIVE", "PIECES", "EVES", "CORE"], minScore: 50 }
        ];

        // Global State
        let grid = [];
        let score = 0;
        let wordsToPlace = [];
        let currentWord = '';
        let gameState = 'selecting_start'; // 'selecting_start', 'selecting_direction', 'review_placement', 'game_over', 'level_success'
        let currentLevelIndex = 0;
        let minScoreTarget = 0;

        let startPos = null;
        let endPos = null;
        let calculatedDirection = null;
        let placementResult = null;
        let placementHistory = [];

        // --- DOM Elements ---
        const mainGameView = document.getElementById('main-game-view');
        const aboutView = document.getElementById('about-view');
        const settingsView = document.getElementById('settings-view');

        const gridContainer = document.getElementById('game-grid');
        const scoreDisplay = document.getElementById('score');
        const messageBox = document.getElementById('main-status-display'); 
        const confirmBtn = document.getElementById('confirm-btn');
        const resetBtn = document.getElementById('reset-btn');
        const undoBtn = document.getElementById('undo-btn');
        
        // Navigation Buttons (updated to include mobile version)
        const aboutBtn = document.getElementById('about-btn'); 
        const aboutBtnMobile = document.getElementById('about-btn-mobile');
        const settingsBtn = document.getElementById('settings-btn'); 
        
        const currentLevelDisplay = document.getElementById('current-level');
        const targetScoreDisplay = document.getElementById('target-score');
        const wordListContainer = document.getElementById('word-list-container');
        
        const standardControls = document.getElementById('standard-controls');
        const gameOverFailure = document.getElementById('game-over-failure');
        const tryAgainBtn = document.getElementById('try-again-btn');
        const shareFailureBtn = document.getElementById('share-failure-btn');
        const levelSuccessControls = document.getElementById('level-success-controls');
        const shareSuccessBtn = document.getElementById('share-success-btn');
        const nextLevelBtn = document.getElementById('next-level-btn');
        
        // Settings View Elements
        const backFromAboutBtn = document.getElementById('back-from-about-btn');
        const backFromSettingsBtn = document.getElementById('back-from-settings-btn');
        const levelSelect = document.getElementById('level-select');
        const levelWordsInput = document.getElementById('level-words');
        const minScoreInput = document.getElementById('min-score');
        const addLevelBtn = document.getElementById('add-level-btn'); 
        const saveLevelBtn = document.getElementById('save-level-btn');
        const startLevelBtn = document.getElementById('start-level-btn');
        const debugMessage = document.getElementById('debug-message');
        const generateUrlBtn = document.getElementById('generate-url-btn'); // New button


        // --- Navigation Function ---

        /** Switches the currently visible view. */
        function navigateTo(viewId) {
            const views = [mainGameView, aboutView, settingsView];
            views.forEach(view => view.classList.add('hidden'));

            const targetView = document.getElementById(viewId);
            if (targetView) {
                targetView.classList.remove('hidden');
            }
            
            // Special initialization for settings view
            if (viewId === 'settings-view') {
                openSettingsScreen();
            }
        }


        // --- Utility Functions ---

        /** Utility function to wrap coordinates (for toroidal grid). */
        function wrapCoord(coord) {
            const size = GRID_SIZE;
            return (coord % size + size) % size;
        }

        /** Calculates the wrapped direction component (-1, 0, or 1) for a single axis. */
        function getWrappedDirectionComponent(rawDiff) {
            const N = GRID_SIZE;
            
            if (rawDiff >= -1 && rawDiff <= 1) return rawDiff;
            
            if (rawDiff === (N - 1)) return -1;
            if (rawDiff === -(N - 1)) return 1; 
            
            return null;
        }
        
        /** * Parses URL parameters for custom level data (target score & words). 
         * If found and valid, it overrides the LEVELS array.
         * @returns {boolean} True if a custom level was loaded.
         */
        function loadCustomLevelFromURL() {
            const params = new URLSearchParams(window.location.search);
            const urlTarget = params.get('target');
            const urlWords = params.get('words');

            if (urlTarget && urlWords) {
                const minScore = parseInt(urlTarget);
                const wordList = urlWords.split(',')
                    .map(w => decodeURIComponent(w).trim().toUpperCase())
                    .filter(w => w.length > 0 && w.length <= GRID_SIZE);

                // Basic validation
                if (isNaN(minScore) || minScore < 0 || wordList.length === 0) {
                    console.error("Invalid custom level parameters found in URL. Loading default levels.");
                    return false;
                }

                // Override LEVELS with the single custom level
                LEVELS = [{
                    level: 1, // Custom level is always level 1 in this session
                    words: wordList,
                    minScore: minScore
                }];
                
                currentLevelIndex = 0;
                
                // Show a confirmation message
                setTimeout(() => {
                    showMessage(`Loaded **Custom Challenge**! Target: ${minScore}. Words: ${wordList.join(', ')}. Play the challenge!`);
                }, 100);

                return true;
            }
            return false;
        }


        // --- Core Functions ---

        /** Initializes the game state and UI. */
        function initGame() {
            // 1. Check for custom level in URL
            const isCustomLevelLoaded = loadCustomLevelFromURL();

            // 2. Set default start if no custom level
            if (!isCustomLevelLoaded) {
                currentLevelIndex = 0; 
            }
            
            // Continue initialization
            grid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(''));
            score = 0; // Score always starts at 0 for the first loaded level
            
            // Load the determined starting level (custom or default)
            loadLevel(currentLevelIndex);
            gameState = 'selecting_start';
            placementHistory = [];
            renderGrid(); 
            renderUI();
            updateUndoButtonState();
            navigateTo('main-game-view'); 
            
            if (!isCustomLevelLoaded) {
                showMessage('Welcome! **Select a word** from the list above to begin placement.');
            }
        }
        
        /** Loads the words and target score for a specific level. */
        function loadLevel(index) {
            if (index >= LEVELS.length) {
                gameState = 'game_over';
                showMessage(`You have completed all levels! Final Score: ${score}`);
                return;
            }
            
            const levelData = LEVELS[index];
            minScoreTarget = levelData.minScore;
            
            // Always reset the grid when loading a new level configuration
            grid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(''));
            
            wordsToPlace = [...levelData.words].sort(() => 0.5 - Math.random());
            currentWord = '';
        }
        
        /** Renders the list of words available for placement, making them clickable. */
        function renderWordList() {
            wordListContainer.innerHTML = '';

            wordsToPlace.forEach(word => {
                const btn = document.createElement('button');
                btn.textContent = word;
                btn.classList.add('word-btn');

                if (word === currentWord) {
                    btn.classList.add('word-btn-selected');
                } else {
                    btn.classList.add('word-btn-default');
                    btn.addEventListener('click', () => selectWord(word));
                }

                wordListContainer.appendChild(btn);
            });
        }
        
        /** Selects a word for placement. */
        function selectWord(word) {
            startPos = null;
            endPos = null;
            calculatedDirection = null;
            placementResult = null;

            currentWord = word;
            gameState = 'selecting_start';
            showMessage(`Word **${currentWord}** selected. **Step 1:** Click any cell on the grid to choose the starting position.`);
            
            renderGrid();
            renderUI();
        }

        /** Renders the current state of the grid. */
        function renderGrid() {
            gridContainer.innerHTML = '';
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell flex items-center justify-center rounded-sm';
                    cell.id = `cell-${r}-${c}`;
                    cell.textContent = grid[r][c];

                    if (grid[r][c]) {
                        cell.classList.add('filled-cell');
                    } else {
                        cell.classList.remove('filled-cell');
                    }

                    if (gameState !== 'level_success' && gameState !== 'game_over') {
                        // Highlight placement based on game state
                        if (startPos && startPos.r === r && startPos.c === c) {
                            cell.classList.add('start-cell');
                        } else if (gameState === 'review_placement' && placementResult && placementResult.placements.some(p => p.r === r && p.c === c)) {
                            const placement = placementResult.placements.find(p => p.r === r && p.c === c);
                            if (placement.isOverlap) {
                                cell.classList.add('overlap-cell');
                            } else {
                                cell.classList.add('placement-valid');
                            }
                        } else if (gameState === 'selecting_direction' && startPos) {
                            const drRaw = r - startPos.r;
                            const dcRaw = c - startPos.c;
                            const dr = getWrappedDirectionComponent(drRaw);
                            const dc = getWrappedDirectionComponent(dcRaw);

                            const isDirectionValid = dr !== null && dc !== null && (dr === 0 || dc === 0) && (dr !== 0 || dc !== 0);

                            if (isDirectionValid) {
                                 cell.classList.add('possible-cell');
                            }
                        }
                    }

                    cell.addEventListener('click', () => handleCellClick(r, c));
                    gridContainer.appendChild(cell);
                }
            }
        }

        /** Updates non-grid UI elements and controls based on game state. */
        function renderUI() {
            scoreDisplay.textContent = score;

            const currentLevelData = LEVELS[currentLevelIndex];
            if (currentLevelData) {
                // If a custom level is loaded, show 'Custom' instead of the level number
                currentLevelDisplay.textContent = LEVELS.length === 1 && currentLevelData.level === 1 && window.location.search.includes('target=') ? 'Custom' : currentLevelData.level;
                targetScoreDisplay.textContent = currentLevelData.minScore;
            } else {
                 currentLevelDisplay.textContent = 'MAX';
                 targetScoreDisplay.textContent = '---';
            }

            renderWordList();

            // Control Visibility Logic
            gameOverFailure.classList.add('hidden');
            levelSuccessControls.classList.add('hidden');
            standardControls.classList.add('hidden');
            
            confirmBtn.disabled = true;
            resetBtn.classList.add('hidden');
            
            // Hide the reserved space placeholder
            document.querySelector('#standard-controls > div:first-child').classList.add('hidden');

            if (gameState === 'selecting_start' || gameState === 'selecting_direction') {
                standardControls.classList.remove('hidden');
                confirmBtn.textContent = `Place Word (+0)`;
            } else if (gameState === 'review_placement' && placementResult) {
                standardControls.classList.remove('hidden');
                confirmBtn.textContent = `Place Word (+${placementResult.totalScore})`;
                confirmBtn.disabled = false;
                resetBtn.classList.remove('hidden');
            } else if (gameState === 'level_success') {
                levelSuccessControls.classList.remove('hidden');
            } else if (gameState === 'game_over') { 
                gameOverFailure.classList.remove('hidden');

                const isFinalVictory = currentLevelIndex >= LEVELS.length;

                if (isFinalVictory) {
                    tryAgainBtn.textContent = "Start New Game";
                } else {
                    tryAgainBtn.textContent = "Try Again";
                }
            }
            
            updateUndoButtonState();
        }
        
        /** Updates the disabled state of the Undo button based on history. */
        function updateUndoButtonState() {
            const isPlacementMode = gameState === 'selecting_start' || gameState === 'selecting_direction' || gameState === 'review_placement';
            undoBtn.disabled = placementHistory.length === 0 || !isPlacementMode;
        }

        /**
         * Checks if a word placement is valid and calculates the score.
         * @returns {object} { isValid: boolean, totalScore: number, overlapCount: number, placements: array }
         */
        function checkPlacement(word, startR, startC, direction) {
            const length = word.length;
            const [dr, dc] = direction;
            let isValid = true; 
            let overlapCount = 0;
            let totalScore = 0;
            const placements = [];

            for (let i = 0; i < length; i++) {
                const rRaw = startR + i * dr;
                const cRaw = startC + i * dc;

                const r = wrapCoord(rRaw);
                const c = wrapCoord(cRaw);
                
                const letter = word[i];
                const existingLetter = grid[r][c] || '';

                let isOverlap = false;
                if (existingLetter) {
                    if (existingLetter === letter) {
                        isOverlap = true;
                        overlapCount++;
                        totalScore += OVERLAP_BONUS;
                    }
                } else {
                    totalScore += BASE_SCORE_PER_LETTER; 
                }

                placements.push({ r, c, letter, isOverlap });
            }

            return { isValid, totalScore, overlapCount, placements };
        }

        /** Checks if the level minimum score has been met and handles transitions. */
        function checkLevelCompletion() {
            const currentLevel = LEVELS[currentLevelIndex];
            
            if (score >= currentLevel.minScore) {
                gameState = 'level_success';
                showMessage(`Level ${LEVELS[currentLevelIndex].level} Passed! Score ${score} / Target ${currentLevel.minScore}. <span class="text-green-600 font-bold">CONGRATULATIONS!</span>`);
            } else {
                gameState = 'game_over';
                showMessage(`<span class="text-red-600 font-bold">Level ${LEVELS[currentLevelIndex].level} Failed!</span> You scored ${score} but needed ${currentLevel.minScore}.`);
            }
        }


        /** Updates the grid and score with the placed word. */
        function placeWord() {
            if (!placementResult || !placementResult.isValid) return;

            // 1. SAVE STATE FOR UNDO
            const savedGrid = grid.map(row => [...row]); 
            const savedWordsToPlace = [...wordsToPlace]; 
            const savedCurrentWord = currentWord;
            const savedScore = score;
            
            placementHistory.push({
                grid: savedGrid,
                score: savedScore,
                wordsToPlace: savedWordsToPlace,
                currentWord: savedCurrentWord,
                currentLevelIndex: currentLevelIndex,
            });
            
            const placedScore = placementResult.totalScore; 

            // 2. APPLY PLACEMENT
            placementResult.placements.forEach(p => {
                grid[p.r][p.c] = p.letter;
            });

            score += placedScore;

            // 3. CHECK NEXT WORD / LEVEL COMPLETION
            const placedWordIndex = wordsToPlace.indexOf(currentWord);
            if (placedWordIndex > -1) {
                wordsToPlace.splice(placedWordIndex, 1);
            }
            
            currentWord = '';

            if (wordsToPlace.length > 0) {
                gameState = 'selecting_start';
                startPos = null;
                endPos = null;
                calculatedDirection = null;
                
                showMessage(`Great move! Score +${placedScore}. Now, **select your next word** from the list above.`); 
                
                placementResult = null;
            } else {
                checkLevelCompletion(); 
            }

            renderGrid();
            renderUI();
        }
        
        /** Reverts the game state to the state before the last successful word placement. */
        function undoLastPlacement() {
            if (placementHistory.length === 0) return;

            const lastState = placementHistory.pop();
            
            grid = lastState.grid;
            score = lastState.score;
            wordsToPlace = lastState.wordsToPlace;
            currentWord = lastState.currentWord;
            currentLevelIndex = lastState.currentLevelIndex;
            minScoreTarget = LEVELS[currentLevelIndex].minScore;
            
            startPos = null;
            endPos = null;
            calculatedDirection = null;
            placementResult = null;
            
            gameState = 'selecting_start';
            
            const messageWord = currentWord ? currentWord : 'a word';
            showMessage(`Undo successful! Please **select ${messageWord}** to re-place.`);
            
            renderGrid();
            renderUI();
        }

        /**
         * Handles sharing the score via the Web Share API with a clipboard fallback.
         */
        async function shareScore() {
            const level = LEVELS.length === 1 && currentLevelIndex === 0 && window.location.search.includes('target=') ? 'Custom Challenge' : LEVELS[currentLevelIndex].level;
            const shareText = `I scored ${score} on ${level} in Wordga. Can you beat my score?`;
            
            // Use the current URL, which includes custom level parameters if present
            const shareUrl = window.location.href; 

            const shareData = {
                title: 'Wordga Score Challenge!',
                text: shareText,
                url: shareUrl
            };

            if (navigator.share) {
                try {
                    await navigator.share(shareData);
                    showMessage(`Score successfully shared!`);
                } catch (error) {
                    if (error.name === 'AbortError') {
                        showMessage('Sharing <span class="text-yellow-600">cancelled</span> by user.');
                    } else {
                        console.error('Error sharing score:', error);
                        showMessage(`Sharing failed: <span class="text-red-600">${error.message}</span>`);
                    }
                }
            } else {
                const fallbackMessage = `${shareText} Play the game here: ${shareUrl}`;
                const el = document.createElement('textarea');
                el.value = fallbackMessage;
                el.setAttribute('readonly', '');
                el.style.position = 'absolute';
                el.style.left = '-9999px';
                document.body.appendChild(el);
                el.select();
                document.execCommand('copy');
                document.body.removeChild(el);

                showMessage(`Web Share not supported. Score message copied to clipboard!`);
            }
        }


        /** Advances to the next level. */
        function goToNextLevel() {
            // Check if this is a custom level loaded from URL
            if (LEVELS.length === 1 && currentLevelIndex === 0 && window.location.search.includes('target=')) {
                // If it's a custom level, end the game after success.
                currentLevelIndex++; 
                gameState = 'game_over';
                showMessage(`Custom Challenge Complete! Final Score: ${score}`);
                return;
            }

            if (currentLevelIndex + 1 >= LEVELS.length) {
                currentLevelIndex++;
                gameState = 'game_over';
                showMessage(`Fantastic! You beat all levels! Final Score: ${score}`);
            } else {
                currentLevelIndex++;
                score = 0; // Reset score for the new level
                loadLevel(currentLevelIndex);
                gameState = 'selecting_start';
                placementHistory = [];
                showMessage(`Starting Level ${LEVELS[currentLevelIndex].level}! Your new challenge begins now.`);
            }
            renderGrid();
            renderUI();
        }


        /** Handles the click on any grid cell, driving the state machine. */
        function handleCellClick(r, c) {
            if (gameState !== 'selecting_start' && gameState !== 'selecting_direction') return;

            if (gameState === 'selecting_start') {
                if (!currentWord) {
                     showMessage('Please **select a word** from the list above before choosing a starting cell.');
                     return;
                }
                
                startPos = { r, c };
                gameState = 'selecting_direction';
                showMessage(`**Step 2:** Select an **adjacent cell** (H or V) to set the direction for the remaining letters of **${currentWord}**.`);
            } else if (gameState === 'selecting_direction') {
                endPos = { r, c };

                const drRaw = endPos.r - startPos.r;
                const dcRaw = endPos.c - startPos.c;

                const dr = getWrappedDirectionComponent(drRaw);
                const dc = getWrappedDirectionComponent(dcRaw);
                
                const isDirectionValid = dr !== null && dc !== null && (dr === 0 || dc === 0) && (dr !== 0 || dc !== 0);
                
                if (!isDirectionValid) {
                    const errorMessage = 'Invalid direction! You must select a cell that is **immediately adjacent** (horizontally or vertically) to the start cell, including wrap-around.';
                    showMessage(`<span class="text-red-600 font-bold">Placement Failed:</span> ${errorMessage}`);
                    return;
                }
                
                calculatedDirection = [dr, dc];
                placementResult = checkPlacement(currentWord, startPos.r, startPos.c, [dr, dc]);

                gameState = 'review_placement';
                showMessage(`Placement ready. Overlaps: <span class="text-orange-600 font-bold">${placementResult.overlapCount}</span>. Total score: <span class="text-emerald-600 font-bold"> +${placementResult.totalScore}</span>. Press 'Place Word' to confirm.`);
                
            }

            renderGrid();
            renderUI();
        }

        /** Resets the current word placement attempt. */
        function resetPlacement() {
            startPos = null;
            endPos = null;
            calculatedDirection = null;
            placementResult = null;
            gameState = 'selecting_start';
            showMessage(`Placement reset. Select a starting cell for the word: <span class="text-indigo-600">${currentWord}</span>`);
            renderGrid();
            renderUI();
        }

        /** Displays a message in the message box. */
        function showMessage(htmlText) {
            messageBox.innerHTML = htmlText;
        }

        // --- Settings / Level Setting Functions ---
        
        function displayDebugMessage(message, isError) {
             debugMessage.textContent = message;
             debugMessage.classList.remove('hidden', 'text-red-500', 'text-green-500');
             debugMessage.classList.add(isError ? 'text-red-500' : 'text-green-500');
        }

        function populateLevelSelector() {
            levelSelect.innerHTML = '';
            LEVELS.sort((a, b) => a.level - b.level).forEach(levelData => {
                const option = document.createElement('option');
                option.value = levelData.level;
                option.textContent = `Level ${levelData.level}`;
                levelSelect.appendChild(option);
            });
        }

        function loadLevelDataToEditor(levelNumber) {
            const levelData = LEVELS.find(l => l.level === parseInt(levelNumber));
            if (levelData) {
                levelWordsInput.value = levelData.words.join(', ');
                minScoreInput.value = levelData.minScore;
            } else {
                levelWordsInput.value = '';
                minScoreInput.value = '';
            }
            debugMessage.classList.add('hidden');
        }
        
        function addNewLevel() {
            const newLevelNumber = LEVELS.length > 0 ? Math.max(...LEVELS.map(l => l.level)) + 1 : 1;
            
            const newLevelData = {
                level: newLevelNumber,
                words: ["NEW", "LEVEL", "EDIT", "ME"],
                minScore: 10,
            };
            
            LEVELS.push(newLevelData);
            
            populateLevelSelector();
            
            levelSelect.value = newLevelNumber;
            loadLevelDataToEditor(newLevelNumber);
            
            displayDebugMessage(`New Level ${newLevelNumber} created. Edit the words/score and press 'Save Changes'.`, false);
        }

        function saveLevelChanges() {
            const levelNumber = parseInt(levelSelect.value);
            const levelIndex = LEVELS.findIndex(l => l.level === levelNumber);
            
            if (levelIndex === -1) return;

            const newWords = levelWordsInput.value.split(',')
                .map(w => w.trim().toUpperCase())
                .filter(w => w.length > 0 && w.length <= GRID_SIZE);
            
            const newMinScore = parseInt(minScoreInput.value);

            if (newWords.length === 0) {
                 displayDebugMessage("Error: Word list cannot be empty or words are too long (max 8 letters).", true);
                 return;
            }
            if (isNaN(newMinScore) || newMinScore < 0) {
                 displayDebugMessage("Error: Minimum score must be a non-negative number.", true);
                 return;
            }
            
            LEVELS[levelIndex].words = newWords;
            LEVELS[levelIndex].minScore = newMinScore;
            
            displayDebugMessage(`Level ${levelNumber} updated successfully!`, false);
            renderUI(); 
        }

        function startSelectedLevel() {
            const levelNumber = parseInt(levelSelect.value);
            const levelIndex = LEVELS.findIndex(l => l.level === levelNumber);

            if (levelIndex !== -1) {
                saveLevelChanges();

                score = 0; // Score reset for starting a specific level
                currentLevelIndex = levelIndex;
                loadLevel(currentLevelIndex); 
                gameState = 'selecting_start';
                placementHistory = [];
                navigateTo('main-game-view');
                renderGrid();
                renderUI();
                showMessage(`Settings: Starting game at **Level ${levelNumber}** with target score **${LEVELS[levelIndex].minScore}**.`);
            }
        }

        function openSettingsScreen() {
            // Restore default levels if a custom URL was used, so the editor sees the full set.
            // (This is a quick fix; a robust solution would use a persistent storage for user levels).
            if (LEVELS.length === 1 && LEVELS[0].level === 1 && window.location.search.includes('target=')) {
                // Since we don't store the original, we just prevent saving back to the URL's level
                // and warn the user. For this context, we allow editing the single level.
            }

            populateLevelSelector();
            
            const levelToLoad = LEVELS[currentLevelIndex] ? LEVELS[currentLevelIndex].level : (LEVELS[0] ? LEVELS[0].level : 1); 
            
            if (LEVELS.length === 0) {
                addNewLevel();
            } else {
                 levelSelect.value = levelToLoad; 
                 loadLevelDataToEditor(levelToLoad);
            }
        }
        
        /** Generates a shareable URL for the currently edited level. */
        function generateShareLink() {
            const levelNumber = parseInt(levelSelect.value);
            const levelData = LEVELS.find(l => l.level === levelNumber);
            
            if (!levelData) {
                displayDebugMessage("Error: Could not find current level data.", true);
                return;
            }

            // Ensure latest changes are saved before generating the link
            saveLevelChanges();

            const wordsParam = encodeURIComponent(levelData.words.join(','));
            const targetParam = levelData.minScore;
            
            // Construct the base URL without existing parameters
            const baseUrl = window.location.origin + window.location.pathname;
            const shareUrl = `${baseUrl}?target=${targetParam}&words=${wordsParam}`;

            // Display the link and copy it to clipboard
            const el = document.createElement('textarea');
            el.value = shareUrl;
            el.setAttribute('readonly', '');
            el.style.position = 'absolute';
            el.style.left = '-9999px';
            document.body.appendChild(el);
            el.select();
            document.execCommand('copy');
            document.body.removeChild(el);

            displayDebugMessage("Share link copied to clipboard! Paste the URL to challenge a friend.", false);
        }


        // --- Event Listeners ---
        confirmBtn.addEventListener('click', () => {
            if (gameState === 'review_placement') {
                placeWord();
            }
        });

        resetBtn.addEventListener('click', resetPlacement);
        undoBtn.addEventListener('click', undoLastPlacement);
        
        // Game Over Controls
        tryAgainBtn.addEventListener('click', initGame);
        nextLevelBtn.addEventListener('click', goToNextLevel);
        shareSuccessBtn.addEventListener('click', shareScore);
        shareFailureBtn.addEventListener('click', shareScore);

        // Navigation Controls
        aboutBtn.addEventListener('click', () => navigateTo('about-view'));
        aboutBtnMobile.addEventListener('click', () => navigateTo('about-view')); 
        settingsBtn.addEventListener('click', () => navigateTo('settings-view'));
        backFromAboutBtn.addEventListener('click', () => navigateTo('main-game-view'));
        backFromSettingsBtn.addEventListener('click', () => navigateTo('main-game-view'));

        // Settings Controls
        levelSelect.addEventListener('change', (e) => loadLevelDataToEditor(e.target.value));
        addLevelBtn.addEventListener('click', addNewLevel); 
        saveLevelBtn.addEventListener('click', saveLevelChanges);
        startLevelBtn.addEventListener('click', startSelectedLevel);
        generateUrlBtn.addEventListener('click', generateShareLink); // New URL generator listener


        // --- Start Game on Load ---
        window.onload = initGame;
    </script>
</body>
</html>
