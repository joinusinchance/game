<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>I-mog-en: The Mewsical</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #2b2b2b;
            font-family: 'Fredoka One', cursive;
            overflow: hidden;
            touch-action: none;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: #fff;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            height: 100vh;
            background: linear-gradient(180deg, #3a3a3a 0%, #222 100%);
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlays */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(43, 43, 43, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            transition: opacity 0.3s;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            font-size: 3rem;
            color: #FF6B6B;
            text-shadow: 3px 3px 0px #4ECDC4;
            margin-bottom: 5px;
            text-align: center;
            line-height: 1.1;
        }

        .subtitle {
            font-size: 1.2rem;
            color: #ffe66d;
            margin-bottom: 20px;
        }

        p {
            font-size: 1.2rem;
            text-align: center;
            margin: 10px 20px;
            color: #ddd;
        }

        .btn {
            background: #4ecdc4;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.5rem;
            border-radius: 50px;
            cursor: pointer;
            font-family: 'Fredoka One', cursive;
            margin-top: 15px;
            box-shadow: 0 6px 0 #2a9d8f;
            transition: transform 0.1s;
            width: 80%;
            max-width: 300px;
        }

        .btn:active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 #2a9d8f;
        }
        
        .btn:disabled {
            background: #777;
            box-shadow: 0 4px 0 #555;
            cursor: default;
        }

        .btn-secondary {
            background: #ff6b6b;
            box-shadow: 0 6px 0 #c44d4d;
        }
        
        .btn-share {
            background: #ffe66d;
            color: #5e3a58;
            box-shadow: 0 6px 0 #d4c04d;
        }
        
        #loading-status {
            font-size: 1rem;
            color: #4ECDC4;
            margin-top: 10px;
        }


        /* HUD */
        #hud-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #score-board {
            position: absolute;
            top: 10px;
            left: 15px;
            font-size: 1.5rem;
            color: #fff;
            text-shadow: 2px 2px 0 #000;
        }

        #combo-board {
            position: absolute;
            top: 45px;
            left: 15px;
            font-size: 1.2rem;
            color: #ffe66d;
            text-shadow: 1px 1px 0 #000;
        }

        /* Lyrics Container */
        #lyrics-container {
            position: absolute;
            top: 80px;
            left: 0;
            width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 5;
            padding: 0 10px;
            box-sizing: border-box;
        }

        .lyric-line {
            font-size: 1.3rem;
            color: rgba(255, 255, 255, 0.4);
            transition: all 0.2s ease-out;
            margin: 5px 0;
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .lyric-active {
            font-size: 1.6rem;
            color: #ff6b6b;
            transform: scale(1.05);
            text-shadow: 2px 2px 0px #fff;
            opacity: 1;
        }

        select {
            font-size: 1.2rem; 
            padding: 12px; 
            border-radius: 15px; 
            margin-top: 5px; 
            border: 3px solid #ff6b6b; 
            background: white; 
            font-family: 'Fredoka One';
            width: 80%;
            max-width: 300px;
            outline: none;
        }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="hud-layer">
        <div id="score-board">Score: 0</div>
        <div id="combo-board">Combo: 0</div>
        <div id="lyrics-container"></div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="overlay">
        <h1>I-mog-en:<br>The Mewsical</h1>
        <div class="subtitle">Rhythm Action Game</div>
        
        <div style="margin: 20px 0; width: 100%; text-align: center;">
            <label for="song-select" style="font-size: 1.2rem; color: #4ECDC4;">Select Track:</label><br>
            <select id="song-select">
                <option value="camptown">Camptown Races (Long)</option>
                <option value="entertainer">The Entertainer (Long)</option>
                <option value="korobeiniki">Korobeiniki (Tetris) (Long)</option>
                <option value="mountain">Hall of Mountain King (Long)</option>
                <option value="ode">Ode to Joy (Long)</option>
            </select>
        </div>
        
        <button class="btn" id="start-btn" disabled>Start Purring</button>
        <div id="loading-status">Loading Cat Audio...</div>
        <p style="font-size: 0.9rem; opacity: 0.7; margin-top: 20px;">Use D, F, J, K or Touch the Lanes</p>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="overlay hidden">
        <h1>Finished!</h1>
        <p>Score: <span id="final-score" style="color:#4ECDC4">0</span></p>
        <p>Best Combo: <span id="max-combo" style="color:#ffe66d">0</span></p>
        <p id="rank-text" style="font-size: 2rem; color: #ff6b6b; margin: 10px 0;"></p>
        
        <button class="btn btn-share" id="share-btn">Share Score</button>
        <button class="btn btn-secondary" id="restart-btn">Play Again</button>
    </div>
</div>

<script>
/**
 * CONSTANTS
 */
const LANE_COLORS = ['#FF6B6B', '#4ECDC4', '#FFE66D', '#FF9F43'];
// Lane 0: Fashion Handbag, Lane 1: Pill, Lane 2: Squirrel, Lane 3: Croissant
const LANE_ITEMS = ['ðŸ‘œ', 'ðŸ’Š', 'ðŸ¿ï¸', 'ðŸ¥']; 

/**
 * AUDIO ENGINE & DATA
 */
const AudioEngine = (() => {
    let ctx = null;
    let masterGain = null;
    let meowBuffer = null; // Buffer for the note melody
    let fxBuffer = null; // Buffer for the button/ui feedback
    let loadedCount = 0;
    const TOTAL_SOUNDS = 2;
    let isLoaded = false;
    
    // URLs for the sound files
    const MEOW_URL = 'https://joinusinchance.github.io/game/mixkit-sweet-kitty-meow-93.wav';
    const FX_URL = 'https://joinusinchance.github.io/game/mixkit-little-cat-pain-meow-87.wav';
    
    // Base frequency assumption for the meow sample (used for pitch calculation)
    const BASE_FREQUENCY = 261.63; // C4
    const OCTAVE_OFFSET = 0.65; // NEW: Multiplier to drop the pitch by one octave (1.0 -> 0.5)

    // STANDARD NOTE FREQUENCIES
    const NOTE_FREQS = {
        'C2': 65.41, 'C#2': 69.30, 'D2': 73.42, 'D#2': 77.78, 'E2': 82.41, 'F2': 87.31, 'F#2': 92.50, 'G2': 98.00, 'G#2': 103.83, 'A2': 110.00, 'A#2': 116.54, 'B2': 123.47,
        'C3': 130.81, 'C#3': 138.59, 'D3': 146.83, 'D#3': 155.56, 'E3': 164.81, 'F3': 174.61, 'F#3': 185.00, 'G3': 196.00, 'G#3': 207.65, 'A3': 220.00, 'A#3': 233.08, 'B3': 246.94,
        'C4': 261.63, 'C#4': 277.18, 'D4': 293.66, 'D#4': 311.13, 'E4': 329.63, 'F4': 349.23, 'F#4': 369.99, 'G4': 392.00, 'G#4': 415.30, 'A4': 440.00, 'A#4': 466.16, 'B4': 493.88,
        'C5': 523.25, 'C#5': 554.37, 'D5': 587.33, 'D#5': 622.25, 'E5': 659.25, 'F5': 698.46, 'F#5': 739.99, 'G5': 783.99, 'G#5': 830.61, 'A5': 880.00, 'A#5': 932.33, 'B5': 987.77,
        'C6': 1046.50
    };

    /**
     * Generic function to load an audio file.
     */
    async function loadAudioFile(url, bufferName) {
        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status} for ${url}`);
            const arrayBuffer = await response.arrayBuffer();
            const buffer = await ctx.decodeAudioData(arrayBuffer);
            
            if (bufferName === 'meowBuffer') meowBuffer = buffer;
            if (bufferName === 'fxBuffer') fxBuffer = buffer;

            loadedCount++;
            console.log(`${bufferName} loaded. (${loadedCount}/${TOTAL_SOUNDS})`);
            
            if (loadedCount === TOTAL_SOUNDS) {
                isLoaded = true;
                // Signal the UI that loading is complete
                document.getElementById('start-btn').disabled = false;
                document.getElementById('loading-status').innerText = "Audio Ready! Tap to Start.";
            }

        } catch (error) {
            console.error(`Error loading ${bufferName} from ${url}:`, error);
            document.getElementById('loading-status').innerText = "Error loading audio. Check console.";
        }
    }

    /**
     * Initializes the AudioContext and loads both sound files.
     */
    function init() {
        if (!ctx) {
            ctx = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = ctx.createGain();
            masterGain.gain.value = 0.6; 
            masterGain.connect(ctx.destination);
            
            // Start loading both sounds simultaneously
            loadAudioFile(MEOW_URL, 'meowBuffer');
            loadAudioFile(FX_URL, 'fxBuffer');
        }
        if (ctx.state === 'suspended') ctx.resume();
        return isLoaded;
    }

    /**
     * Plays the loaded meow sample for the melody.
     * The playback rate is halved (multiplied by 0.5) to drop the pitch by one octave.
     */
    function playMeow(freq) {
        if (!ctx || !meowBuffer || !isFinite(freq)) return;

        const source = ctx.createBufferSource();
        source.buffer = meowBuffer;

        // Calculate playback rate ratio: (Target Frequency) / (Base Frequency of sample)
        // Multiply by 0.5 to drop the pitch by one octave.
        const playbackRate = (freq / BASE_FREQUENCY) * OCTAVE_OFFSET;
        source.playbackRate.value = playbackRate;

        const gainNode = ctx.createGain();
        gainNode.gain.setValueAtTime(1.0, ctx.currentTime);
        
        source.connect(gainNode);
        gainNode.connect(masterGain);
        
        source.start(0);
        source.onended = () => {
            source.disconnect();
            gainNode.disconnect();
        };
    }
    
    /**
     * Plays the loaded UI sound effect.
     */
    function playUISound() {
        if (!ctx || !fxBuffer) return;

        const source = ctx.createBufferSource();
        source.buffer = fxBuffer;
        
        // Lower the volume slightly for UI FX
        const gainNode = ctx.createGain();
        gainNode.gain.value = 0.4; 
        
        source.connect(gainNode);
        gainNode.connect(masterGain);
        
        source.start(0);
        source.onended = () => {
            source.disconnect();
            gainNode.disconnect();
        };
    }


    /**
     * Plays synthesized sounds for hit/miss feedback, distinct from the meow melody.
     */
    function playHitSound(rating) {
        if (!ctx) return;
        const now = ctx.currentTime;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain);
        gain.connect(masterGain);

        if (rating === 'miss') {
            // Low-pitched growl/hiss (synthesized)
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(80, now);
            osc.frequency.linearRampToValueAtTime(60, now + 0.1);
            gain.gain.setValueAtTime(0.2, now);
            gain.gain.linearRampToValueAtTime(0.001, now + 0.2);
            osc.start();
            osc.stop(now + 0.2);
        } else if (rating === 'perfect') {
            // A cheerful purr-trill (synthesized)
            osc.type = 'sine';
            osc.frequency.setValueAtTime(600, now);
            osc.frequency.exponentialRampToValueAtTime(1000, now + 0.15);
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
            osc.start();
            osc.stop(now + 0.2);
        } else {
            // Simple click for other hits
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(1200, now);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
            osc.start();
            osc.stop(now + 0.05);
        }
    }

    function getCurrentTime() { return ctx ? ctx.currentTime : 0; }

    return { 
        init, 
        playMeow, 
        playHitSound, 
        playUISound, // New UI sound function
        getCurrentTime, 
        NOTE_FREQS, 
        get isLoaded() { return isLoaded; } 
    };
})();

/**
 * SONG DATA (Full length tracks)
 */
// Define the core phrases
const camptown_phrase = [
    ['G4',1],['G4',1],['E4',1],['G4',1], ['A4',1],['G4',1],['E4',2],
    ['E4',1],['D4',1],['C4',2], ['E4',1],['D4',1],['C4',2],
    ['G4',1],['G4',1],['E4',1],['G4',1], ['A4',1],['G4',1],['E4',2],
    ['D4',1],['E4',1],['F4',1],['D4',1], ['C4',4]
]; // 24 beats total

const korobeiniki_phrase = [
    ['E4', 1], ['B3', 0.5], ['C4', 0.5], ['D4', 1], ['C4', 0.5], ['B3', 0.5],
    ['A3', 1], ['A3', 0.5], ['C4', 0.5], ['E4', 1], ['D4', 0.5], ['C4', 0.5],
    ['B3', 1], ['B3', 0.5], ['C4', 0.5], ['D4', 1], ['E4', 1],
    ['C4', 1], ['A3', 1], ['A3', 1],
    ['D4', 1.5], ['F4', 0.5], ['A4', 1], ['G4', 0.5], ['F4', 0.5],
    ['E4', 1.5], ['C4', 0.5], ['E4', 1], ['D4', 0.5], ['C4', 0.5],
    ['B3', 1], ['B3', 0.5], ['C4', 0.5], ['D4', 1], ['E4', 1],
    ['C4', 1], ['A3', 1], ['A3', 1]
]; // 32 beats total

const entertainer_phrase = [
    ['D5',0.5],['E5',0.5],['C5',0.5],['A4',1],['B4',0.5],['G4',0.5],
    ['D4',0.5],['E4',0.5],['C4',0.5],['A3',1],['B3',0.5],['G3',0.5],
    ['D3',0.5],['E3',0.5],['C3',0.5],['A2',1],['B2',0.5],['A2',0.5],['G#2',0.5],['G2',2],
    ['D4',0.5],['D#4',0.5],['E4',0.5],['C5',1],['E4',0.5],['C5',1],['E4',0.5],['C5',2],
    ['C5',0.5],['D5',0.5],['D#5',0.5],['E5',0.5],['C5',0.5],['D5',0.5],['E5',2]
]; // 30 beats total

const mountain_phrase = [
    ['B3',0.5],['C#4',0.5],['D4',0.5],['E4',0.5],['F#4',0.5],['D4',0.5],['F#4',1],
    ['F#4',0.5],['D4',0.5],['F#4',1], ['F#4',0.5],['D4',0.5],['F#4',1],
    ['B3',0.5],['C#4',0.5],['D4',0.5],['E4',0.5],['F#4',0.5],['D4',0.5],['F#4',1],
    ['A4',0.5],['G4',0.5],['E4',1], ['F#4',0.5],['D4',0.5],['B3',1]
]; // 24 beats total

const ode_phrase = [
    ['E4', 1], ['E4', 1], ['F4', 1], ['G4', 1],
    ['G4', 1], ['F4', 1], ['E4', 1], ['D4', 1],
    ['C4', 1], ['C4', 1], ['D4', 1], ['E4', 1],
    ['E4', 1.5], ['D4', 0.5], ['D4', 2]
]; // 16 beats total

// Helper to repeat an array
const repeat = (arr, times) => Array(times).fill(arr).flat();

const SONGS = {
    'camptown': {
        bpm: 110,
        notes: repeat(camptown_phrase, 4), // 96 beats (approx 52 seconds)
        lyrics: [
            {beat: 0, text: "Camptown ladies sing this song..."},
            {beat: 24, text: "Doo-dah! Oh, doo-dah day!"},
            {beat: 48, text: "We're going to run all night..."},
            {beat: 72, text: "Camptown forever!"}
        ]
    },
    'korobeiniki': {
        bpm: 140,
        notes: repeat(korobeiniki_phrase, 4), // 128 beats (approx 55 seconds)
        lyrics: [
            {beat: 0, text: "Stacking boxes in a row..."},
            {beat: 32, text: "Twisting shapes to make them fit!"},
            {beat: 64, text: "Cats fit in boxes, don't you know?"},
            {beat: 96, text: "If I fits, I sits! Forever!"}
        ]
    },
    'entertainer': {
        bpm: 140, 
        notes: repeat(entertainer_phrase, 4), // 120 beats (approx 51 seconds)
        lyrics: [
            {beat: 0, text: "Ragtime Intro... Tap those feet!"},
            {beat: 30, text: "The cat is here to entertain!"},
            {beat: 60, text: "Dancing on the keys, faster now!"},
            {beat: 90, text: "A true meow-sical sensation!"}
        ]
    },
    'mountain': {
        bpm: 160,
        notes: repeat(mountain_phrase, 4), // 96 beats (approx 36 seconds)
        lyrics: [
            {beat: 0, text: "Creeping down the mountain hall..."},
            {beat: 24, text: "Trolls are watching! Run!"},
            {beat: 48, text: "Running faster now! Keep going!"},
            {beat: 72, text: "Escape is near!"}
        ]
    },
    'ode': {
        bpm: 120,
        notes: repeat(ode_phrase, 5), // 80 beats (approx 40 seconds)
        lyrics: [
            {beat: 0, text: "Joy, beautiful spark of Divinity..."},
            {beat: 16, text: "Daughter of Elysium..."},
            {beat: 32, text: "We enter, drunk with fire..."},
            {beat: 48, text: "Your magic joins again..."},
            {beat: 64, text: "All that custom has divided!"}
        ]
    }
};

/**
 * GAME LOGIC
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const startScreen = document.getElementById('start-screen');
const gameOverScreen = document.getElementById('game-over-screen');
const scoreEl = document.getElementById('score-board');
const comboEl = document.getElementById('combo-board');
const lyricsContainer = document.getElementById('lyrics-container');
const finalScoreEl = document.getElementById('final-score');
const maxComboEl = document.getElementById('max-combo');
const rankTextEl = document.getElementById('rank-text');

let gameState = {
    isPlaying: false,
    startTime: 0,
    score: 0,
    combo: 0,
    maxCombo: 0,
    notes: [], 
    lyrics: [],
    particles: [], 
    laneCount: 4,
    speed: 500, // Pixels per second
    hitY: 0, 
    keyMap: { 'KeyD': 0, 'KeyF': 1, 'KeyJ': 2, 'KeyK': 3 }
};


function resize() {
    canvas.width = document.getElementById('game-container').offsetWidth;
    canvas.height = document.getElementById('game-container').offsetHeight;
    gameState.hitY = canvas.height - 120;
}
window.addEventListener('resize', resize);
resize();

function parseSong(songId) {
    const song = SONGS[songId];
    if (!song) return { notes: [], lyrics: [] };

    const beatTime = 60 / song.bpm;
    let currentNoteTime = 2.0;

    const gameNotes = song.notes.map((n, index) => {
        const freq = AudioEngine.NOTE_FREQS[n[0]];
        const duration = n[1];
        let lane = index % 4;
        
        // Randomization logic for lane assignment
        if (index % 3 === 0) lane = (lane + 1) % 4;
        // High notes mostly go to Lane 3 (Croissant)
        if (n[0].indexOf('5') > -1 || n[0].indexOf('6') > -1) lane = 3; 
        // Low notes mostly go to Lane 0 (Handbag)
        if (n[0].indexOf('2') > -1) lane = 0; 

        const noteObj = {
            time: currentNoteTime,
            lane: lane,
            freq: freq,
            duration: duration * beatTime,
            played: false, hit: false, missed: false, visible: true
        };
        currentNoteTime += duration * beatTime;
        return noteObj;
    });

    const gameLyrics = song.lyrics ? song.lyrics.map(l => ({
        time: 2.0 + (l.beat * beatTime),
        text: l.text,
        shown: false
    })) : [];

    return { notes: gameNotes, lyrics: gameLyrics };
}

function startGame() {
    if (!AudioEngine.isLoaded) {
        document.getElementById('loading-status').innerText = "Audio not fully loaded yet!";
        return;
    }
    
    AudioEngine.playUISound(); // Play FX when starting
    
    const songId = document.getElementById('song-select').value;
    AudioEngine.init(); // Resume context if suspended
    
    const songData = parseSong(songId);
    gameState.notes = songData.notes;
    gameState.lyrics = songData.lyrics;
    
    gameState.isPlaying = true;
    gameState.startTime = AudioEngine.getCurrentTime();
    gameState.score = 0;
    gameState.combo = 0;
    gameState.maxCombo = 0;
    gameState.particles = [];
    
    // Reset UI
    startScreen.classList.add('hidden');
    gameOverScreen.classList.add('hidden');
    lyricsContainer.innerHTML = '<div class="lyric-line lyric-active">Ready...</div>';
    
    updateScore();
    requestAnimationFrame(gameLoop);
}

function endGame() {
    gameState.isPlaying = false;
    setTimeout(() => {
        gameOverScreen.classList.remove('hidden');
        finalScoreEl.innerText = gameState.score;
        maxComboEl.innerText = gameState.maxCombo;

        let rank = "Stray Cat";
        const maxScore = gameState.notes.length * 100;
        const pct = maxScore > 0 ? gameState.score / maxScore : 0;

        if (pct > 0.9) rank = "Pop Star Purrfection!";
        else if (pct > 0.7) rank = "Cool Cat";
        else if (pct > 0.5) rank = "House Cat";
        
        rankTextEl.innerText = rank;
    }, 1000);
}

function updateScore() {
    scoreEl.innerText = `${gameState.score}`;
    comboEl.innerText = `x${gameState.combo}`;
    if (gameState.combo > gameState.maxCombo) gameState.maxCombo = gameState.combo;
}

function spawnParticles(x, y, color) {
    for (let i = 0; i < 10; i++) {
        gameState.particles.push({
            x: x, y: y,
            vx: (Math.random() - 0.5) * 15,
            vy: (Math.random() - 0.5) * 15,
            life: 1.0, color: color
        });
    }
}

function shareScore() {
    AudioEngine.playUISound(); // Play FX when sharing

    const shareBtn = document.getElementById('share-btn');
    const originalText = shareBtn.innerText;

    const finalRank = rankTextEl.innerText || "Stray Cat";
    const text = `I scored ${gameState.score} points (${finalRank}) on I-mog-en: The Mewsical! Can you beat my combo of ${gameState.maxCombo}? ðŸ±ðŸŽµ`;
    
    // Function to restore button text
    const restoreButton = (newText, duration = 2000) => {
        shareBtn.innerText = newText;
        setTimeout(() => shareBtn.innerText = originalText, duration);
    };

    if (navigator.share) {
        navigator.share({
            title: 'I-mog-en: The Mewsical',
            text: text,
            url: window.location.href
        }).catch(error => {
            // Handle user cancellation (AbortError) silently
            if (error.name === 'AbortError') {
                restoreButton("Share Canceled");
            } else {
                console.error('Error sharing:', error);
                restoreButton("Sharing Failed", 3000);
            }
        });
    } else {
        // Fallback for browsers/environments without navigator.share (Clipboard Copy)
        const textArea = document.createElement("textarea");
        textArea.value = text;
        textArea.style.position = 'fixed'; // Keep it off-screen
        textArea.style.left = '-9999px';
        document.body.appendChild(textArea);
        textArea.select();
        
        try {
            document.execCommand('copy');
            restoreButton("Copied to Clipboard!", 2500); // UI message instead of alert
        } catch (err) {
            console.error('Unable to copy', err);
            restoreButton("Copy Failed", 3000);
        } finally {
            document.body.removeChild(textArea);
        }
    }
}

// Draw Utils
function drawPaw(ctx, x, y, size, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(x, y, size, 0, Math.PI * 2); // Pad
    ctx.fill();
    // Toes
    const tDist = size * 1.2;
    const tSize = size * 0.4;
    ctx.beginPath(); ctx.arc(x - tDist*0.7, y - tDist*0.7, tSize, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x, y - tDist, tSize*1.1, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x + tDist*0.7, y - tDist*0.7, tSize, 0, Math.PI*2); ctx.fill();
}

function gameLoop() {
    if (!gameState.isPlaying) return;

    const audioTime = AudioEngine.getCurrentTime();
    const gameTime = audioTime - gameState.startTime;
    
    // Clear & BG
    ctx.fillStyle = "#2b2b2b";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Update Lyrics
    gameState.lyrics.forEach(lyric => {
        if (!lyric.shown && gameTime >= lyric.time) {
            lyric.shown = true;
            lyricsContainer.innerHTML = `<div class="lyric-line lyric-active">${lyric.text}</div>`;
        }
    });

    // Draw Lanes
    const laneWidth = canvas.width / gameState.laneCount;
    for (let i = 0; i < gameState.laneCount; i++) {
        // Gradient Lane
        const grd = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grd.addColorStop(0, "rgba(255,255,255,0)");
        grd.addColorStop(1, "rgba(255,255,255,0.05)");
        ctx.fillStyle = grd;
        ctx.fillRect(i * laneWidth, 0, laneWidth, canvas.height);
        
        // Separator
        ctx.strokeStyle = "rgba(255,255,255,0.1)";
        ctx.beginPath(); ctx.moveTo(i*laneWidth, 0); ctx.lineTo(i*laneWidth, canvas.height); ctx.stroke();

        // Hit Target (Paw)
        const x = i * laneWidth + laneWidth / 2;
        const y = gameState.hitY;
        
        ctx.strokeStyle = activeLanes[i] ? "#fff" : LANE_COLORS[i];
        ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(x, y, 35, 0, Math.PI*2); ctx.stroke();
        
        if (activeLanes[i]) {
            drawPaw(ctx, x, y, 30, LANE_COLORS[i]);
            // Glow effect
            ctx.shadowBlur = 20;
            ctx.shadowColor = LANE_COLORS[i];
            ctx.shadowBlur = 0;
        }
    }

    let allNotesFinished = true;

    // Draw & Update Notes (Emojiss, no background circle)
    gameState.notes.forEach(note => {
        const timeDiff = note.time - gameTime;
        const y = gameState.hitY - (timeDiff * gameState.speed);

        // Auto-play audio (The Meow)
        if (timeDiff <= 0 && !note.played) {
            // Play the meow audio with pitch adjustment
            AudioEngine.playMeow(note.freq); 
            note.played = true;
        }

        // Miss Logic
        if (y > gameState.hitY + 80 && !note.hit && !note.missed) {
            note.missed = true;
            note.visible = false;
            gameState.combo = 0;
            updateScore();
            createFloatingText("Hiss", note.lane * laneWidth + laneWidth/2, canvas.height - 50, "#888");
            AudioEngine.playHitSound('miss');
        }

        // Draw Item (Emoji)
        if (note.visible && y > -50 && y < canvas.height + 50) {
            allNotesFinished = false;
            const x = note.lane * laneWidth + laneWidth / 2;
            const item = LANE_ITEMS[note.lane];

            ctx.font = '40px sans-serif'; // Use a standard font for reliable emoji rendering
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Draw the emoji with a white shadow for contrast against the dark background
            ctx.shadowColor = 'rgba(255, 255, 255, 1.0)';
            ctx.shadowBlur = 4;
            ctx.fillText(item, x, y); 

            ctx.shadowBlur = 0; // Reset shadow
        } else if (!note.missed && !note.hit && note.time > gameTime) {
            allNotesFinished = false;
        }
    });

    // Particles
    gameState.particles.forEach((p, i) => {
        p.x += p.vx; p.y += p.vy; p.vy += 0.8; p.life -= 0.04;
        ctx.globalAlpha = Math.max(0, p.life);
        ctx.fillStyle = p.color;
        ctx.beginPath(); ctx.arc(p.x, p.y, 6, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1;
        if (p.life <= 0) gameState.particles.splice(i, 1);
    });

    // Floating Text
    floatingTexts.forEach((ft, i) => {
        ft.y -= 2; ft.life -= 0.03;
        ctx.globalAlpha = Math.max(0, ft.life);
        ctx.save();
        ctx.translate(ft.x, ft.y);
        const scale = 1 + (1-ft.life)*0.5;
        ctx.scale(scale, scale);
        ctx.fillStyle = ft.color;
        ctx.font = "bold 30px 'Fredoka One'";
        ctx.textAlign = "center";
        ctx.strokeStyle = "black";
        ctx.lineWidth = 3;
        ctx.strokeText(ft.text, 0, 0);
        ctx.fillText(ft.text, 0, 0);
        ctx.restore();
        ctx.globalAlpha = 1;
        if (ft.life <= 0) floatingTexts.splice(i, 1);
    });

    if (allNotesFinished && gameState.notes.length > 0) {
        if (gameTime > gameState.notes[gameState.notes.length-1].time + 1.5) {
            endGame();
            return;
        }
    }

    requestAnimationFrame(gameLoop);
}

// Inputs
const activeLanes = [false, false, false, false];
let floatingTexts = [];

function createFloatingText(text, x, y, color) {
    floatingTexts.push({ text, x, y, color, life: 1.0 });
}

function handleInput(lane) {
    if (!gameState.isPlaying) return;

    // Visual feedback
    activeLanes[lane] = true;
    setTimeout(() => activeLanes[lane] = false, 100);

    const gameTime = AudioEngine.getCurrentTime() - gameState.startTime;
    const laneWidth = canvas.width / gameState.laneCount;
    const x = lane * laneWidth + laneWidth / 2;

    const candidates = gameState.notes.filter(n => 
        n.lane === lane && !n.hit && !n.missed && Math.abs(n.time - gameTime) < 0.35
    );

    if (candidates.length > 0) {
        const note = candidates[0];
        const diff = Math.abs(note.time - gameTime);
        note.hit = true;
        note.visible = false;
        
        let txt = "", col = "";
        if (diff < 0.1) {
            txt = "PURRFECT!"; col = "#FF6B6B"; gameState.score += 100 + (gameState.combo*5);
            gameState.combo++;
            AudioEngine.playHitSound('perfect');
        } else if (diff < 0.25) {
            txt = "Good!"; col = "#4ECDC4"; gameState.score += 50 + (gameState.combo*2);
            gameState.combo++;
            AudioEngine.playHitSound('good');
        } else {
            txt = "Meh"; col = "#F7D794"; gameState.score += 10;
            gameState.combo = 0; // Combo breaker
            AudioEngine.playHitSound('meh');
        }
        createFloatingText(txt, x, gameState.hitY - 80, col);
        spawnParticles(x, gameState.hitY, LANE_COLORS[lane]);
        updateScore();
    }
}

// Input Listeners
window.addEventListener('keydown', (e) => {
    if (gameState.keyMap.hasOwnProperty(e.code)) handleInput(gameState.keyMap[e.code]);
});

canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    for (let i = 0; i < e.changedTouches.length; i++) {
        const x = e.changedTouches[i].clientX - canvas.getBoundingClientRect().left;
        const lane = Math.floor(x / (canvas.width / 4));
        if (lane >= 0 && lane < 4) handleInput(lane);
    }
}, {passive:false});

canvas.addEventListener('mousedown', (e) => {
    const x = e.clientX - canvas.getBoundingClientRect().left;
    const lane = Math.floor(x / (canvas.width / 4));
    if (lane >= 0 && lane < 4) handleInput(lane);
});

// UI Event Handlers
document.getElementById('start-btn').addEventListener('click', startGame);

document.getElementById('restart-btn').addEventListener('click', () => {
    AudioEngine.playUISound(); // Play FX when restarting
    gameOverScreen.classList.add('hidden');
    startScreen.classList.remove('hidden');
});

document.getElementById('share-btn').addEventListener('click', shareScore);

// Initial setup call
document.addEventListener('DOMContentLoaded', () => {
    AudioEngine.init(); 
});
</script>
</body>
</html>
