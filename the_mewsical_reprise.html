<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>I-mog-en: The Mewsical</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Luckiest+Guy&display=swap" rel="stylesheet">
    <!-- 'Bangers' for that jaunty, garish comic book look -->
    <link href="https://fonts.googleapis.com/css2?family=Bangers&display=swap" rel="stylesheet">

    <style>
        /* --- Animation Definitions --- */
        @keyframes textBreath {
            0% { transform: scale(1.0); }
            50% { 
                transform: scale(1.08); 
                text-shadow: -8px -8px 0 #6d5b9b, 8px 8px 0 #33ffff, -2px -2px 0 #fff; 
            }
            100% { transform: scale(1.0); }
        }

        @keyframes colorFlash {
            0%, 100% { color: #ff69b4; }
            50% { color: #ffff00; }
        }

        @keyframes subtitleBounce {
            0%, 100% { transform: translateY(0) scale(1.0); }
            50% { transform: translateY(-2px) scale(1.05); }
        }
        
        @keyframes buttonWobble {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            33% { transform: translateY(-1px) rotate(1deg); }
            66% { transform: translateY(1px) rotate(-1deg); }
        }

        @keyframes rhythmicJitter {
            0% { transform: translateY(0) rotate(0deg) scale(2.0); }
            25% { transform: translateY(5px) rotate(2deg) scale(1.95); }
            50% { transform: translateY(-15px) rotate(-8deg) scale(2.10); }
            75% { transform: translateY(0) rotate(0deg) scale(2.0); }
            100% { transform: translateY(0) rotate(0deg) scale(2.0); }
        }

        @keyframes moveBubbles {
            from { background-position: 0 0, 0 0, 0 0, 0 0; }
            to { background-position: 200px 200px, -300px 300px, 150px -150px, -350px 350px; }
        }

        /* --- Global Styles --- */
        body {
            margin: 0;
            padding: 0;
            background-color: #F8F8FF;
            font-family: 'Fredoka One', cursive; /* Fallback */
            overflow: hidden;
            touch-action: none;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 90vh;
            color: #5A189A;
            user-select: none;
            -webkit-user-select: none;
        }

        /* --- Bubble Background --- */
        .bubble-bg {
            background: #ffffff; 
            background-image: 
                radial-gradient(circle at 5% 15%, rgba(255, 20, 147, 0.4) 0%, transparent 70%), 
                radial-gradient(circle at 75% 85%, rgba(0, 255, 255, 0.5) 0%, transparent 70%), 
                radial-gradient(circle at 30% 60%, rgba(255, 165, 0, 0.3) 0%, transparent 70%),
                radial-gradient(circle at 90% 10%, rgba(128, 0, 128, 0.3) 0%, transparent 60%); 
            background-size: 200px 200px, 300px 300px, 150px 150px, 350px 350px;
            animation: moveBubbles 15s linear infinite;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            height: 90vh;
            background: linear-gradient(180deg, #FFE4E1 0%, #FFFFFF 100%); 
            box-shadow: 0 0 30px rgba(236, 72, 153, 0.4); 
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.95); 
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            transition: opacity 0.3s;
        }

        /* --- Typography Classes --- */
        
        .bubble-title {
            font-family: 'Luckiest Guy', cursive;
            line-height: 1;
            text-shadow: 
                -5px -5px 0 #5f4b8b, 
                5px 5px 0 #00ffff, 
                0 0 10px #ff00ff, 
                0 0 20px #00ffff, 
                -2px -2px 0 #fff; 
            animation: textBreath 3s ease-in-out infinite alternate,
                       colorFlash 0.2s linear infinite;
        }

        .subtitle-garish {
            font-family: 'Luckiest Guy', cursive;
            color: #ffff00;
            text-shadow: -3px -3px 0 #ff69b4, 3px 3px 0 #00ffff, 0 0 8px #ff00ff;
            line-height: 1;
            animation: subtitleBounce 0.3s ease-in-out infinite alternate;
        }

        /* NEW: Class for "Annoying Garish" font used in Score, Combo, etc. */
        .garish-text {
            font-family: 'Bangers', cursive;
            letter-spacing: 2px;
            color: #FF00FF; /* Magenta Fill */
            -webkit-text-stroke: 1.5px black; /* Thick black outline */
            text-shadow: 3px 3px 0 #00FFFF; /* Cyan Shadow */
        }

        /* Features Section Text Style */
        .feature-text {
            font-family: 'Bangers', cursive;
            color: #33ffff;
            -webkit-text-stroke: 1px #6d5b9b;
            text-shadow: 2px 2px 0 #ff69b4;
            transform: rotate(-2deg);
        }

        /* --- UI Elements --- */

        .song-select-garish {
            font-family: 'Luckiest Guy', cursive;
            color: #000000; 
            background-color: #00ffff; 
            border: 4px solid #ff69b4; 
            padding: 0.5rem 1.5rem;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="%23FF69B4" d="M7 10l5 5 5-5z"/></svg>');
            background-repeat: no-repeat;
            background-position: right 1rem center;
            background-size: 1.5em;
        }

        .cat-animated {
            animation: rhythmicJitter 0.5s ease-out infinite;
            cursor: pointer; 
        }

        .start-button {
            transition: none;
            font-family: 'Bangers', cursive; 
            letter-spacing: 2px;
            border-width: 4px;
            border-style: solid;
            border-color: #000;
            box-shadow: 0 8px 0 0 #5f4b8b, 0 0 10px #ff00ff, 0 0 20px #00ffff;
            animation: buttonWobble 0.2s linear infinite; 
        }

        .start-button:active {
            box-shadow: 0 2px 0 0 #5f4b8b, 0 0 10px #ff00ff, 0 0 20px #00ffff;
            transform: translateY(6px);
            animation: none; 
        }

        /* HUD Positioning */
        #hud-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        #score-board, #combo-board {
            position: absolute;
            top: 20px;
            /* Updated to use new garish class */
            font-size: 2rem; 
        }

        #score-board { left: 20px; }
        #combo-board { right: 20px; }

        #lyrics-container {
            position: absolute;
            width: 100%;
            top: 100px; 
            text-align: center;
            pointer-events: none;
        }

        .lyric-active {
            font-family: 'Bangers', cursive; 
            font-size: 2.2rem; 
            color: #FFF000; 
            -webkit-text-stroke: 1.5px black;
            text-shadow: 3px 3px 0 #000, 5px 5px 0 #FF00FF; 
            transform: scale(1.05) rotate(-2deg); 
            opacity: 1;
            letter-spacing: 1px;
        }

        /* General Inputs */
        select {
            font-size: 1.2rem; 
            padding: 12px; 
            border-radius: 15px; 
            margin-top: 5px; 
            border: 3px solid #EC4899; 
            background: white; 
            font-family: 'Fredoka One';
            width: 80%;
            max-width: 300px;
            outline: none;
            color: #000; 
        }
    </style>
</head>
<body class="bubble-bg min-h-screen flex items-center justify-center p-4">

    <div id="game-container" class="w-full max-w-md bg-white/90 backdrop-blur-sm rounded-3xl p-6 md:p-10 text-center border-4 border-pink-500 shadow-2xl">
        <canvas id="gameCanvas"></canvas>

        <div id="hud-layer">
            <!-- Apply garish-text class here -->
            <div id="score-board" class="garish-text">Score: 0</div>
            <div id="combo-board" class="garish-text">Combo: x0</div>
            <div id="lyrics-container"></div>
        </div>

        <!-- Start Screen -->
        <div id="start-screen" class="overlay">
 
            <!-- Container for Overlapping Text and Image -->
            <div class="relative h-96 sm:h-[30rem] mb-2">
                
                <!-- Text Content (Layer Z-20) -->
                <div class="relative z-20 pt-7">
                    <!-- INCREASED TITLE SIZE -->
                    <h1 class="bubble-title text-7xl sm:text-8xl md:text-9xl select-none whitespace-nowrap -ml-3">
                        I MOG EN
                    </h1>
                    <p class="subtitle-garish text-2xl md:text-4xl font-bold tracking-wider">
                        The Mewsical!
                    </p>
                </div>

                <!-- Animated Cat Image (Layer Z-10) -->
                <div class="absolute inset-x-0 -bottom-24 z-10 flex justify-center">
                    <img 
                        src="https://joinusinchance.github.io/game/I_mog_en_front.png" 
                        alt="Imogen the cat ready to play a rhythm game" 
                        class="cat-animated w-full max-w-xs h-auto block transform origin-bottom"
                        onerror="this.onerror=null;this.src='https://placehold.co/200x200/ff69b4/ffffff?text=CAT+IMAGE'"
                    />
                </div>
            </div>

            <!-- NEW FEATURES SECTION -->
            <div class="mb-6 relative z-20 text-center space-y-1">
                <p class="feature-text text-2xl md:text-3xl">RHYTHM ACTION GAME!</p>
                <p class="feature-text text-xl md:text-2xl" style="color: #ffff00; text-shadow: 2px 2px 0 #000;">PLAY ALONG BY TOUCH, MOUSE OR D F J K!</p>
                <p class="feature-text text-2xl md:text-3xl" style="color: #ff69b4; transform: rotate(2deg);">5 ANNOYING SONGS!</p>
            </div>

            <div class="mb-4 relative z-20 w-full flex justify-center flex-col items-center">
                <label for="song-select" class="block mb-2 subtitle-garish text-xl md:text-2xl">Choose Your Tune:</label>
                <select id="song-select" class="song-select-garish w-full text-xl rounded-2xl shadow-lg focus:ring-4 focus:ring-pink-500 transition-colors">
                        <option value="camptown">Camptown Races</option>
                        <option value="ode">Ode to Joy</option>
                        <option value="entertainer">The Entertainer</option>
                        <option value="korobeiniki">Korobeiniki (Tetris)</option>
                        <option value="mountain">Hall of Mountain King </option>
                </select>
            </div>

            <!-- Start Game Button -->
            <button 
                id="start-btn"
                class="start-button w-full py-4 text-4xl font-bold rounded-xl bg-pink-400 text-black hover:bg-pink-300 uppercase relative z-30"
            >
                Play Now!
            </button>

        </div>


        <!-- Game Over Screen -->
        <div id="game-over-screen" class="overlay hidden" style="display: none;">
            <p class="subtitle-garish text-4xl md:text-6xl font-bold tracking-wider mb-6">
                Finished!
            </p>

            <div class="mb-8 space-y-2">
                <!-- Apply garish-text to score results -->
                <p class="text-3xl text-gray-700">Score: <span id="final-score" class="garish-text" style="font-size: 3rem;">0</span></p>
                <p class="text-3xl text-gray-700">Best Combo: <span id="max-combo" class="garish-text" style="font-size: 3rem; color: #33ffff;">0</span></p>
                <p id="rank-text" class="garish-text" style="font-size: 2.5rem; margin-top: 15px; color: #ffff00;"></p>
            </div>

            <!-- Buttons with whitespace (flex-col with gap) -->
            <div class="w-full flex flex-col gap-6 relative z-30">
                <button 
                    id="share-btn"
                    class="start-button w-full py-4 text-3xl font-bold rounded-full bg-cyan-500 
                    text-black border-4 border-pink-500 hover:bg-cyan-400 uppercase"
                >
                    Share Score
                </button>
                
                <button 
                    id="restart-btn"
                    class="start-button w-full py-4 text-3xl font-bold rounded-full bg-green-500 text-black border-4 border-pink-500 hover:bg-green-400 uppercase"
                >
                    Play Again!
                </button>
            </div>

        </div>
    </div>

    <script>
        // --- Constants (UPDATED LANE COLORS) ---
        const LANE_COLORS = ['#EC4899', '#3B82F6', '#FCD34D', '#A78BFA']; 
        const LANE_ITEMS = ['ðŸ‘œ', 'ðŸ’Š', 'ðŸ¿ï¸', 'ðŸ¥']; 
        const MEOW_URL = 'https://joinusinchance.github.io/game/mixkit-sweet-kitty-meow-93.wav';
        const FX_URL = 'https://joinusinchance.github.io/game/mixkit-little-cat-pain-meow-87.wav';
        const PAW_IMAGE_URL = 'https://joinusinchance.github.io/game/paw.png'; 
        const BASE_FREQUENCY = 261.63; // C4
        const OCTAVE_OFFSET = 0.65; 
        const keyMap = { 'KeyD': 0, 'KeyF': 1, 'KeyJ': 2, 'KeyK': 3 };

        // Standard Note Frequencies
        const NOTE_FREQS = {
            'C2': 65.41, 'C#2': 69.30, 'D2': 73.42, 'D#2': 77.78, 'E2': 82.41, 'F2': 87.31, 'F#2': 92.50, 'G2': 98.00, 'G#2': 103.83, 'A2': 110.00, 'A#2': 116.54, 'B2': 123.47,
            'C3': 130.81, 'C#3': 138.59, 'D3': 146.83, 'D#3': 155.56, 'E3': 164.81, 'F3': 174.61, 'F#3': 185.00, 'G3': 196.00, 'G#3': 207.65, 'A3': 220.00, 'A#3': 233.08, 'B3': 246.94,
            'C4': 261.63, 'C#4': 277.18, 'D4': 293.66, 'D#4': 311.13, 'E4': 329.63, 'F4': 349.23, 'F#4': 369.99, 'G4': 392.00, 'G#4': 415.30, 'A4': 440.00, 'A#4': 466.16, 'B4': 493.88,
            'C5': 523.25, 'C#5': 554.37, 'D5': 587.33, 'D#5': 622.25, 'E5': 659.25, 'F5': 698.46, 'F#5': 739.99, 'G5': 783.99, 'G#5': 830.61, 'A5': 880.00, 'A#5': 932.33, 'B5': 987.77,
            'C6': 1046.50
        };

        const repeat = (arr, times) => Array(times).fill(arr).flat();

        // --- FULL-LENGTH SONG DEFINITIONS ---

        // 1. CAMPTOWN RACES (110 BPM)
        const camptown_verse = [
            ['G4',1],['G4',1],['E4',1],['G4',1], ['A4',1],['G4',1],['E4',2],['E4',1],['D4',3], ['E4',1],['D4',3],
            ['G4',1],['G4',1],['E4',1],['G4',1], ['A4',1],['G4',1],['E4',2],['D4',1], ['F4',1],['E4',1],['D4',1],['C4',2],
        ];
        const camptown_chorus = [
            ['D4',1],['D4',1],['D4',1],['E4',1], ['F4',1],['E4',1],['D4',2],
            ['C4',1],['D4',1],['E4',1],['C4',1], ['G3',4] 
        ];
        const camptown_full = [].concat(camptown_verse, camptown_chorus, camptown_verse);
        const camptown_lyrics_full = [
            {beat: 0, text: "Camptown ladies sing this song, Doo-dah, Doo-dah!"}, 
            {beat: 8, text: "Camptown race-track five miles long, Oh, doo-dah day!"},
            {beat: 16, text: "Goin' to run all night, Goin' to run all day,"}, 
            {beat: 24, text: "I'll bet my money on the bob-tail nag, somebody bet on the bay."},
            {beat: 32, text: "De Camptown ladies am goin' to shine, Doo-dah, Doo-dah!"}, 
            {beat: 64, text: "Final flourish! Doo-dah!"}
        ];

        // 2. ODE TO JOY (120 BPM)
        const ode_a = [['E4', 1], ['E4', 1], ['F4', 1], ['G4', 1], ['G4', 1], ['F4', 1], ['E4', 1], ['D4', 1], ['C4', 1], ['C4', 1], ['D4', 1], ['E4', 1], ['E4', 1.5], ['D4', 0.5], ['D4', 2]];
        const ode_b = [['E4', 1], ['E4', 1], ['F4', 1], ['G4', 1], ['G4', 1], ['F4', 1], ['E4', 1], ['D4', 1], ['C4', 1], ['C4', 1], ['D4', 1], ['E4', 1], ['D4', 1.5], ['C4', 0.5], ['C4', 2]];
        const ode_c = [['D4', 1], ['D4', 1], ['E4', 1], ['C4', 1], ['D4', 1], ['E4', 0.5],['F4', 0.5], ['E4', 1], ['C4', 1], ['D4', 1], ['E4', 0.5],['F4', 0.5], ['E4', 1], ['D4', 1], ['C4', 1], ['D4', 1], ['G3', 2]];
        const ode_full = [].concat(ode_a, ode_b, ode_c, ode_b); 
        const ode_lyrics_full = [ {beat: 0, text: "Joy, beautiful spark of Divinity"}, {beat: 16, text: "We enter, drunk with fire"}, {beat: 32, text: "Your magic joins again"}, {beat: 48, text: "All men become brothers"} ];
        
        // 4. THE ENTERTAINER (140 BPM)
        const entertainer_part_a = [['D5',0.5],['E5',0.5],['C5',0.5],['A4',1],['B4',0.5],['G4',0.5], ['C5', 0.5], ['A4', 0.5], ['G4', 0.5], ['E4', 0.5], ['C4', 2], ['D5',0.5],['E5',0.5],['C5',0.5],['A4',1],['B4',0.5],['G4',0.5], ['C5', 0.5], ['A4', 0.5], ['G4', 0.5], ['E4', 0.5], ['C4', 2], ['D5',0.5],['E5',0.5],['C5',0.5],['A4',1],['B4',0.5],['G4',0.5], ['E4',0.5],['F4',0.5],['G4',0.5],['E4',0.5],['C4',2], ['G4', 0.5], ['F4', 0.5], ['E4', 0.5], ['D4', 0.5], ['C4', 2], ['C4', 1], ['D4', 1], ['E4', 1], ['F4', 1]];
        const entertainer_part_c = [['C5', 2], ['G4', 2], ['C5', 2], ['G4', 2], ['C5', 1], ['D5', 1], ['E5', 1], ['F5', 1], ['G5', 4], ['F5', 1], ['E5', 1], ['D5', 1], ['C5', 1], ['B4', 1], ['A4', 1], ['G4', 1], ['F4', 1], ['E4', 2], ['D4', 2], ['C4', 4]];
        const entertainer_full = [].concat(entertainer_part_a, entertainer_part_c, entertainer_part_a, ['C4', 4]); 
        const entertainer_lyrics_full = [{beat: 0, text: "Ragtime Intro..."}, {beat: 16, text: "Sliding on the keys"}, {beat: 32, text: "The Trio begins"}, {beat: 64, text: "Back to the main theme"}];

        // 5. KOROBEINIKI (TETRIS - 140 BPM)
        const korobeiniki_part_a = [['E4', 1], ['B3', 0.5], ['C4', 0.5], ['D4', 1], ['C4', 0.5], ['B3', 0.5], ['A3', 1], ['A3', 0.5], ['C4', 0.5], ['E4', 1], ['D4', 0.5], ['C4', 0.5], ['B3', 1], ['B3', 0.5], ['C4', 0.5], ['D4', 1], ['E4', 1], ['C4', 1], ['A3', 1], ['A3', 1]];
        const korobeiniki_part_b = [['D4', 1.5], ['F4', 0.5], ['A4', 1], ['G4', 0.5], ['F4', 0.5], ['E4', 1.5], ['C4', 0.5], ['E4', 1], ['D4', 0.5], ['C4', 0.5], ['B3', 1], ['B3', 0.5], ['C4', 0.5], ['D4', 1], ['E4', 1], ['C4', 1], ['A3', 1], ['A3', 1]];
        const korobeiniki_full = [].concat(korobeiniki_part_a, korobeiniki_part_b, korobeiniki_part_a, korobeiniki_part_b, ['E4', 2], ['C4', 2], ['A3', 4]); 
        const korobeiniki_lyrics_full = [{beat: 0, text: "Tetris time!"}, {beat: 16, text: "Keep up!"}, {beat: 32, text: "Faster!"}, {beat: 48, text: "Stack 'em high!"}];

        // 6. HALL OF THE MOUNTAIN KING (160 BPM)
        const mountain_part_a = [['B3',0.5],['C#4',0.5],['D4',0.5],['E4',0.5],['F#4',0.5],['D4',0.5],['F#4',1], ['F#4',0.5],['D4',0.5],['F#4',1], ['F#4',0.5],['D4',0.5],['F#4',1], ['B3',0.5],['C#4',0.5],['D4',0.5],['E4',0.5],['F#4',0.5],['D4',0.5],['F#4',1], ['A4',0.5],['G4',0.5],['E4',1], ['F#4',0.5],['D4',0.5],['B3',1]];
        const mountain_part_b = [['B4',0.5],['C#5',0.5],['D5',0.5],['E5',0.5],['F#5',0.5],['D5',0.5],['F#5',1], ['F#5',0.5],['D5',0.5],['F#5',1], ['F#5',0.5],['D5',0.5],['F#5',1], ['B4',0.5],['C#5',0.5],['D5',0.5],['E5',0.5],['F#5',0.5],['D5',0.5],['F#5',1], ['A5',0.5],['G5',0.5],['E5',1], ['F#5',0.5],['D5',0.5],['B4',1]];
        const mountain_full = [].concat(mountain_part_a, mountain_part_b, mountain_part_a, ['B4', 0.5], ['A4', 0.5], ['G4', 0.5], ['F#4', 0.5], ['E4', 4]); 
        const mountain_lyrics_full = [{beat: 0, text: "Creeping..."}, {beat: 16, text: "Faster..."}, {beat: 32, text: "Running!"}, {beat: 48, text: "Escape!"}];
        
        const SONGS = {
            'camptown': { bpm: 110, notes: camptown_full, lyrics: camptown_lyrics_full},
            'ode': { bpm: 120, notes: ode_full, lyrics: ode_lyrics_full},
            'entertainer': { bpm: 140, notes: entertainer_full, lyrics: entertainer_lyrics_full},
            'korobeiniki': { bpm: 140, notes: korobeiniki_full, lyrics: korobeiniki_lyrics_full},
            'mountain': { bpm: 160, notes: mountain_full, lyrics: mountain_lyrics_full}
        };

        // --- Game State & Logic ---
        let canvas, ctx;
        let gameState = {};
        let audioEngine = null;
        let animationFrameId;
        let floatingTexts = [];
        let activeLanes = [false, false, false, false];
        let pawStamps = []; 
        let pawImage = new Image(); 

        const ui = {
            startScreen: null, gameOverScreen: null, startBtn: null, 
            loadingStatus: null, scoreBoard: null, comboBoard: null, 
            finalScore: null, maxCombo: null, rankText: null, 
            songSelect: null, lyricsContainer: null, shareBtn: null, restartBtn: null
        };
        
        const initUI = () => {
            ui.startScreen = document.getElementById('start-screen');
            ui.gameOverScreen = document.getElementById('game-over-screen');
            ui.startBtn = document.getElementById('start-btn');
            ui.loadingStatus = document.getElementById('loading-status');
            ui.scoreBoard = document.getElementById('score-board');
            ui.comboBoard = document.getElementById('combo-board');
            ui.finalScore = document.getElementById('final-score');
            ui.maxCombo = document.getElementById('max-combo');
            ui.rankText = document.getElementById('rank-text');
            ui.songSelect = document.getElementById('song-select');
            ui.lyricsContainer = document.getElementById('lyrics-container');
            ui.shareBtn = document.getElementById('share-btn');
            ui.restartBtn = document.getElementById('restart-btn');
        };

        const resize = () => {
            if (canvas) {
                canvas.width = canvas.parentElement.offsetWidth;
                canvas.height = canvas.parentElement.offsetHeight;
                gameState.hitY = canvas.height - 100;
            }
        };

        const initAudioEngine = async () => {
            let audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            let masterGain = audioCtx.createGain();
            masterGain.gain.value = 0.6; 
            masterGain.connect(audioCtx.destination);
            
            let meowBuffer = null;
            let fxBuffer = null;
            
            // For simplicity in this single file, we skip external audio loading checks
            // and assume buffers are ready or fail silently if fetch fails.
            // In a real app, you'd handle loading states properly.
            
            const loadAudioFile = async (url, bufferName) => {
                try {
                    const response = await fetch(url);
                    const arrayBuffer = await response.arrayBuffer();
                    const buffer = await audioCtx.decodeAudioData(arrayBuffer);
                    if (bufferName === 'meowBuffer') meowBuffer = buffer;
                    if (bufferName === 'fxBuffer') fxBuffer = buffer;
                } catch (e) { console.log("Audio load error (expected if offline):", e); }
            };

            // Start loading in background
            loadAudioFile(MEOW_URL, 'meowBuffer');
            loadAudioFile(FX_URL, 'fxBuffer');
            
            pawImage.src = PAW_IMAGE_URL;

            audioEngine = {
                init: () => { if (audioCtx.state === 'suspended') audioCtx.resume(); },
                playMeow: (freq) => {
                    if (!audioCtx || !meowBuffer) return;
                    const source = audioCtx.createBufferSource();
                    source.buffer = meowBuffer;
                    source.playbackRate.value = (freq / BASE_FREQUENCY) * OCTAVE_OFFSET;
                    const gain = audioCtx.createGain(); // Fixed: was audioContext
                    source.connect(gain);
                    gain.connect(masterGain);
                    source.start(0);
                },
                playUISound: () => {
                    if (!audioCtx || !fxBuffer) return;
                    const source = audioCtx.createBufferSource();
                    source.buffer = fxBuffer;
                    source.connect(masterGain);
                    source.start(0);
                },
                playHitSound: (type) => {
                    if (!audioCtx) return;
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.connect(gain);
                    gain.connect(masterGain);
                    const now = audioCtx.currentTime;
                    
                    if (type === 'perfect') {
                        osc.frequency.setValueAtTime(880, now);
                        osc.frequency.exponentialRampToValueAtTime(1760, now + 0.1);
                        gain.gain.setValueAtTime(0.3, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    } else if (type === 'miss') {
                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(100, now);
                        gain.gain.setValueAtTime(0.3, now);
                        gain.gain.linearRampToValueAtTime(0.01, now + 0.2);
                    } else {
                        osc.frequency.setValueAtTime(440, now);
                        gain.gain.setValueAtTime(0.3, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    }
                    osc.start();
                    osc.stop(now + 0.2);
                },
                getCurrentTime: () => audioCtx.currentTime,
                isLoaded: () => true 
            };
        };

        const updateScoreboard = () => {
            if (ui.scoreBoard) ui.scoreBoard.innerText = `Score: ${gameState.score}`;
            if (ui.comboBoard) ui.comboBoard.innerText = `Combo: x${gameState.combo}`;
        };

        const createFloatingText = (text, x, y, color) => {
            floatingTexts.push({ text, x, y, color, life: 1.0 });
        };

        const spawnParticles = (x, y, color) => {
            for (let i = 0; i < 10; i++) {
                gameState.particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 15,
                    vy: (Math.random() - 0.5) * 15,
                    life: 1.0, color: color
                });
            }
        };

        const createPawStamp = (lane, x, y, color) => {
            if (!pawImage.complete) return;
            pawStamps.push({
                lane: lane, x: x, y: y+20, 
                rotation: (Math.random() - 0.5) * 0.7, 
                size: 90 + Math.random() * 30, 
                life: 1.0, color: color
            });
        };

        const drawPaw = (ctx, x, y, size, color) => {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
        };

        const endGame = () => {
            gameState.isPlaying = false;
            cancelAnimationFrame(animationFrameId);
            setTimeout(() => {
                ui.startScreen.style.display = 'none';
                ui.gameOverScreen.style.display = 'flex';
                ui.finalScore.innerText = gameState.score;
                ui.maxCombo.innerText = gameState.maxCombo;
                
                // Add garish font to rank text too
                ui.rankText.className = "garish-text";
                const maxPossibleScore = gameState.notes.length * 100;
                const pct = maxPossibleScore > 0 ? gameState.score / maxPossibleScore : 0;
                let rank = "Stray Cat";
                if (pct > 0.9) rank = "Pop Star Purrfection!";
                else if (pct > 0.7) rank = "Cool Cat";
                else if (pct > 0.5) rank = "House Cat";
                ui.rankText.innerText = rank;
            }, 500);
        };

        const gameLoop = () => {
            if (!gameState.isPlaying || !ctx || !canvas || !audioEngine) {
                 animationFrameId = requestAnimationFrame(gameLoop);
                 return;
            }

            const AE = audioEngine;
            const audioTime = AE.getCurrentTime();
            const gameTime = audioTime - gameState.startTime;
            const laneWidth = canvas.width / gameState.laneCount;
            const hitZoneTop = gameState.hitY;
            
            // BG
            const grd = ctx.createLinearGradient(0, 0, 0, canvas.height);
            grd.addColorStop(0, "#FFFFFF");
            grd.addColorStop(1, "#FFE4E1"); 
            ctx.fillStyle = grd;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Lyrics
            gameState.lyrics.forEach(lyric => {
                if (!lyric.shown && gameTime >= lyric.time) {
                    lyric.shown = true;
                    ui.lyricsContainer.innerHTML = `<div class="lyric-line lyric-active">${lyric.text}</div>`;
                }
            });

            // Lanes & Hit Zone
            for (let i = 0; i < gameState.laneCount; i++) {
                const laneGrd = ctx.createLinearGradient(0, 0, 0, canvas.height);
                laneGrd.addColorStop(0, "rgba(255,255,255,0)");
                laneGrd.addColorStop(1, "rgba(255,255,255,0.1)");
                ctx.fillStyle = laneGrd;
                ctx.fillRect(i * laneWidth, 0, laneWidth, canvas.height);
                
                ctx.strokeStyle = "rgba(90, 24, 154, 0.2)";
                ctx.beginPath(); ctx.moveTo(i*laneWidth, 0); ctx.lineTo(i*laneWidth, canvas.height); ctx.stroke();

                const targetHeight = canvas.height - hitZoneTop;
                
                // Static Target
                ctx.fillStyle = "rgba(236, 72, 153, 0.15)";
                ctx.fillRect(i * laneWidth, hitZoneTop, laneWidth, targetHeight);

                // Highlight
                if (activeLanes[i]) {
                    ctx.fillStyle = LANE_COLORS[i];
                    ctx.fillRect(i * laneWidth, hitZoneTop, laneWidth, targetHeight);
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = LANE_COLORS[i];
                }
                ctx.shadowBlur = 0;
                
                ctx.strokeStyle = activeLanes[i] ? "#000" : LANE_COLORS[i];
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(i * laneWidth, hitZoneTop);
                ctx.lineTo((i + 1) * laneWidth, hitZoneTop);
                ctx.stroke();
            }

            let allNotesFinished = true;

            gameState.notes.forEach(note => {
                const timeDiff = note.time - gameTime;
                const y = hitZoneTop - (timeDiff * gameState.speed);

                if (timeDiff <= 0 && !note.played) {
                    AE.playMeow(note.freq); 
                    note.played = true;
                }

                if (y > canvas.height + 50 && !note.hit && !note.missed) {
                    note.missed = true;
                    note.visible = false;
                    gameState.combo = 0;
                    updateScoreboard();
                    createFloatingText("Hiss", note.lane * laneWidth + laneWidth/2, hitZoneTop + 50, "#5A189A");
                    AE.playHitSound('miss');
                }

                if (note.visible && y > -50 && y < canvas.height + 50) {
                    allNotesFinished = false;
                    const x = note.lane * laneWidth + laneWidth / 2;
                    const item = LANE_ITEMS[note.lane];

                    // Set font for Item
                    ctx.font = '60px sans-serif'; 
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // --- Draw Item with Glow Hack ---
                    // Draw multiple times to fake intensity if needed or just ensure alpha=1
                    ctx.globalAlpha = 1.0; 
                    // Draw a subtle shadow to lift it
                    ctx.shadowColor = LANE_COLORS[note.lane];
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = "#000"; // fallback
                    
                    ctx.fillText(item, x, y); 
                    
                    ctx.shadowBlur = 0;
                } else if (!note.missed && !note.hit && note.time > gameTime) {
                    allNotesFinished = false;
                }
            });

            // Particles
            for (let i = gameState.particles.length - 1; i >= 0; i--) {
                const p = gameState.particles[i];
                p.x += p.vx; p.y += p.vy; p.vy += 0.8; p.life -= 0.04;
                ctx.globalAlpha = Math.max(0, p.life);
                ctx.fillStyle = p.color;
                ctx.beginPath(); ctx.arc(p.x, p.y, 6, 0, Math.PI*2); ctx.fill();
                ctx.globalAlpha = 1;
                if (p.life <= 0) gameState.particles.splice(i, 1);
            }

            // Paw Stamps
            for (let i = pawStamps.length - 1; i >= 0; i--) {
                const stamp = pawStamps[i];
                stamp.life -= 0.03;
                if (stamp.life <= 0) { pawStamps.splice(i, 1); continue; }
                
                const laneX = stamp.lane * laneWidth;
                ctx.globalAlpha = Math.max(0, stamp.life * 0.7);
                ctx.fillStyle = stamp.color;
                ctx.fillRect(laneX, hitZoneTop, laneWidth, canvas.height - hitZoneTop);
                ctx.globalAlpha = 1; 

                ctx.save();
                ctx.globalAlpha = Math.max(0, stamp.life);
                ctx.translate(stamp.x, stamp.y);
                ctx.rotate(stamp.rotation);
                if (pawImage.complete) {
                    ctx.filter = `drop-shadow(0 0 5px ${stamp.color})`;
                    ctx.drawImage(pawImage, -stamp.size/2, -stamp.size/2, stamp.size, stamp.size);
                }
                ctx.filter = 'none';
                ctx.restore();
                ctx.globalAlpha = 1;
            }

            // Floating Text (Using the Garish Font Style manually via canvas if feasible, or just bold sans)
            // Note: Canvas font support for custom fonts requires them to be loaded. 'Bangers' should be ready.
            for (let i = floatingTexts.length - 1; i >= 0; i--) {
                const ft = floatingTexts[i];
                ft.y -= 2; ft.life -= 0.03;
                if (ft.life <= 0) { floatingTexts.splice(i, 1); continue; }

                ctx.globalAlpha = Math.max(0, ft.life);
                ctx.save();
                ctx.translate(ft.x, ft.y);
                const scale = 1 + (1-ft.life)*0.5;
                ctx.scale(scale, scale);
                
                // Use Garish Font properties
                ctx.font = "40px 'Bangers'";
                ctx.textAlign = "center";
                
                // Stroke
                ctx.strokeStyle = "black";
                ctx.lineWidth = 4;
                ctx.strokeText(ft.text, 0, 0);
                
                // Fill
                ctx.fillStyle = ft.color;
                ctx.fillText(ft.text, 0, 0);
                
                ctx.restore();
                ctx.globalAlpha = 1;
            }

            if (allNotesFinished && gameState.notes.length > 0) {
                if (gameTime > gameState.notes[gameState.notes.length-1].time + 1.5) {
                    endGame();
                    return;
                }
            }
            animationFrameId = requestAnimationFrame(gameLoop);
        };

        const handleInput = (lane) => {
            if (!gameState.isPlaying || !audioEngine) return;
            activeLanes[lane] = true;
            setTimeout(() => { activeLanes[lane] = false; }, 100);

            const AE = audioEngine;
            const gameTime = AE.getCurrentTime() - gameState.startTime;
            const laneWidth = canvas.width / gameState.laneCount;
            const x = lane * laneWidth + laneWidth / 2;
            const yStamp = gameState.hitY + 50; 

            createPawStamp(lane, x, yStamp, LANE_COLORS[lane]); 

            const candidates = gameState.notes.filter(n => 
                n.lane === lane && !n.hit && !n.missed && Math.abs(n.time - gameTime) < 0.35
            );

            if (candidates.length > 0) {
                const note = candidates[0];
                const diff = Math.abs(note.time - gameTime);
                note.hit = true;
                note.visible = false;
                
                let txt = "", col = "";
                let scoreDelta = 0;
                let comboDelta = 0;

                if (diff < 0.1) {
                    txt = "PURRFECT!"; col = "#FF00FF"; /* Magenta */
                    scoreDelta = 100 + (gameState.combo*5);
                    comboDelta = 1;
                    AE.playHitSound('perfect');
                } else if (diff < 0.25) {
                    txt = "Good!"; col = "#33FFFF"; /* Cyan */
                    scoreDelta = 50 + (gameState.combo*2);
                    comboDelta = 1;
                    AE.playHitSound('good');
                } else {
                    txt = "Meh"; col = "#FFFF00"; /* Yellow */
                    scoreDelta = 10;
                    comboDelta = -gameState.combo;
                    AE.playHitSound('meh');
                }

                gameState.combo = Math.max(0, gameState.combo + comboDelta);
                gameState.score += scoreDelta;
                if (gameState.combo > gameState.maxCombo) gameState.maxCombo = gameState.combo;
                
                updateScoreboard();
                createFloatingText(txt, x, gameState.hitY - 30, col);
                spawnParticles(x, gameState.hitY + 50, LANE_COLORS[lane]);
            }
        };

        const handleKey = (e) => { if (keyMap.hasOwnProperty(e.code)) handleInput(keyMap[e.code]); };
        const handleTouch = (e) => {
            if (!gameState.isPlaying) return;
            e.preventDefault();
            const canvasRect = canvas.getBoundingClientRect();
            for (let i = 0; i < e.changedTouches.length; i++) {
                const x = e.changedTouches[i].clientX - canvasRect.left;
                const lane = Math.floor(x / (canvasRect.width / 4));
                if (lane >= 0 && lane < 4) handleInput(lane);
            }
        };
        const handleMouse = (e) => {
            if (!gameState.isPlaying) return;
            const canvasRect = canvas.getBoundingClientRect();
            const x = e.clientX - canvasRect.left;
            const lane = Math.floor(x / (canvasRect.width / 4));
            if (lane >= 0 && lane < 4) handleInput(lane);
        };
        
        const parseSong = (songId) => {
            const song = SONGS[songId];
            if (!song) return { notes: [], lyrics: [] };
            const beatTime = 60 / song.bpm;
            let currentNoteTime = 2.0;
            const gameNotes = song.notes.map((n, index) => {
                if (!n || typeof n[0] !== 'string' || typeof n[1] !== 'number' || n[1] <= 0) return null;
                const freq = NOTE_FREQS[n[0]];
                const duration = n[1];
                let lane = index % 4;
                if (index % 3 === 0) lane = (lane + 1) % 4;
                if (n[0].indexOf('5') > -1 || n[0].indexOf('6') > -1) lane = 3; 
                if (n[0].indexOf('2') > -1) lane = 0; 
                const noteObj = {
                    time: currentNoteTime, lane: lane, freq: freq, duration: duration * beatTime,
                    played: false, hit: false, missed: false, visible: true
                };
                currentNoteTime += duration * beatTime;
                return noteObj;
            }).filter(n => n !== null);
            const gameLyrics = song.lyrics ? song.lyrics.map(l => ({
                time: 2.0 + (l.beat * beatTime), text: l.text, shown: false
            })) : [];
            return { notes: gameNotes, lyrics: gameLyrics };
        };

        const startGame = () => {
            if (!audioEngine) return;
            audioEngine.playUISound();
            audioEngine.init();
            const selectedSongId = ui.songSelect.value;
            const songData = parseSong(selectedSongId);
            gameState = {
                isPlaying: true, startTime: audioEngine.getCurrentTime(), score: 0, combo: 0, maxCombo: 0,
                notes: songData.notes, lyrics: songData.lyrics, particles: [], laneCount: 4, speed: 500, hitY: gameState.hitY,
            };
            floatingTexts = []; pawStamps = [];
            updateScoreboard();
            ui.startScreen.style.display = 'none';
            ui.lyricsContainer.innerHTML = '<div class="lyric-line lyric-active">Ready...</div>';
            cancelAnimationFrame(animationFrameId);
            animationFrameId = requestAnimationFrame(gameLoop);
        };

        const restartGame = () => {
            audioEngine?.playUISound();
            ui.gameOverScreen.style.display = 'none';
            ui.startScreen.style.display = 'flex';
        };

        const shareScore = () => {
            audioEngine?.playUISound();
            // Get song display name from select box
            const select = ui.songSelect;
            const songName = select.options[select.selectedIndex].text;
            
            const originalText = ui.shareBtn.innerText;
            const finalRankText = ui.rankText.innerText || "Stray Cat";
            const text = `I scored ${gameState.score} points (${finalRankText}) for ${songName} on I-mog-en: The Mewsical! Can you beat my combo of ${gameState.maxCombo}? ðŸ±ðŸŽµ`;
            
            const restoreButton = (newText, duration = 2000) => {
                ui.shareBtn.innerText = newText;
                setTimeout(() => ui.shareBtn.innerText = originalText, duration);
            };

            if (navigator.share) {
                navigator.share({ title: 'I-mog-en: The Mewsical', text: text, url: window.location.href })
                .catch(error => { if (error.name !== 'AbortError') restoreButton("Sharing Failed", 3000); });
            } else {
                const textArea = document.createElement("textarea");
                textArea.value = text;
                textArea.style.position = 'fixed'; 
                textArea.style.left = '-9999px';
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    restoreButton("Copied to Clipboard!", 2500); 
                } catch (err) { restoreButton("Copy Failed", 3000); } 
                finally { document.body.removeChild(textArea); }
            }
        };

        window.onload = function () {
            initUI();
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            gameState = {
                isPlaying: false, startTime: 0, score: 0, combo: 0, maxCombo: 0,
                notes: [], lyrics: [], particles: [], laneCount: 4, speed: 500, hitY: 0,
            };
            resize();
            initAudioEngine();
            window.addEventListener('resize', resize);
            window.addEventListener('keydown', handleKey);
            canvas.addEventListener('touchstart', handleTouch, {passive: false}); 
            canvas.addEventListener('mousedown', handleMouse);
            ui.startBtn.addEventListener('click', startGame);
            ui.restartBtn.addEventListener('click', restartGame);
            ui.shareBtn.addEventListener('click', shareScore);
            animationFrameId = requestAnimationFrame(gameLoop);
        }
    </script>
</body>
</html>
