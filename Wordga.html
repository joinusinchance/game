<!DOCTYPE html>
<html>

<head>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.24.1/dist/phaser.min.js"></script>

    <style>
        body {
            background-color: black;
        }
    </style>


</head>

<body>
    <div id="game"></div>
    <script>
        // see plane_jump.html for previous versions
        // example from https://www.thepolyglotdeveloper.com/2020/09/include-touch-cursor-gesture-events-phaser-game/
        /*
                    const phaserConfig = {
                        type: Phaser.AUTO,
                        parent: "game",
                        width: 1280,
                        height: 720,
                        backgroundColor: "#5DACD8",
                        scene: {
                            init: initScene,
                            preload: preloadScene,
                            create: createScene,
                            update: updateScene
                        }
                    }; 
          */

        //from  https://rexrainbow.github.io/phaser3-rex-notes/docs/site/game/#configuration
        // something added

        const phaserConfig = {
            type: Phaser.AUTO,
            parent: 'game',
            // 750previousX334
            // 2560×1440
            width: 828,
            height: 1425,
            //height: 1792, 
            //width: 1440,
            //height: 2560,
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH
            },
            dom: {
                createContainer: false,
            },
            scene: 'scene_01',
            backgroundColor: 0x000000,
            transparent: true,
            scene: {
                init: initScene,
                preload: preloadScene,
                create: createScene,
                update: updateScene
            }
        }

        const game = new Phaser.Game(phaserConfig);

        //var game = new Phaser.Game(config);


        var isClicking = false;
        var swipeDirection;
        var touchAlpha = 0.5;
        var touchAlphaChange = -0.1;
        var currentX = -1;
        var currentY = -1;
        var previousX = -1;
        var previousY = -1;


        var matrixWidth = 10;
        var playWidth = 8;


        widthText = game.config.width / matrixWidth;
        heightText = widthText


        // text offset x & y 
        var widthOffset = widthText * 0.2;
        var heightOffset = heightText * -0.1;


        var textConfig = { fontSize: widthText, color: '#555555', fontFamily: 'monospace' };
        var textStatusConfig = { fontSize: widthText / 2, color: '#555555', fontFamily: 'monospace' };


        console.log(widthOffset, heightOffset);

        // user input info
        var userState = 'ready'
        //var xShift = 0;
        //var yShift = 0;

        var maxWords = 1024;

        // setup matrices
        var totalLevels = 11 //levelWordList.length();
        var level = 0;
        var wordID = 0;

        var wordStartX = new Array(maxWords);
        var wordStartY = new Array(maxWords);
        var wordDirectionX = new Array(maxWords);
        var wordDirectionY = new Array(maxWords);
   
        var levelWordList = new Array(totalLevels);

        levelWordList[0] = ["zero", "one", "two", "three", "four", "five"];
        levelWordList[1] = ["kitchen", "red", "apples", "motion", "park", "crunch"];
        levelWordList[2] = ["to", "be", "or", "not", "to", "be", "that", "is", "the", "question"];
        levelWordList[3] = ["Neither", "a", "borrower", "nor", "a", "lender", "be"];
        levelWordList[4] = ["The", "lady", "doth", "protest", "too", "much", "methinks"];
        
        levelWordList[5] = ["Do", "you", "think", "I", "am", "easier", "to", "be", "played", "on", "than", "a", "pipe?"]
        
        levelWordList[6] = ["evil", "live", "veil", "vile"];
        levelWordList[7] = ["alpaca", "bandit", "cava", "tuba"];
        levelWordList[8] = ["amaroid", "tressed", "animal", "diorama", "lamina", "dessert"];
        levelWordList[9] = ["reflog", "gater","knab" ,"golfer", "retag","bank"];
        levelWordList[10] = ["tuba", "carom", "bassist", "maraca"];
   





        var levelWordMinScore = new Array(totalLevels);
        levelWordMinScore = [6, 5, 10, 7, 3, 6, 8 ,5 ,5 ,20,18,6];
        var score = 0;
        var totalScore = 0;
        var levelWordOrder = null;
        var levelWordDisplay = null;


        var wordColor = ["white", "grey", "blue", "green", "yellow", "orange", "orangered", "red"];
        var phase = "frontScreen"; //frontScreen , readyForLevel, levelSetUp, level,   
        var wordListLen = levelWordList[0].length;
        var lastTime = 100;

        var matrixSize = 8;

        var hasMatrixPosChanged = 0;

        //var landscape = null; // this will be our graphics object on create




        var displayMatrix = new Array(matrixSize); //  this will be our text matrix on create
        displayMatrix[0] = new Array(matrixSize);
        displayMatrix[1] = new Array(matrixSize);
        displayMatrix[2] = new Array(matrixSize);
        displayMatrix[3] = new Array(matrixSize);
        displayMatrix[4] = new Array(matrixSize);
        displayMatrix[5] = new Array(matrixSize);
        displayMatrix[6] = new Array(matrixSize);
        displayMatrix[7] = new Array(matrixSize);



        //2D matrix for words placed
        // todo dynamically generate this any size
        var maskMatrix = new Array(matrixSize);
        maskMatrix[0] = new Array(matrixSize);
        maskMatrix[1] = new Array(matrixSize);
        maskMatrix[2] = new Array(matrixSize);
        maskMatrix[3] = new Array(matrixSize);
        maskMatrix[4] = new Array(matrixSize);
        maskMatrix[5] = new Array(matrixSize);
        maskMatrix[6] = new Array(matrixSize);
        maskMatrix[7] = new Array(matrixSize);


        // box matrix - this be the rectangular background that should help us improve UI
        var boxMatrix = new Array(matrixSize);
        boxMatrix[0] = new Array(matrixSize);
        boxMatrix[1] = new Array(matrixSize);
        boxMatrix[2] = new Array(matrixSize);
        boxMatrix[3] = new Array(matrixSize);
        boxMatrix[4] = new Array(matrixSize);
        boxMatrix[5] = new Array(matrixSize);
        boxMatrix[6] = new Array(matrixSize);
        boxMatrix[7] = new Array(matrixSize);


        var colorMatrix = new Array(matrixSize);
        colorMatrix[0] = new Array(matrixSize);
        colorMatrix[1] = new Array(matrixSize);
        colorMatrix[2] = new Array(matrixSize);
        colorMatrix[3] = new Array(matrixSize);
        colorMatrix[4] = new Array(matrixSize);
        colorMatrix[5] = new Array(matrixSize);
        colorMatrix[6] = new Array(matrixSize);
        colorMatrix[7] = new Array(matrixSize);




        //2D matrix for words placed
        // todo dynamically generate this any size
        var letterMatrix = new Array(matrixSize);
        letterMatrix[0] = new Array(matrixSize);
        letterMatrix[1] = new Array(matrixSize);
        letterMatrix[2] = new Array(matrixSize);
        letterMatrix[3] = new Array(matrixSize);
        letterMatrix[4] = new Array(matrixSize);
        letterMatrix[5] = new Array(matrixSize);
        letterMatrix[6] = new Array(matrixSize);
        letterMatrix[7] = new Array(matrixSize);

        //2D matrix for words height
        var heightMatrix = new Array(matrixSize);

        heightMatrix[0] = new Array(matrixSize);
        heightMatrix[1] = new Array(matrixSize);
        heightMatrix[2] = new Array(matrixSize);
        heightMatrix[3] = new Array(matrixSize);
        heightMatrix[4] = new Array(matrixSize);
        heightMatrix[5] = new Array(matrixSize);
        heightMatrix[6] = new Array(matrixSize);
        heightMatrix[7] = new Array(matrixSize);


        // create objects for front screen and level splsh screen
        displayFrontTitle = null;
        displayFrontComment1 = null;
        displayFrontComment2 = null;
        displayFrontComment3 = null;
        // create objects for 



        // create objects for commentary and score ingame 
        displayComment = null;
        displayWordList = null;
        displayScore = null;
        displayNextLevelScore = null;
        displayUndo = null;
        firstUndo = 1;



        // figure out whether we are using a url based level


        //levelName = levelName.replace(/%20/g," ");
        searchValues = decodeURI(window.location.search);

        // if no parameters are passed, run test script

        if (searchValues.length > 0) {

            //window.location.serach

            //reuseStart = searchValues.search("reuse=");


            delimeter = searchValues.search(";");
            //reuseValue = searchValues.substring(reuseStart+6,reuseEnd-reuseStart+1);
            reuseValue = searchValues.substring(1, delimeter);


            searchValues = searchValues.substring(delimeter + 1, 1024);

            delimeter = searchValues.search(";");
            levelName = searchValues.substring(0, delimeter);

            searchValues = searchValues.substring(delimeter + 1, 1024);

            delimeter = searchValues.search(";");
            levelComment = searchValues.substring(0, delimeter);

            searchValues = searchValues.substring(delimeter + 1, 1024);


            levelWordsArray = searchValues.split(";");



            console.log(searchValues);
            console.log(reuseValue);
            console.log(levelName);
            console.log(levelComment);
            console.log(levelWordsArray);
            console.log("----");
            console.log(delimeter, reuseValue);

            urlGame = "Yes";


            levelWordList[0] = searchValues.split(";");
            levelWordMinScore[0] = reuseValue;
            wordListLen = levelWordList[0].length;

        }

        else {
            console.log("boot to main menu");

            urlGame = "No";
        }


        console.log("standalone ", window.navigator.standalone);



        function initScene() { }

        function preloadScene() {
            this.load.image("plane", "plane.png");
        }

        function createScene() {

            /* 
            add all text boxes
            show and hide by setting alpha to 1 or 0 
            */
            displayFrontTitle = this.add.text(heightText * .2, heightText * 5, "", textConfig)
            displayFrontComment1 = this.add.text(heightText * .2, heightText * 6, "", textStatusConfig)
            displayFrontComment2 = this.add.text(heightText * .2, heightText * 6, "", textStatusConfig)
            displayComment = this.add.text(heightText * .2, heightText * (9.5) + heightOffset, ("COMMENT"), textStatusConfig);
            displayScore = this.add.text(heightText * .2, heightText * (10) + heightOffset, ("SCORE"), textStatusConfig);
            displayWordList = this.add.text(heightText * .2, heightText * (10.5) + heightOffset, ("LIST"), textStatusConfig)
                .setInteractive()
                /*.on('pointerdown', () => updateDisplayWordList(1)) */
                .on('pointerover', () => enterButtonHoverState())
                .on('pointerout', () => enterButtonRestState());

            displayNextLevelScore = this.add.text(heightText * .2, heightText * (11) + heightOffset, ("NEXT"), textStatusConfig);
            displayUndo = this.add.text(heightText * .2, heightText * (11.5) + heightOffset, ("UNDO"), textStatusConfig)
                .setInteractive()
                .on('pointerdown', () => updateUndo())
            /*
                .on('pointerover', () => enterButtonHoverState())
                .on('pointerout', () => enterButtonRestState());

            /*
                create array of background boxes 
                this will be use hint user actions.. 
            */
            for (x = 0; x < 8; x++) {

                for (y = 0; y < 8; y++) {
                    boxMatrix[x][y] = this.add.rectangle(widthText * (x + 1), widthText * (y + 1), widthText - 1, widthText - 1, 0x000);
                    boxMatrix[x][y].setStrokeStyle(1, 0x000000);
                    boxMatrix[x][y].fillColor = 0x808B96;
                    boxMatrix[x][y].alpha = 0;
                    boxMatrix[x][y].setOrigin(0);
                }
            }

            //this.setStrokeStyle(1, 0xffffff);

            /*
                create array of text boxes for letters
                this will display the words the user has placed
            */


            for (x = 0; x < 8; x++) {

                for (y = 0; y < 8; y++) {

                    displayMatrix[x][y] = this.add.text((widthText * (x + 1)) + widthOffset, (heightText * (y + 1)) + heightOffset, "#", textConfig);
                    //displayMatrix[x][y].alpha =1.0;

                    displayMatrix[x][y].alpha = 0.0;
                }
            }

            /*
                create a cursor
            */
            //plane = this.add.sprite(640, 360, "plane");
            //plane.setScale(0.4);


            /*
            step in to game loop 
            */
            doLogic();

        }


        function updateUndo() {
            console.log("=====undo ", wordID, "user state ", userState);
            hasMatrixPosChanged == 0;

            currentX = -1;
            currentY = -1;
            previousX = -1;
            previousY = -1;

            populateDefaultLetterMatrix();
            levelWordDisplay = [...levelWordList[level]];


            if (wordID > 0) {
                wordID--;
            }


            if (wordID == 0) {
                userState = 'ready';
            }
            else if (wordID > 0) {
                placeWords(wordID - 1);
                //placewords();
                userState == "anchor";

                for (a = 0; a < wordID; a++) {
                    levelWordDisplay.shift();
                }
            }
            console.log("undo -refresh");
            console.log(wordID);
            userState = "ready";
            refreshDisplayLevel();

        }




        function updateDisplayWordList(clickCount) {
            console.log("clicked");

            cycleWordOrder();
            //this.clickCountText.setText(`Button has been clicked ${clickCount} times.`);
        }

        function enterButtonHoverState() {

            console.log("hover");
            // this.clickButton.setStyle({ fill: '#ff0' });
        }

        function enterButtonRestState() {

            console.log("reset");
            //  this.clickButton.setStyle({ fill: '#0f0' });

        }




        //function updateScene() { }
        /* option 1 direct */
        function updateScene() {

            if (!this.input.activePointer.isDown && isClicking == true) {
                //  plane.x = this.input.activePointer.position.x;
                // plane.y = this.input.activePointer.position.y;
                isClicking = false;

                console.log("---Position--->>");
                console.log(this.input.activePointer.position.x, this.input.activePointer.position.y);


                // plane.alpha = 1.0;


                if (phase == "level") {

                    aX = parseInt(this.input.activePointer.position.x / game.config.width * matrixWidth);
                    aY = parseInt(this.input.activePointer.position.y / game.config.width * matrixWidth);



                    // turn XY position in to array position hack
                    aX--;
                    aY--;

                    if (aX >= 0 && aX <= 7) {
                        previousX = currentX;
                        currentX = aX;
                    }

                    if (aY >= 0 && aY <= 7) {
                        previousY = currentY;
                        currentY = aY
                    }



                    if (currentX != previousX || currentY != previousY) {
                        hasMatrixPosChanged = 1;
                        getUserState();

                    }
                    else {
                        console.log("nothing has changed");
                        hasMatrixPosChanged = 0;
                    }

                }
                else if (phase != "level") {
                    getUserState();
                    hasMatrixPosChanged = 0;
                }
                /*
                                if (phase =='level') {
                                    boxMatrix[previousX][previousY].setStrokeStyle(1, 0x000000);
                                    boxMatrix[currentX][currentY].setStrokeStyle(1, 0xffffff);
                                }
                */

            } else if (this.input.activePointer.isDown && isClicking == false) {
                isClicking = true;
            }
            /*
                        if (plane.alpha <= 0.1) {
                            touchAlphaChange = 0.01;
                        } else if (plane.alpha >= 0.9) {
                            touchAlphaChange = -0.01;
                        }
            
                        plane.alpha += touchAlphaChange;
            */

            xAlpha = previousX;
            yAlpha = previousY;


        }

        function getUserState() {
            /*
                1) Compare current click XY postions to previous
                decide whether it is up down left right or same

                2) Decide Click state (for valid clicks)
                on 0th click = ready
                on 1st click = anchor
                on 2nd click decide action
                        if first click <> second click
                            place word
                        if firstclick = second click
                            remove anchor
                    then set user state to be ready
            */


            console.log("User state logged")


            console.log("---old pos new pso----");
            console.log(previousX, previousY);
            console.log(currentX, currentY);


            var xShift = 0;
            var yShift = 0;




            // check if user input is vertical
            if (previousX == currentX) {
                xShift = 0;
                if (previousY == currentY) {
                    yShift = 0;
                    console.log("no direction indicated");
                }
                else if (currentY == previousY + 1 || (currentY == 0 && previousY == 7)) {
                    console.log("verticle down");
                    yShift = 1;
                }
                else if (currentY == previousY - 1 || (currentY == 7 && previousY == 0)) {
                    console.log("verticle up");
                    yShift = -1;
                }
                else {
                    console.log("error!");
                }

            }
            // check if user input is horizontal

            else if (previousY == currentY) {
                if (currentX == previousX + 1 || (currentX == 0 && previousX == 7)) {
                    yShift = 0;
                    console.log("horizontal right");
                    xShift = 1;
                }
                else if (currentX == previousX - 1 || (currentX == 7 && previousX == 0)) {
                    console.log("horizontal left");
                    xShift = -1;
                }
                else {
                    console.log("Error! We should never be here")

                }
            }
            else {
                console.log("no direction");
            }




            console.log("Previous XY ", previousX, previousY);
            console.log("Current XY ", currentX, currentY);

            console.log(xShift, yShift);

            /*
            ## If phase = 'readyForLevel'
            */


            console.log("has matrix pos changed", hasMatrixPosChanged);

            if (phase != 'level') {
                doLogic();
            }



            /*
            ## IF phase = 'level'
            2) Decide Click state (for valid clicks)
            on 0th click = ready
            on 1st click = anchor
            on 2nd click decide action
                    if first click <> second click
                        place word
                    if firstclick = second click
                        remove anchor
                then set user state to be ready
            */


            else if (phase == 'level' && hasMatrixPosChanged == 1) {


                if (
                    currentX >= 0 && currentX <= 7
                    && currentY >= 0 && currentY <= 7
                ) {
                    if (userState == 'ready') {
                        userState = 'anchor';

                    }
                    else if (userState == 'anchor') {
                        if (xShift + yShift != 0) {
                            userState = 'place';
                        }
                        // implied here is that we want to re anchor the text 
                    }
                    else if (userState == 'place') {
                        userState = 'anchor';
                    }


                    console.log("-##-", userState, "-##-");
                    console.log("xshiftyshift:", xShift, yShift);
                    console.log("Previous XY ", previousX, previousY);
                    console.log("Current XY ", currentX, currentY);

                    /*
                    if anchor is within the  playfield,
                    placewords
                    else funstuff
                    */

                    if (
                        currentX >= 0 && currentX <= 7
                        && currentY >= 0 && currentY <= 7
                        && userState == 'anchor'
                        && hasMatrixPosChanged == 1
                    ) {

                        console.log('please place anchor ////////////');
                        populateDefaultLetterMatrix();
                        if (wordID > 0) {
                            placeWords(wordID - 1);

                        }

                        console.log(levelWordList[level][wordID]);
                        placeAnchor(levelWordList[level][wordID]);
                        //placeAnchor(levelWordList[level][wordID]);
                        refreshDisplayLevel();
                    }
                    else if (
                        previousX >= 0 && previousX <= 7
                        && previousY >= 0 && previousY <= 7
                        && userState == 'place'
                    ) {
                        console.log('please place word------------------');

                        wordStartX[wordID] = previousX;
                        wordStartY[wordID] = previousY;
                        wordDirectionX[wordID] = xShift;
                        wordDirectionY[wordID] = yShift;

                        populateDefaultLetterMatrix();
                        placeWords(wordID);
                        //placeWords(wordID);
                        //if (wordID<wordListLen){
                            wordID++;

                        

                        levelWordDisplay.shift();
                        //cycleWordOrder("forward");
                        refreshDisplayLevel();

                        currentX = -1;
                        currentY = -1;
                        userState = 'place';

                        //}

                    }
                    else {
                        console.log("unknown action!!!   ");
                        console.log("-##-", userState, "-##-");
                        console.log("xshiftyshift:", xShift, yShift);
                        console.log("Previous XY ", previousX, previousY);
                        console.log("Current XY ", currentX, currentY);
                        console.log("-------------");

                    }


                }
            }
        }


        // placewords up to wordID
        function placeWords(upToWord) {

            score = 0;
            totalScore = 0;

            populateDefaultLetterMatrix();
            for (var a = 0; a <= upToWord; a++) {

                placeWord(levelWordList[level][a], wordStartX[a], wordStartY[a], wordDirectionX[a], wordDirectionY[a], 1, 1, levelWordList[level][a].length)

            }


        }


        function placeAnchor(aWord) {


            // but first clear matrix;
            //populateDefaultLetterMatrix();

            console.log("Place anchor letter:", levelWordList[level][wordID])
            var currentWord = levelWordList[level][wordID].split("");
            var currentWordLen = currentWord.length;


            // turn postion in to array location ..Hack fix

            if (aWord.length==1) {
                aWord=aWord + "✓";
            }


            console.log("currentXcurrentY:", currentX, currentY);
            //levelWordList[level][wordID]
            placeWord(aWord, currentX, currentY, -1, 0, 1, 0, 2);
            placeWord(aWord, currentX, currentY, 0, -1, 1, 0, 2);
            placeWord(aWord, currentX, currentY, 1, 0, 1, 0, 2);
            placeWord(aWord, currentX, currentY, 0, 1, 1, 0, 2);

        }



        function placeWord(aWord, posX, posY, shiftX, shiftY, maskBit, scoreBit, currentWordLen) {


            var currentWord = aWord.split("");
            //var currentWordLen = placeNletters; 

            if (shiftX + shiftY != 0) {

                for (var a = 0; a < currentWordLen; a++) {

                    if (letterMatrix[posX][posY] == currentWord[a] && scoreBit == 1) {
                        score += 1;
                        totalScore += 1;
                        //console.log("point gained +1");
                    }
                    else if (letterMatrix[posX][posY] != currentWord[a]) {
                        letterMatrix[posX][posY] = currentWord[a];
                        heightMatrix[posX][posY] = heightMatrix[posX][posY] + 1;


                        //    console.log(letterMatrix[posX][posY]);
                    }

                    posX = (posX + shiftX) % (matrixSize);
                    posY = (posY + shiftY) % (matrixSize);


                    if (posX < 0) {
                        posX = matrixSize - 1
                    }

                    if (posY < 0) {
                        posY = matrixSize - 1
                    }


                }


                //userState = 'place';
            }

        }





        function initDisplayLevel() {



            setBoxVisibility(1.0);




            displayComment.alpha = 1.0;
            displayScore.alpha = 1.0;
            displayNextLevelScore.alpha = 1.0;
            displayWordList.alpha = 1.0;
            displayUndo.alpha = 1.0;

        }



        function refreshDisplayLevel() {


            for (var x1 = 0; x1 < matrixSize; x1++) {

                for (var y1 = 0; y1 < matrixSize; y1++) {
                    displayMatrix[x1][y1].setText(letterMatrix[x1][y1]);
                    if (letterMatrix[x1][y1] != '#') {
                        displayMatrix[x1][y1].alpha = 1.0;
                    }
                }

            }


            initDisplayLevel();

            displayFrontTitle.alpha = 0.0;
            displayFrontComment1.alpha = 0.0;

            /*
 
            //context.fillText("a", Math.ceil(xUp/50)*50-25, Math.ceil(yUp/50)*50-25);
            //console.log ("x=" + Math.ceil(xUp/50) + " y=" + Math.ceil(yUp/50));	
            context.fillStyle = "blue";
            context.font = "bold 15px Courier New";
            */
            if (wordID < wordListLen) {
                displayComment.setText("Reuse as many letters as you can:");
                //displayWordList.setText(levelWordList[level].toString());
                displayWordList.setText(levelWordDisplay.toString());

                displayScore.setText("Current score: " + score + " TotalScore: " + totalScore);
                displayNextLevelScore.setText("Score to unlock next level: " + levelWordMinScore[level]);
            }

            if (wordID == wordListLen) {
                displayScore.setText("Current score: " + score);

                
                if (score < levelWordMinScore[level]) {
                    displayComment.setText("You have failed..");
                    displayWordList.setText("Tap to try the level again");
                    wordID = 0;
                    score = 0;
                    totalScore = 0;
                    phase = "readyForLevel";
                }
                    

                else if (score >= levelWordMinScore[level]) {
                    displayComment.setText("Next level unlocked!!");
                    displayWordList.setText("Click here to continue...");
                    level += 1;


                    if (level == totalLevels) {
                        phase = "playerWon";
                    }
                    else {
                        phase = "readyForLevel";
                        wordID = 0;
                        score = 0;
                        wordListLen = levelWordList[level].length;
                        //populateDefaultLetterMatrix();
                        //levelWordOrder = new Array ();
                    }
                }
            }
        }

        function populateDefaultLetterMatrix() {
            for (x = 0; x < 8; x++) {
                for (y = 0; y < 8; y++) {
                    letterMatrix[x][y] = "#";
                    displayMatrix[x][y].alpha = 0.0;
                }
            }

        }

        function doLogic() {

            console.log("phase " + phase + "  doLogic");
            if (phase == "frontScreen") {
                refreshDisplayFrontScreen();
                phase = "readyForLevel";
            }
            else if (phase == "readyForLevel") {
                refreshDisplayReadyForLevel();
                phase = "levelSetUp";
            }
            else if (phase == "levelSetUp") {
                refreshDisplayLevel();
                previousX = -1;
                previousY = -1;
                currentX = -1;
                currentY = -1;
                phase = "level";
            }
            else if (phase == "level") {
                // placeWord();
            }
            else if (phase == "playerWon") {
                refreshDisplayPlayerWon();
                phase = "frontScreen";
            }

            xDown = undefined;
            yDown = undefined;
            xUp = undefined;
            yUp = undefined;

            console.log("Next phase:" + phase);


        }



        function refreshDisplayFrontScreen() {



            // landscape.alpha = 0.0;

            displayFrontTitle.alpha = 1.0;
            displayFrontTitle.setText("Wordga!");
            displayFrontComment1.alpha = 1.0;
            displayFrontComment1.setText("Tap to start")
            displayFrontComment2.alpha = 1.0;


            displayComment.alpha = 0.0;
            displayScore.alpha = 0.0;
            displayNextLevelScore.alpha = 0.0;
            displayWordList.alpha = 0.0;
            displayUndo.alpha = 0.0;

            console.log("phase" + phase + "  refreshDisplayFrontScreen");

            populateDefaultLetterMatrix();
            setBoxVisibility(0.0);

            xDown = 0;
            yDown = 0;
            xUp = 0;
            yUp = 0;

        }


        function refreshDisplayReadyForLevel() {



            setBoxVisibility(0.0);



            //landscape.alpha = 0.0;
            displayFrontTitle.alpha = 1.0;
            displayFrontTitle.setText("Level " + level);
            displayFrontComment1.alpha = 1.0;
            displayFrontComment1.setText("tap to continue..")
            displayFrontComment2.alpha = 1.0;


            displayComment.alpha = 0.0;
            displayScore.alpha = 0.0;
            displayNextLevelScore.alpha = 0.0;
            displayWordList.alpha = 0.0;
            displayUndo.alpha = 0.0;


            levelWordDisplay = [...levelWordList[level]];



            populateDefaultLetterMatrix();

            xDown = 0;
            yDown = 0;
            xUp = 0;
            yUp = 0;

        }


        function setBoxVisibility(alphaValue) {
            //hide boxes
            console.log("setBoxVisibility", alphaValue);
            for (x = 0; x < 8; x++) {
                for (y = 0; y < 8; y++) {
                    boxMatrix[x][y].alpha = alphaValue;
                }
            }
        }

        function refreshDisplayPlayerWon() {

            populateDefaultLetterMatrix();
            setBoxVisibility(0);

            displayFrontTitle.alpha = 1.0;
            displayFrontTitle.setText("Congratulations - You have Won!");
            displayFrontComment1.alpha = 1.0;
            displayFrontComment1.setText("Tap to continue..")
            displayFrontComment2.alpha = 1.0;


            displayComment.alpha = 0.0;
            displayScore.alpha = 0.0;
            displayNextLevelScore.alpha = 0.0;
            displayWordList.alpha = 0.0;
            displayUndo.alpha = 0.0;

        }




    </script>
</body>

</html>
