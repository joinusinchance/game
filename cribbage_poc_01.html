import React, { useState, useEffect, useRef } from 'react';
import { Play, RotateCcw, Trophy, User, ArrowRight, Shield } from 'lucide-react';

/**
 * UTILITY & LOGIC FUNCTIONS
 */
const SUITS = ['♠', '♥', '♣', '♦'];
const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];

const getCardValue = (rank) => {
  if (['J', 'Q', 'K'].includes(rank)) return 10;
  if (rank === 'A') return 1;
  return parseInt(rank);
};

const createDeck = () => {
  const deck = [];
  SUITS.forEach(suit => {
    RANKS.forEach((rank, index) => {
      deck.push({
        id: `${rank}${suit}`,
        rank,
        suit,
        value: getCardValue(rank),
        order: index + 1,
        isRed: suit === '♥' || suit === '♦'
      });
    });
  });
  return deck.sort(() => Math.random() - 0.5);
};

// --- SCORING ALGORITHMS ---

// Helper for combinations
const getCombinations = (array, size) => {
  const result = [];
  const f = (prefix, array) => {
    for (let i = 0; i < array.length; i++) {
      const newPrefix = [...prefix, array[i]];
      if (newPrefix.length === size) result.push(newPrefix);
      else f(newPrefix, array.slice(i + 1));
    }
  };
  f([], array);
  return result;
};

const scoreHand = (hand, starter, isCrib = false) => {
  let score = 0;
  let breakdown = [];
  const allCards = [...hand, starter];

  // 1. Fifteen (2 points)
  const combinations = [];
  for (let i = 2; i <= 5; i++) {
    combinations.push(...getCombinations(allCards, i));
  }
  combinations.forEach(combo => {
    if (combo.reduce((acc, card) => acc + card.value, 0) === 15) {
      score += 2;
      breakdown.push('15 for 2');
    }
  });

  // 2. Pairs (2 points)
  const pairs = getCombinations(allCards, 2);
  pairs.forEach(pair => {
    if (pair[0].rank === pair[1].rank) {
      score += 2;
      breakdown.push('Pair for 2');
    }
  });

  // 3. Runs (3+ points)
  // Sort by order
  const sorted = [...allCards].sort((a, b) => a.order - b.order);
  
  // Robust Run Check: Check all permutations of length 3, 4, 5
  let runPoints = 0;
  for (let len = 5; len >= 3; len--) {
    const combos = getCombinations(allCards, len);
    let foundRunOfLen = false;
    combos.forEach(c => {
      const cSorted = [...c].sort((a,b) => a.order - b.order);
      let isRun = true;
      for(let k=0; k<cSorted.length-1; k++){
        if(cSorted[k+1].order !== cSorted[k].order + 1) isRun = false;
      }
      if(isRun) {
        runPoints += len;
        foundRunOfLen = true;
      }
    });
    // If we found a run of 5, we don't count the runs of 4 or 3 inside it
    if(foundRunOfLen) break; 
  }
  if(runPoints > 0) {
    score += runPoints;
    breakdown.push(`Runs for ${runPoints}`);
  }

  // 4. Flush (4 or 5 points)
  if (!isCrib) {
    const suit = hand[0].suit;
    if (hand.every(c => c.suit === suit)) {
      if (starter.suit === suit) {
        score += 5;
        breakdown.push('Flush for 5');
      } else {
        score += 4;
        breakdown.push('Flush for 4');
      }
    }
  } else {
    // Crib needs 5 cards for flush
    const suit = starter.suit;
    if (hand.every(c => c.suit === suit) && starter.suit === suit) {
      score += 5;
      breakdown.push('Crib Flush for 5');
    }
  }

  // 5. Nobs (1 point)
  const jack = hand.find(c => c.rank === 'J' && c.suit === starter.suit);
  if (jack) {
    score += 1;
    breakdown.push('Nobs for 1');
  }

  return { score, breakdown };
};

const scorePegging = (playedCards) => {
  // Returns points gained by the LAST card played
  if (playedCards.length === 0) return 0;
  
  let points = 0;
  const recent = [...playedCards].reverse(); // Newest first

  // 15
  const total = playedCards.reduce((a, b) => a + b.value, 0);
  if (total === 15) points += 2;
  if (total === 31) points += 2;

  // Pairs
  let pairCount = 0;
  for (let i = 1; i < recent.length; i++) {
    if (recent[i].rank === recent[0].rank) pairCount++;
    else break;
  }
  if (pairCount === 1) points += 2;
  if (pairCount === 2) points += 6;
  if (pairCount === 3) points += 12;

  // Runs
  // Check depth 3, then 4, etc.
  let longestRun = 0;
  for (let depth = 3; depth <= recent.length; depth++) {
    const sub = recent.slice(0, depth);
    const subSorted = [...sub].sort((a,b) => a.order - b.order);
    let isRun = true;
    for(let k=0; k<subSorted.length-1; k++){
      if(subSorted[k+1].order !== subSorted[k].order + 1) isRun = false;
    }
    if (isRun) longestRun = depth;
  }
  if (longestRun > 0) points += longestRun;

  return points;
};

/**
 * COMPONENT: SLIDE TO UNLOCK (Pass Phone)
 */
const Slider = ({ onUnlock, nextPlayer }) => {
  const [dragX, setDragX] = useState(0);
  const containerRef = useRef(null);
  const isDragging = useRef(false);

  const handleStart = (e) => {
    isDragging.current = true;
  };

  const handleMove = (e) => {
    if (!isDragging.current || !containerRef.current) return;
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const rect = containerRef.current.getBoundingClientRect();
    const offsetX = Math.min(Math.max(0, clientX - rect.left - 25), rect.width - 50);
    setDragX(offsetX);
    
    // Unlock threshold
    if (offsetX > rect.width - 60) {
      isDragging.current = false;
      onUnlock();
    }
  };

  const handleEnd = () => {
    isDragging.current = false;
    setDragX(0);
  };

  return (
    <div className="flex flex-col items-center justify-center h-screen bg-emerald-900 text-white p-6 space-y-8 animate-in fade-in">
      <div className="text-center space-y-4">
        <div className="w-20 h-20 bg-emerald-700 rounded-full flex items-center justify-center mx-auto shadow-inner">
          <Shield size={40} className="text-emerald-300" />
        </div>
        <h1 className="text-3xl font-bold">Pass to {nextPlayer}</h1>
        <p className="text-emerald-200">Hide your screen while passing!</p>
      </div>

      <div 
        ref={containerRef}
        className="relative w-full max-w-xs h-16 bg-emerald-800 rounded-full shadow-inner border border-emerald-700 overflow-hidden"
        onMouseMove={handleMove}
        onTouchMove={handleMove}
        onMouseUp={handleEnd}
        onTouchEnd={handleEnd}
        onMouseLeave={handleEnd}
      >
        <div className="absolute inset-0 flex items-center justify-center text-emerald-500 font-semibold tracking-wider pointer-events-none opacity-50">
          SLIDE TO START
        </div>
        <div 
          className="absolute top-1 left-1 h-14 w-14 bg-white rounded-full shadow-lg flex items-center justify-center cursor-grab active:cursor-grabbing z-10"
          style={{ transform: `translateX(${dragX}px)` }}
          onMouseDown={handleStart}
          onTouchStart={handleStart}
        >
          <ArrowRight className="text-emerald-900" />
        </div>
      </div>
    </div>
  );
};

/**
 * COMPONENT: PLAYING CARD
 */
const Card = ({ card, onClick, selected, disabled, hidden, small }) => {
  if (hidden) {
    return (
      <div className={`
        ${small ? 'w-10 h-14' : 'w-16 h-24 sm:w-20 sm:h-28'} 
        bg-blue-800 rounded-lg border-2 border-white shadow-md
        bg-[url('https://www.transparenttextures.com/patterns/cubes.png')]
      `} />
    );
  }

  return (
    <div 
      onClick={() => !disabled && onClick && onClick(card)}
      className={`
        relative flex flex-col items-center justify-between
        ${small ? 'w-10 h-14 text-xs p-1' : 'w-16 h-24 sm:w-20 sm:h-28 p-2 text-lg sm:text-xl'} 
        bg-white rounded-lg shadow-md transition-all duration-200
        ${selected ? 'ring-4 ring-yellow-400 -translate-y-4' : ''}
        ${disabled ? 'opacity-50 grayscale cursor-not-allowed' : 'cursor-pointer hover:-translate-y-1'}
        ${card.isRed ? 'text-red-600' : 'text-slate-900'}
      `}
    >
      <div className="self-start font-bold leading-none">{card.rank}</div>
      <div className={`${small ? 'text-lg' : 'text-3xl'}`}>{card.suit}</div>
      <div className="self-end font-bold leading-none rotate-180">{card.rank}</div>
    </div>
  );
};

/**
 * MAIN GAME COMPONENT
 */
export default function CribbageGame() {
  // Game State
  const [phase, setPhase] = useState('SETUP'); // SETUP, DEAL, DISCARD, CUT, PEGGING, SHOW, OVER
  const [players, setPlayers] = useState({ p1: { name: 'Player 1', score: 0 }, p2: { name: 'Player 2', score: 0 } });
  const [dealer, setDealer] = useState('p1');
  const [turn, setTurn] = useState('p1');
  
  // Card State
  const [hands, setHands] = useState({ p1: [], p2: [], crib: [] });
  const [deck, setDeck] = useState([]);
  const [starter, setStarter] = useState(null);
  const [playedCards, setPlayedCards] = useState([]); // Cards currently on the table (for 31 count)
  const [peggingHistory, setPeggingHistory] = useState([]); // All cards played this phase
  const [count, setCount] = useState(0);

  // UX State
  const [message, setMessage] = useState("Welcome to Cribbage!");
  const [transitioning, setTransitioning] = useState(false);
  const [transitionTarget, setTransitionTarget] = useState(null);
  const [lastScore, setLastScore] = useState(null);

  // --- ACTIONS ---

  const startGame = () => {
    setDeck(createDeck());
    setPhase('DEAL');
    setMessage("Shuffling...");
    setTimeout(dealCards, 1000);
  };

  const dealCards = () => {
    const newDeck = createDeck();
    const h1 = newDeck.slice(0, 6);
    const h2 = newDeck.slice(6, 12);
    const remaining = newDeck.slice(12);

    setHands({ p1: h1, p2: h2, crib: [] });
    setDeck(remaining);
    setPhase('DISCARD');
    setStarter(null);
    setPlayedCards([]);
    setPeggingHistory([]);
    setCount(0);
    setTurn(dealer === 'p1' ? 'p2' : 'p1'); // Non-dealer starts discard/pegging usually irrelevant for discard, but logic holds
    
    // Start with whoever needs to discard first. Let's force dealer to discard last conventionally, 
    // but in this app we can let them do it in any order. 
    // To simplify Pass-Phone logic: Dealer is P1? P2 discards first.
    const firstActor = dealer === 'p1' ? 'p2' : 'p1';
    triggerTransition(firstActor, `${firstActor === 'p1' ? players.p1.name : players.p2.name}, discard 2 cards.`);
  };

  const discard = (cards) => {
    // Current player removes 2 cards
    const player = turn;
    const newHand = hands[player].filter(c => !cards.find(x => x.id === c.id));
    
    setHands(prev => ({
      ...prev,
      [player]: newHand,
      crib: [...prev.crib, ...cards]
    }));

    // Switch turn or move to Cut
    if (hands.crib.length === 0) {
      // Only first player has discarded
      const nextPlayer = player === 'p1' ? 'p2' : 'p1';
      triggerTransition(nextPlayer, "Your turn to discard.");
    } else {
      // Both discarded
      setPhase('CUT');
      setMessage("Cutting the deck...");
      setTimeout(cutDeck, 1500);
    }
  };

  const cutDeck = () => {
    const cutCard = deck[0];
    setStarter(cutCard);
    
    let msg = `Cut: ${cutCard.rank}${cutCard.suit}`;
    if (cutCard.rank === 'J') {
      msg += " - His Heels! Dealer +2";
      scorePoints(dealer, 2);
    }
    setMessage(msg);
    
    setTimeout(() => {
      setPhase('PEGGING');
      const firstPegger = dealer === 'p1' ? 'p2' : 'p1';
      triggerTransition(firstPegger, "Start Pegging!");
    }, 2000);
  };

  // --- PEGGING LOGIC ---

  const playCard = (card) => {
    if (count + card.value > 31) return; // Should be disabled in UI, but safety check

    const newPlayed = [...playedCards, card];
    const newCount = count + card.value;
    
    // Calculate new hand state immediately for logic checks
    const nextHand = hands[turn].filter(c => c.id !== card.id);
    // Create a snapshot of the future state of hands
    const futureHands = {
      ...hands,
      [turn]: nextHand
    };
    
    // Update state
    setHands(prev => ({
      ...prev,
      [turn]: nextHand
    }));

    setPlayedCards(newPlayed);
    setPeggingHistory(prev => [...prev, { ...card, player: turn }]);
    setCount(newCount);

    // Score
    const pts = scorePegging(newPlayed);
    let msg = `${players[turn].name} plays ${card.rank}`;
    if (pts > 0) {
      scorePoints(turn, pts);
      msg += ` (+${pts})`;
    }
    setMessage(msg);

    // Check for 31
    if (newCount === 31) {
      setMessage("31! 2 points. Count resets.");
      // Use futureHands to avoid stale closure issues in resetCount
      setTimeout(() => resetCount(turn === 'p1' ? 'p2' : 'p1', futureHands), 1500);
      return;
    }

    // Determine Next Player
    const nextPlayer = turn === 'p1' ? 'p2' : 'p1';
    
    // Helper to check playability using the FUTURE state
    const canPlayerPlay = (player) => {
      return futureHands[player].some(c => newCount + c.value <= 31);
    };
    
    // Check if next player CAN play
    if (canPlayerPlay(nextPlayer)) {
      triggerTransition(nextPlayer, "Your turn to play.");
    } else if (canPlayerPlay(turn)) {
      // Next player can't play, but current player can ("Go" logic)
      // NOTE: We do NOT score 1 point here. You only get the "Go" point when NOBODY can play (1 for Last).
      setMessage(`${players[nextPlayer].name} says Go. ${players[turn].name} plays again.`);
      // No transition needed, stay on current player
    } else {
      // Neither can play
      scorePoints(turn, 1); // 1 for last card
      setMessage("1 for Last. Count resets.");
      setTimeout(() => resetCount(nextPlayer, futureHands), 1500);
    }
  };

  const canPlay = (player, currentCount) => {
    // This function is for UI rendering (current state), not logic prediction
    return hands[player].some(c => currentCount + c.value <= 31);
  };

  const resetCount = (nextStarter, handsSnapshot) => {
    // handsSnapshot ensures we aren't using stale state from the closure when this runs via setTimeout
    const currentHands = handsSnapshot || hands;

    setPlayedCards([]);
    setCount(0);
    
    // Check if hand is over
    if (currentHands.p1.length === 0 && currentHands.p2.length === 0) {
      setPhase('SHOW');
      // Non-dealer shows first
      const firstShow = dealer === 'p1' ? 'p2' : 'p1';
      triggerTransition(firstShow, "Counting hands...");
    } else {
      // Find who has cards left
      if (currentHands[nextStarter].length > 0) {
        triggerTransition(nextStarter, "New count started.");
      } else {
        triggerTransition(nextStarter === 'p1' ? 'p2' : 'p1', "New count started.");
      }
    }
  };

  // --- SHOW LOGIC ---

  const calculateShow = () => {
    // Reconstruct hand from pegging history for the active player
    const playerCards = peggingHistory.filter(c => c.player === turn);
    
    // Fallback: If for some reason history is empty (shouldn't happen), use empty array
    const handToScore = playerCards.length > 0 ? playerCards : [];

    const { score, breakdown } = scoreHand(handToScore, starter, false);
    
    setMessage(`${players[turn].name} scores ${score}: ${breakdown.join(', ') || '0 points'}`);
    scorePoints(turn, score);
    setLastScore({ score, breakdown, player: turn });

    setTimeout(() => {
      if (turn !== dealer) {
        // Non-dealer just went, now dealer goes
        triggerTransition(dealer, "Dealer's Show.");
      } else {
        // Dealer just went, now dealer counts Crib
        countCrib();
      }
    }, 3500);
  };

  const countCrib = () => {
    const { score, breakdown } = scoreHand(hands.crib, starter, true);
    setMessage(`Dealer (Crib) scores ${score}: ${breakdown.join(', ') || '0 points'}`);
    scorePoints(dealer, score);
    setLastScore({ score, breakdown, player: 'Crib' });
    
    setTimeout(() => {
      // End Round
      if (players.p1.score >= 121 || players.p2.score >= 121) return; // Game over handled in scorePoints
      
      const newDealer = dealer === 'p1' ? 'p2' : 'p1';
      setDealer(newDealer);
      setDealer(newDealer); // React batching safety
      setMessage(`Round over! ${players[newDealer].name} deals next.`);
      setPhase('DEAL');
      setTimeout(startGame, 2000);
    }, 3500);
  };

  // --- UTILS ---

  const scorePoints = (player, points) => {
    setPlayers(prev => {
      const newScore = prev[player].score + points;
      if (newScore >= 121) {
        setPhase('OVER');
        return { ...prev, [player]: { ...prev[player], score: 121 } }; // Cap at 121
      }
      return { ...prev, [player]: { ...prev[player], score: newScore } };
    });
  };

  const triggerTransition = (nextPlayer, msg) => {
    setTurn(nextPlayer);
    setMessage(msg || `Pass to ${players[nextPlayer].name}`);
    setTransitionTarget(nextPlayer);
    setTransitioning(true);
  };

  // --- RENDER HELPERS ---

  useEffect(() => {
    if (phase === 'SHOW' && !transitioning) {
      calculateShow();
    }
  }, [phase, turn, transitioning]);

  // Discard Selection State
  const [selectedDiscards, setSelectedDiscards] = useState([]);
  
  const handleCardClick = (card) => {
    if (phase === 'DISCARD') {
      if (selectedDiscards.find(c => c.id === card.id)) {
        setSelectedDiscards(selectedDiscards.filter(c => c.id !== card.id));
      } else {
        if (selectedDiscards.length < 2) {
          setSelectedDiscards([...selectedDiscards, card]);
        }
      }
    } else if (phase === 'PEGGING') {
      if (count + card.value <= 31) {
        playCard(card);
      } else {
        setMessage("Total cannot exceed 31!");
      }
    }
  };

  const submitDiscards = () => {
    if (selectedDiscards.length === 2) {
      discard(selectedDiscards);
      setSelectedDiscards([]);
    }
  };

  // --- MAIN RENDER ---

  if (transitioning) {
    return (
      <Slider 
        nextPlayer={players[transitionTarget].name} 
        onUnlock={() => setTransitioning(false)} 
      />
    );
  }

  if (phase === 'OVER') {
    return (
      <div className="flex flex-col items-center justify-center h-screen bg-emerald-900 text-white p-8">
        <Trophy size={64} className="text-yellow-400 mb-4" />
        <h1 className="text-4xl font-bold mb-4">GAME OVER</h1>
        <p className="text-2xl mb-8">
          {players.p1.score >= 121 ? players.p1.name : players.p2.name} Wins!
        </p>
        <div className="bg-emerald-800 p-6 rounded-lg w-full max-w-sm">
          <div className="flex justify-between mb-2">
            <span>{players.p1.name}</span>
            <span className="font-bold">{players.p1.score}</span>
          </div>
          <div className="flex justify-between">
            <span>{players.p2.name}</span>
            <span className="font-bold">{players.p2.score}</span>
          </div>
        </div>
        <button 
          onClick={() => window.location.reload()}
          className="mt-8 bg-yellow-500 hover:bg-yellow-600 text-black font-bold py-3 px-8 rounded-full shadow-lg"
        >
          Play Again
        </button>
      </div>
    );
  }

  return (
    <div className="flex flex-col h-screen bg-emerald-900 text-slate-100 overflow-hidden font-sans select-none">
      
      {/* HEADER / SCOREBOARD */}
      <div className="flex justify-between items-center p-4 bg-emerald-950 shadow-md">
        <div className={`flex flex-col items-start ${turn === 'p1' ? 'text-yellow-400' : 'text-slate-400'}`}>
          <div className="flex items-center space-x-2">
            <User size={16} />
            <span className="font-bold">{players.p1.name}</span>
            {dealer === 'p1' && <span className="text-xs bg-slate-700 px-1 rounded">D</span>}
          </div>
          <div className="text-2xl font-mono">{players.p1.score}</div>
        </div>

        <div className="flex flex-col items-center">
           <div className="text-xs uppercase tracking-widest text-emerald-500 font-bold mb-1">{phase}</div>
           {phase === 'PEGGING' && (
             <div className="bg-black/30 px-4 py-1 rounded-full text-xl font-mono border border-emerald-700">
               {count}
             </div>
           )}
        </div>

        <div className={`flex flex-col items-end ${turn === 'p2' ? 'text-yellow-400' : 'text-slate-400'}`}>
          <div className="flex items-center space-x-2">
            {dealer === 'p2' && <span className="text-xs bg-slate-700 px-1 rounded">D</span>}
            <span className="font-bold">{players.p2.name}</span>
            <User size={16} />
          </div>
          <div className="text-2xl font-mono">{players.p2.score}</div>
        </div>
      </div>

      {/* GAME AREA */}
      <div className="flex-1 relative flex flex-col items-center justify-center p-2 space-y-4">
        
        {/* Opponent's Hand (Hidden) */}
        <div className="flex justify-center -space-x-4 opacity-50 scale-75">
          {[1,2,3,4].map(i => <Card key={i} hidden small />)}
        </div>

        {/* Table Area */}
        <div className="w-full max-w-lg bg-emerald-800/50 rounded-xl p-4 min-h-[160px] flex flex-col items-center justify-center border border-emerald-700/50 relative">
          
          {phase === 'SETUP' && (
            <button 
              onClick={startGame}
              className="bg-yellow-500 hover:bg-yellow-600 text-emerald-950 font-bold py-3 px-8 rounded-full shadow-lg flex items-center space-x-2 transform transition hover:scale-105"
            >
              <Play size={20} /> <span>Start Game</span>
            </button>
          )}

          <div className="text-center text-emerald-200 font-medium mb-4 animate-pulse">
            {message}
          </div>

          <div className="flex items-center space-x-6">
            {/* Starter Card */}
            {starter ? (
              <div className="relative">
                <span className="absolute -top-6 left-0 w-full text-center text-xs text-emerald-400 uppercase">Starter</span>
                <Card card={starter} />
              </div>
            ) : (phase !== 'SETUP' && phase !== 'DEAL') && (
              <div className="w-16 h-24 border-2 border-dashed border-emerald-600 rounded flex items-center justify-center opacity-30">
                <span className="text-2xl">?</span>
              </div>
            )}

            {/* Played Cards (Pegging) */}
            {phase === 'PEGGING' && (
              <div className="flex -space-x-8 pl-4">
                {playedCards.map((c, i) => (
                  <div key={i} className="transform hover:-translate-y-2 transition-transform" style={{ zIndex: i }}>
                    <Card card={c} />
                  </div>
                ))}
              </div>
            )}
            
            {/* Show Phase Display */}
            {phase === 'SHOW' && lastScore && (
               <div className="flex flex-col items-center animate-in zoom-in">
                  <div className="text-xl font-bold text-yellow-400 mb-2">
                    +{lastScore.score}
                  </div>
               </div>
            )}
          </div>
        </div>

        {/* Player's Hand */}
        <div className="w-full flex flex-col items-center pb-6">
          <div className="flex justify-center -space-x-2 sm:space-x-2">
            {hands[turn].map((card) => (
              <div key={card.id} className="transform transition-transform hover:-translate-y-4">
                <Card 
                  card={card} 
                  onClick={handleCardClick} 
                  selected={selectedDiscards.find(c => c.id === card.id)}
                  disabled={phase === 'PEGGING' && count + card.value > 31}
                />
              </div>
            ))}
          </div>
          
          {phase === 'DISCARD' && (
            <button 
              onClick={submitDiscards}
              disabled={selectedDiscards.length !== 2}
              className={`
                mt-6 py-2 px-8 rounded-full font-bold shadow-lg transition-all
                ${selectedDiscards.length === 2 
                  ? 'bg-blue-500 hover:bg-blue-600 text-white translate-y-0' 
                  : 'bg-slate-700 text-slate-500 cursor-not-allowed translate-y-2 opacity-0'}
              `}
            >
              Discard 2 Cards
            </button>
          )}

          {phase === 'PEGGING' && !canPlay(turn, count) && hands[turn].length > 0 && (
             <div className="mt-4 text-yellow-400 font-bold animate-bounce">
                Press any card to call "Go" (if automated check fails)
                {/* Note: logic handles GO automatically, but visually seeing cards disabled is helpful */}
             </div>
          )}
        </div>
      </div>
    </div>
  );
}
