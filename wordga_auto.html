<!DOCTYPE html>
<html>

<head>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.24.1/dist/phaser.min.js"></script>

    <style>
        body {
            background-color: black;
        }
    </style>


</head>

<body>
    <div id="game"></div>
    <script>
        // see plane_jump.html for previous versions
        // example from https://www.thepolyglotdeveloper.com/2020/09/include-touch-cursor-gesture-events-phaser-game/
        /*
                    const phaserConfig = {
                        type: Phaser.AUTO,
                        parent: "game",
                        width: 1280,
                        height: 720,
                        backgroundColor: "#5DACD8",
                        scene: {
                            init: initScene,
                            preload: preloadScene,
                            create: createScene,
                            update: updateScene
                        }
                    }; 
          */

        //from  https://rexrainbow.github.io/phaser3-rex-notes/docs/site/game/#configuration
        // something added

        const phaserConfig = {
            type: Phaser.AUTO,
            parent: 'game',
            // 750previousX334
            // 2560×1440
            width: 828,
            height: 1425,
            //height: 1792, 
            //width: 1440,
            //height: 2560,
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH
            },
            dom: {
                createContainer: false,
            },
            scene: 'scene_01',
            backgroundColor: 0x000000,
            transparent: true,
            scene: {
                init: initScene,
                preload: preloadScene,
                create: createScene,
                update: updateScene
            }
        }

        const game = new Phaser.Game(phaserConfig);

        //var game = new Phaser.Game(config);


        var isClicking = false;
        var swipeDirection;
        var touchAlpha = 0.5;
        var touchAlphaChange = -0.1;
        var currentX = -1;
        var currentY = -1;
        var previousX = -1;
        var previousY = -1;
        var isFadeOn = 0;

        var matrixWidth = 10;
        var playWidth = 8;


        widthText = game.config.width / matrixWidth;
        heightText = widthText


        // text offset x & y 
        var widthOffset = widthText * 0.2;
        var heightOffset = heightText * -0.1;


        var textConfig = { fontSize: widthText, color: '#AAAAAA', fontFamily: 'monospace' };
        var textStatusConfig = { fontSize: widthText / 2, color: '#AAAAAA', fontFamily: 'monospace' };


        console.log(widthOffset, heightOffset);

        // user input info
        var userState = 'ready'
        //var xShift = 0;
        //var yShift = 0;

        var maxWords = 1024;

        // setup matrices
        var totalLevels = 20 //levelWordList.length();
        var level = 0;
        var levelStore = 0;
        var wordID = 0;

        /*
            bootState
            practice =  all levels 
            daily = from day N ration 1 game per day
            others WIP
        */

        var bootState = "practice";


        var wordStartX = new Array(maxWords);
        var wordStartY = new Array(maxWords);
        var wordDirectionX = new Array(maxWords);
        var wordDirectionY = new Array(maxWords);
   
        var levelWordList = new Array(totalLevels);

        levelWordList[0] = ["zero", "one", "two", "three", "four", "five"];
        levelWordList[1] = ["kitchen", "red", "apples", "motion", "park", "crunch"];
        levelWordList[2] = ["to", "be", "or", "not", "to", "be", "that", "is", "the", "question"];
        levelWordList[3] = ["Neither", "a", "borrower", "nor", "a", "lender", "be"];

        levelWordList[4] = ["The", "lady", "doth", "protest", "too", "much", "methinks"];
        levelWordList[5] = ["Do", "you", "think", "I", "am", "easier", "to", "be", "played", "on", "than", "a", "pipe?"]
        levelWordList[6] = ["evil", "live", "veil", "vile"];
        levelWordList[7] = ["alpaca", "bandit", "cava", "tuba"];

        levelWordList[8] = ["amaroid", "tressed", "animal", "diorama", "lamina", "dessert"];
        levelWordList[9] = ["reflog", "gater","knab" ,"golfer", "retag","bank"];
        levelWordList[10] = ["tuba", "carom", "bassist", "maraca"];
        levelWordList[11] = ["biscuits", "crisps", "chocolates", "sweets"];

        
        levelWordList[12] = ["Ryan", "Reynolds", "gifts", "Wrexham","co-owner","memorial","urinal"];
        levelWordList[13] = ["owls", "unwelcome", "contribution", "to","news","briefing"];
        levelWordList[14] = ["manufacturer", "makes", "mistake", "on","Queen","memorabilia"];
        levelWordList[15] = ["Lost", "dog", "rescued", "by","sausage","dangled","from","drone"];

        levelWordList[16] = ["amoeba","basilica","tuba", "bassist","balsa","cab"];
        levelWordList[17] = ["piranha", "harp", "cola", "laconic","lapwing","gala","tombola","last"];
        levelWordList[18] = ["cinema", "magic", "dilemma", "maid","dogma","matted","eczema","maize"];
        levelWordList[19] = ["stigma", "mains", "echidna","name", "savanna","nabs"];

        // ["paprica","cart","tapioca","camp"]


        //var days = Math.floor(delta / 86400);
        //delta -= days * 86400;


        var levelWordMinScore = new Array(totalLevels);
        levelWordMinScore = [6,5,10,7, 7,11,9,5, 22,17,7,4, 5,4,5,7, 8,14,14,11];
        var score = 0;
        var totalScore = 0;
        var totalScoreStore = 0;
        var levelWordOrder = null;
        var levelWordDisplay = null;


        //var wordColor = ["grey", "white", "blue", "green", "yellow", "orange", "orangered", "red"];
        var wordColor = ["#555555","#ffffff","#0581a3","04bf55","#b9c211","#cfa81b","eb822d","#ff0000"];
        var wordColorHighlight = wordColor[1];
        var phase = "frontScreen"; //frontScreen , readyForLevel, levelSetUp, level,   
        var wordListLen = levelWordList[0].length;
        var lastTime = 100;

        var matrixSize = 8;

        var hasMatrixPosChanged = 0;

        //var landscape = null; // this will be our graphics object on create




        var displayMatrix = new Array(matrixSize); //  this will be our text matrix on create
        displayMatrix[0] = new Array(matrixSize);
        displayMatrix[1] = new Array(matrixSize);
        displayMatrix[2] = new Array(matrixSize);
        displayMatrix[3] = new Array(matrixSize);
        displayMatrix[4] = new Array(matrixSize);
        displayMatrix[5] = new Array(matrixSize);
        displayMatrix[6] = new Array(matrixSize);
        displayMatrix[7] = new Array(matrixSize);



        //2D matrix for words placed
        // todo dynamically generate this any size
        var maskMatrix = new Array(matrixSize);
        maskMatrix[0] = new Array(matrixSize);
        maskMatrix[1] = new Array(matrixSize);
        maskMatrix[2] = new Array(matrixSize);
        maskMatrix[3] = new Array(matrixSize);
        maskMatrix[4] = new Array(matrixSize);
        maskMatrix[5] = new Array(matrixSize);
        maskMatrix[6] = new Array(matrixSize);
        maskMatrix[7] = new Array(matrixSize);


        // box matrix - this be the rectangular background that should help us improve UI
        var boxMatrix = new Array(matrixSize);
        boxMatrix[0] = new Array(matrixSize);
        boxMatrix[1] = new Array(matrixSize);
        boxMatrix[2] = new Array(matrixSize);
        boxMatrix[3] = new Array(matrixSize);
        boxMatrix[4] = new Array(matrixSize);
        boxMatrix[5] = new Array(matrixSize);
        boxMatrix[6] = new Array(matrixSize);
        boxMatrix[7] = new Array(matrixSize);

        //2D matrix for words placed
        // todo dynamically generate this any size
        var letterMatrix = new Array(matrixSize);
        letterMatrix[0] = new Array(matrixSize);
        letterMatrix[1] = new Array(matrixSize);
        letterMatrix[2] = new Array(matrixSize);
        letterMatrix[3] = new Array(matrixSize);
        letterMatrix[4] = new Array(matrixSize);
        letterMatrix[5] = new Array(matrixSize);
        letterMatrix[6] = new Array(matrixSize);
        letterMatrix[7] = new Array(matrixSize);

        //2D matrix for words height
        var heightMatrix = new Array(matrixSize);

        heightMatrix[0] = new Array(matrixSize);
        heightMatrix[1] = new Array(matrixSize);
        heightMatrix[2] = new Array(matrixSize);
        heightMatrix[3] = new Array(matrixSize);
        heightMatrix[4] = new Array(matrixSize);
        heightMatrix[5] = new Array(matrixSize);
        heightMatrix[6] = new Array(matrixSize);
        heightMatrix[7] = new Array(matrixSize);


        // create objects for front screen and level splsh screen
        displayFrontTitle = null;
        displayFrontComment1 = null;
        displayFrontComment2 = null;
        displayFrontComment3 = null;
        // create objects for 



        // create objects for commentary and score ingame 
        displayComment = null;
        displayWordList = null;
        displayScore = null;
        displayNextLevelScore = null;
        displayUndo = null;
        firstUndo = 1;
        player = "human";// human or robot ; robot to find best score possible..



        /*
         figure out whether we are using a url based level
         or some other mode
         9999 = auto 
         */

        searchValues = decodeURI(window.location.search); // removes all escape codes browser puts in



        // check for level passed in by url...
        if (searchValues.length > 0) {
        // url parameters for a game looks like Wordga.html?4;level_name;level_comment;word1;word2;wordn
        // if level score to beat is set to -1 then set game play to robot...

            delimeter = searchValues.search(";");
            //reuseValue = searchValues.substring(reuseStart+6,reuseEnd-reuseStart+1);
            reuseValue = searchValues.substring(1, delimeter);

            // check for player type -- human; robot; etc 
            if (isInt(reuseValue)) {
                console.log("user diy level");
            }
            else {
                console.log("robot or manformed url");
                if (reuseValue == "robot") {
                    player ="robot";
                }
                console.log(player);
                robot_setup();                 
            }


            searchValues = searchValues.substring(delimeter + 1, 1024);
            delimeter = searchValues.search(";");
            levelName = searchValues.substring(0, delimeter);

            searchValues = searchValues.substring(delimeter + 1, 1024);

            delimeter = searchValues.search(";");
            levelComment = searchValues.substring(0, delimeter);

            searchValues = searchValues.substring(delimeter + 1, 1024);


            levelWordsArray = searchValues.split(";");



            console.log(searchValues);
            console.log(reuseValue);
            console.log(levelName);
            console.log(levelComment);
            console.log(levelWordsArray);
            console.log(searchValues);
            console.log("----");
            console.log(delimeter, reuseValue);

            urlGame = "Yes";


            levelWordList[0] = searchValues.split(";");
            console.log(levelWordList[0]);
            levelWordMinScore[0] = reuseValue;
            wordListLen = levelWordList[0].length;

        }

        else {
            console.log("boot to main menu");

            urlGame = "No";
        }


        //localStorage.getItem("mytime")
//localStorage



        if (bootState == "daily") {
            levelStore = localStorage.getItem('wordga_level');
            totalScoreStore = localStorage.getItem('wordga_totalScore');


            console.log ("levelStore # totalScoreStore", levelStore,totalScoreStore);

            if (levelStore == totalLevels) {
                level = 0;
            } 
            else if (levelStore >=0 && levelStore < totalLevels) {
                level = parseInt(levelStore,10);
                if (totalScoreStore>=0) {
                    totalScore = parseInt(totalScoreStore,10);
                }
            }

        }



        //var x = localStorage.getItem("mytime");


        console.log("standalone ", window.navigator.standalone);



        function initScene() { }

        function preloadScene() {
            //this.load.image("plane", "plane.png");
        }

        function createScene() {

            /* 
            add all text boxes
            show and hide by setting alpha to 1 or 0 
            */
            displayFrontTitle = this.add.text(heightText * .2, heightText * 5, "", textConfig)
            displayFrontComment1 = this.add.text(heightText * .2, heightText * 6, "", textStatusConfig)
            displayFrontComment2 = this.add.text(heightText * .2, heightText * 6, "", textStatusConfig)
            displayComment = this.add.text(heightText * .2, heightText * (9.5) + heightOffset, ("COMMENT"), textStatusConfig);
            displayScore = this.add.text(widthText, heightText /2 + heightOffset, ("SCORE"), textStatusConfig);
            displayWordList = this.add.text(heightText * .2, heightText * (10.5) + heightOffset, ("LIST"), textStatusConfig)
                .setInteractive()
                /*.on('pointerdown', () => updateDisplayWordList(1)) */
                .on('pointerover', () => enterButtonHoverState())
                .on('pointerout', () => enterButtonRestState());

            //displayNextLevelScore = this.add.text(heightText * .2, heightText * (11) + heightOffset, ("NEXT"), textStatusConfig);
            displayUndo = this.add.text(heightText * .2, heightText * (11.5) + heightOffset, ("UNDO"), textStatusConfig)
                .setInteractive()
                .on('pointerdown', () => updateUndo())
            /*
                .on('pointerover', () => enterButtonHoverState())
                .on('pointerout', () => enterButtonRestState());

            /*
                create array of background boxes 
            */
            for (x = 0; x < 8; x++) {

                for (y = 0; y < 8; y++) {
                    boxMatrix[x][y] = this.add.rectangle(widthText * (x + 1), widthText * (y + 1), widthText - 1, widthText - 1, 0x000);
                    boxMatrix[x][y].setStrokeStyle(1, 0x000000);
                    boxMatrix[x][y].fillColor = 0x808B96;
                    boxMatrix[x][y].alpha = 0;
                    boxMatrix[x][y].setOrigin(0);
                    heightMatrix[x][y] = 0;
                }
            }

            //this.setStrokeStyle(1, 0xffffff);

            /*
                create array of text boxes for letters
                this will display the words the user has placed
            */


            for (x = 0; x < 8; x++) {
                for (y = 0; y < 8; y++) {
                    displayMatrix[x][y] = this.add.text((widthText * (x + 1)) + widthOffset, (heightText * (y + 1)) + heightOffset, "#", textConfig);
                    //displayMatrix[x][y].alpha =1.0;
                    displayMatrix[x][y].alpha = 0.0;
                }
            }

            /*
                create a cursor
            */
            //plane = this.add.sprite(640, 360, "plane");
            //plane.setScale(0.4);


            /*
            step in to game loop 
            */
            doLogic();

        }


        function updateUndo() {
            console.log("=====undo ", wordID, "user state ", userState);
            hasMatrixPosChanged == 0;

            currentX = -1;
            currentY = -1;
            previousX = -1;
            previousY = -1;

            populateDefaultLetterMatrix();
            levelWordDisplay = [...levelWordList[level]];


            if (wordID > 0) {
                wordID--;
            }


            if (wordID == 0) {
                userState = 'ready';
            }
            else if (wordID > 0) {
                placeWords(wordID - 1);
                //placewords();
                userState == "anchor";

                for (a = 0; a < wordID; a++) {
                    levelWordDisplay.shift();
                }
            }
            console.log("undo -refresh");
            console.log(wordID);
            userState = "ready";
            refreshDisplayLevel();

        }




        function updateDisplayWordList(clickCount) {
            console.log("clicked");

            cycleWordOrder();
            //this.clickCountText.setText(`Button has been clicked ${clickCount} times.`);
        }

        function enterButtonHoverState() {

            console.log("hover");
            // this.clickButton.setStyle({ fill: '#ff0' });
        }

        function enterButtonRestState() {

            console.log("reset");
            //  this.clickButton.setStyle({ fill: '#0f0' });

        }




        //function updateScene() { }
        /* option 1 direct */
        function updateScene() {

            if (!this.input.activePointer.isDown && isClicking == true) {
                //  plane.x = this.input.activePointer.position.x;
                // plane.y = this.input.activePointer.position.y;
                isClicking = false;

                console.log("---Position--->>");
                console.log(this.input.activePointer.position.x, this.input.activePointer.position.y);


                // plane.alpha = 1.0;


                if (phase == "level") {

                    aX = parseInt(this.input.activePointer.position.x / game.config.width * matrixWidth);
                    aY = parseInt(this.input.activePointer.position.y / game.config.width * matrixWidth);



                    // turn XY position in to array position hack
                    aX--;
                    aY--;

                    if (aX >= 0 && aX <= 7) {
                        previousX = currentX;
                        currentX = aX;
                    }

                    if (aY >= 0 && aY <= 7) {
                        previousY = currentY;
                        currentY = aY
                    }



                    if (currentX != previousX || currentY != previousY) {
                        hasMatrixPosChanged = 1;
                        getUserState();

                    }
                    else {
                        console.log("nothing has changed");
                        hasMatrixPosChanged = 0;
                    }

                }
                else if (phase != "level") {
                //    getCalendarPhase();
                    getUserState();
                    hasMatrixPosChanged = 0;
                }
                /*
                                if (phase =='level') {
                                    boxMatrix[previousX][previousY].setStrokeStyle(1, 0x000000);
                                    boxMatrix[currentX][currentY].setStrokeStyle(1, 0xffffff);
                                }
                */

            } else if (this.input.activePointer.isDown && isClicking == false) {
                isClicking = true;
            }

            if (isFadeOn == 1){
                wordColorHighlight = colorFade(wordColorHighlight);
                //refreshDisplayLevel();
                redrawMatrix();
            }        
            //  hack remove outside loop
            else if (isFadeOn == 0 && phase == "level"){
                wordColorHighlight = wordColor[1];
                isFadeOn = -1;
                //refreshDisplayLevel();
                console.log ("last fade");
                redrawMatrix();
                //getUserState();
                
            }
            else if (phase == "waitScreen") {
                doLogic();

            }

            //currentDay = new Date(event.getDate());
             
            /*
                        if (plane.alpha <= 0.1) {
                            touchAlphaChange = 0.01;
                        } else if (plane.alpha >= 0.9) {
                            touchAlphaChange = -0.01;
                        }
            
                        plane.alpha += touchAlphaChange;
            */

            xAlpha = previousX;
            yAlpha = previousY;


        }

        function getUserState() {
            /*
                1) Compare current click XY postions to previous
                decide whether it is up down left right or same

                2) Decide Click state (for valid clicks)
                on 0th click = ready
                on 1st click = anchor
                on 2nd click decide action
                        if first click <> second click
                            place word
                        if firstclick = second click
                            remove anchor
                    then set user state to be ready
            */


            console.log("User state logged")


            console.log("---old pos new pso----");
            console.log(previousX, previousY);
            console.log(currentX, currentY);


            var xShift = 0;
            var yShift = 0;




            // check if user input is vertical
            if (previousX == currentX) {
                xShift = 0;
                if (previousY == currentY) {
                    yShift = 0;
                    console.log("no direction indicated");
                }
                else if (currentY == previousY + 1 || (currentY == 0 && previousY == 7)) {
                    console.log("verticle down");
                    yShift = 1;
                }
                else if (currentY == previousY - 1 || (currentY == 7 && previousY == 0)) {
                    console.log("verticle up");
                    yShift = -1;
                }
                else {
                    console.log("error!");
                }

            }
            // check if user input is horizontal

            else if (previousY == currentY) {
                if (currentX == previousX + 1 || (currentX == 0 && previousX == 7)) {
                    yShift = 0;
                    console.log("horizontal right");
                    xShift = 1;
                }
                else if (currentX == previousX - 1 || (currentX == 7 && previousX == 0)) {
                    console.log("horizontal left");
                    xShift = -1;
                }
                else {
                    console.log("Error! We should never be here")

                }
            }
            else {
                console.log("no direction");
            }




            console.log("Previous XY ", previousX, previousY);
            console.log("Current XY ", currentX, currentY);

            console.log(xShift, yShift);

            /*
            ## If phase = 'readyForLevel'
            */


            console.log("has matrix pos changed", hasMatrixPosChanged);

            if (phase != 'level') {
                doLogic();
            }



            /*
            ## IF phase = 'level'
            2) Decide Click state (for valid clicks)
            on 0th click = ready
            on 1st click = anchor
            on 2nd click decide action
                    if first click <> second click
                        place word
                    if firstclick = second click
                        remove anchor
                then set user state to be ready
            */


            else if (phase == 'level' && hasMatrixPosChanged == 1) {


                if (
                    currentX >= 0 && currentX <= 7
                    && currentY >= 0 && currentY <= 7
                ) {
                    if (userState == 'ready') {
                        userState = 'anchor';

                    }
                    else if (userState == 'anchor') {
                        if (xShift + yShift != 0) {
                            userState = 'place';
                        }
                        // implied here is that we want to re anchor the text 
                    }
                    else if (userState == 'place') {
                        userState = 'anchor';
                    }


                    console.log("-##-", userState, "-##-");
                    console.log("xshiftyshift:", xShift, yShift);
                    console.log("Previous XY ", previousX, previousY);
                    console.log("Current XY ", currentX, currentY);

                    /*
                    if anchor is within the  playfield,
                    placewords
                    else funstuff
                    */

                    if (
                        currentX >= 0 && currentX <= 7
                        && currentY >= 0 && currentY <= 7
                        && userState == 'anchor'
                        && hasMatrixPosChanged == 1
                    ) {

                        console.log('please place anchor ////////////');
                        populateDefaultLetterMatrix();
                        if (wordID > 0) {
                            placeWords(wordID - 1);

                        }

                        console.log(levelWordList[level][wordID]);
                        placeAnchor(levelWordList[level][wordID]);
                        //placeAnchor(levelWordList[level][wordID]);
                        refreshDisplayLevel();
                    }
                    else if (
                        previousX >= 0 && previousX <= 7
                        && previousY >= 0 && previousY <= 7
                        && userState == 'place'
                    ) {
                        console.log('please place word------------------');

                        wordStartX[wordID] = previousX;
                        wordStartY[wordID] = previousY;
                        wordDirectionX[wordID] = xShift;
                        wordDirectionY[wordID] = yShift;

                        populateDefaultLetterMatrix();
                        placeWords(wordID);
                        //placeWords(wordID);
                        //if (wordID<wordListLen){
                            wordID++;

                        

                        levelWordDisplay.shift();
                        //cycleWordOrder("forward");
                        refreshDisplayLevel();

                        currentX = -1;
                        currentY = -1;
                        userState = 'place';

                        //}

                    }
                    else {
                        console.log("unknown action!!!   ");
                        console.log("-##-", userState, "-##-");
                        console.log("xshiftyshift:", xShift, yShift);
                        console.log("Previous XY ", previousX, previousY);
                        console.log("Current XY ", currentX, currentY);
                        console.log("-------------");

                    }


                }
            }
        }


        // placewords up to wordID
        function placeWords(upToWord) {

            score = 0;
            totalScore = 0;

            populateDefaultLetterMatrix();
            for (var a = 0; a < upToWord; a++) {

                placeWord(levelWordList[level][a], wordStartX[a], wordStartY[a], wordDirectionX[a], wordDirectionY[a], 1, 1, 0,levelWordList[level][a].length,0);

            }
                // set height (color) of only last word placed
                /// but only if wor di last word
                if (upToWord ==wordID){
                    placeWord(levelWordList[level][upToWord], wordStartX[upToWord], wordStartY[upToWord], wordDirectionX[upToWord], wordDirectionY[upToWord], 1, 1, 0,levelWordList[level][upToWord].length,1);
                }
                else
                {
                    placeWord(levelWordList[level][upToWord], wordStartX[upToWord], wordStartY[upToWord], wordDirectionX[upToWord], wordDirectionY[upToWord], 1, 1, 0,levelWordList[level][upToWord].length,0);
                }

        }


        function placeAnchor(aWord) {


            // but first clear matrix;
            //populateDefaultLetterMatrix();

            console.log("Place anchor letter:", levelWordList[level][wordID])
            var currentWord = levelWordList[level][wordID].split("");
            var currentWordLen = currentWord.length;


            // turn postion in to array location ..Hack fix

            if (aWord.length==1) {
                aWord=aWord + "✓";
            }


            console.log("currentXcurrentY:", currentX, currentY);
            //levelWordList[level][wordID]
            placeWord(aWord, currentX, currentY, -1, 0, 1, 0, 0,2,0);
            placeWord(aWord, currentX, currentY, 0, -1, 1, 0, 1,2,0);
            placeWord(aWord, currentX, currentY, 1, 0, 1, 0, 1, 2,0);
            placeWord(aWord, currentX, currentY, 0, 1, 1, 0, 1, 2,0);

        }



        function placeWord(aWord, posX, posY, shiftX, shiftY, maskBit, scoreBit,startPos, wordLength, setHeight) {


            var currentWord = aWord.split("");
            var totalWordLen = aWord.length;
            //var currentWordLen = placeNletters; 

            if (shiftX + shiftY != 0) {

                for (var a = 0; a < totalWordLen; a++) {

                    if (letterMatrix[posX][posY] == currentWord[a] && startPos<=a && a<wordLength  && scoreBit == 1) {  //&& 
                        score += 1;
                        totalScore += 1;
                        if (setHeight ==1) {
                            heightMatrix[posX][posY] = heightMatrix[posX][posY] + 1 ;
                            isFadeOn = 1;
                        }
                    } 
                    // display potential points  /// should just fade when scored
                    /*
                    else if (letterMatrix[posX][posY] == currentWord[a] && startPos<=a && scoreBit == 0 ) {
                        heightMatrix[posX][posY] = heightMatrix[posX][posY] + 1 ;
                    }
                    */
                    else if (letterMatrix[posX][posY] != currentWord[a] && startPos<=a && a<wordLength) {
                        letterMatrix[posX][posY] = currentWord[a];
                    }





                    posX = (posX + shiftX) % (matrixSize);
                    posY = (posY + shiftY) % (matrixSize);


                    if (posX < 0) {
                        posX = matrixSize - 1
                    }

                    if (posY < 0) {
                        posY = matrixSize - 1
                    }


                }


                //userState = 'place';
            }

        }





        function initDisplayLevel() {
            setBoxVisibility(1.0);
            displayComment.alpha = 1.0;
            displayScore.alpha = 1.0;
            //displayNextLevelScore.alpha = 1.0;
            displayWordList.alpha = 1.0;
            displayUndo.alpha = 1.0;

            // and for the bits we dont need 
            displayFrontTitle.alpha = 0.0;
            displayFrontComment1.alpha = 0.0;

        }



        function redrawMatrix() {

            for (var x1 = 0; x1 < matrixSize; x1++) {
                for (var y1 = 0; y1 < matrixSize; y1++) {
                    displayMatrix[x1][y1].setText(letterMatrix[x1][y1]);
                    if (letterMatrix[x1][y1] != '#') {
                        /// fix hacky word fade 
                        if (heightMatrix[x1][y1]==0) { 
                            displayMatrix[x1][y1].setColor(wordColor[0]);
                        }
                        else if (heightMatrix[x1][y1]==1) {
                            displayMatrix[x1][y1].setColor(wordColorHighlight);
                            if (wordColorHighlight == wordColor[0]) {
                                heightMatrix[x1][y1] = 0;
                                isFadeOn = 0;
                            }
                        }
                        displayMatrix[x1][y1].alpha = 1.0;
                        //console.log("color", wordColor[heightMatrix[x1][y1]]);
                    }
                }
            }
        }


        function refreshDisplayLevel() {


            redrawMatrix();
            initDisplayLevel();


            /*
 
            //context.fillText("a", Math.ceil(xUp/50)*50-25, Math.ceil(yUp/50)*50-25);
            //console.log ("x=" + Math.ceil(xUp/50) + " y=" + Math.ceil(yUp/50));	
            context.fillStyle = "blue";
            context.font = "bold 15px Courier New";
            */

            if (wordID < wordListLen) {
                displayComment.setText("Reuse as many letters as you can:");
                //displayWordList.setText(levelWordList[level].toString());
                displayWordList.setText(levelWordDisplay.toString());

                displayScore.setText( "Total:" + totalScore +" Level:" + score + " To unlock:"+levelWordMinScore[level]);
                //displayNextLevelScore.setText("Score to unlock next level: " + levelWordMinScore[level]);
            }

            if (wordID == wordListLen) {
                displayScore.setText("Current score: " + score);
                console.log ("# end of level #");

                
                if (score < levelWordMinScore[level]) {
                    displayComment.setText("You have failed..");
                    displayWordList.setText("Tap to try the level again");
                    totalScore = 0;
                    //level = level;
                    phase = "readyForLevel";
                    console.log ("# player failed #");
                }
                    

                else if (score >= levelWordMinScore[level]) {
                    displayComment.setText("Next level unlocked!!");
                    displayWordList.setText("Click here to continue...");

                    localStorage.setItem('wordga_level',level+1);
                    localStorage.setItem('wordga_totalScore',totalScore);
                    console.log ("# player passed #");



                    if (level == totalLevels) {
                        phase = "playerWon";
                        localStorage.setItem('wordga_level',level);
                        localStorage.setItem('wordga_totalScore',totalScore);
                    }
                    else {
                        phase = "readyForLevel";
                        level += 1;

                        //populateDefaultLetterMatrix();
                        //levelWordOrder = new Array ();
                    }
                }
            }
        }

        function populateDefaultLetterMatrix() {
            populateDefaultLetterMatrix(true)

        }


        function populateDefaultLetterMatrix(setColor) {
            for (x = 0; x < 8; x++) {
                for (y = 0; y < 8; y++) {
                    letterMatrix[x][y] = "#";
                    heightMatrix[x][y]=0;

                    if (setColor){
                        displayMatrix[x][y].alpha = 0.0;
                        displayMatrix[x][y].setColor(wordColor[0]);
                        }
                    
                }
            }

        }





        function doLogic() {

            console.log("phase " + phase + "  doLogic");
            if (phase == "frontScreen") {
                refreshDisplayFrontScreen();
                //phase = "readyForLevel";
                if (bootState == "daily") {
                    getCalendarPhase();
                } 
                else if (bootState == "practice") {
                    phase = "readyForLevel";
                }
                //phase = "wait";
            }
            else if (phase == "waitScreen") {
                waitScreen();
            }
            else if (phase == "readyForLevel") {
                refreshDisplayReadyForLevel();
                if (bootState == "daily") {
                    getCalendarPhase();
                } 
                else if (bootState =="practice") {
                    phase = "levelSetUp";
                }
            }
            else if (phase == "levelSetUp") {
                refreshDisplayLevel();
                previousX = -1;
                previousY = -1;
                currentX = -1;
                currentY = -1;
                phase = "level";
            }
            else if (phase == "level") {
                // placeWord();
            }
            else if (phase == "playerWon") {
                refreshDisplayPlayerWon();
                phase = "frontScreen";
            }

            xDown = undefined;
            yDown = undefined;
            xUp = undefined;
            yUp = undefined;

            console.log("Next phase:" + phase);


        }



        function refreshDisplayFrontScreen() {



            // landscape.alpha = 0.0;

            displayFrontTitle.alpha = 1.0;
            displayFrontTitle.setText("Wordga!");
            displayFrontComment1.alpha = 1.0;
            displayFrontComment1.setText(bootState + " - tap to start")
            displayFrontComment2.alpha = 1.0;


            displayComment.alpha = 0.0;
            displayScore.alpha = 0.0;
            //displayNextLevelScore.alpha = 0.0;
            displayWordList.alpha = 0.0;
            displayUndo.alpha = 0.0;

            console.log("phase" + phase + "  refreshDisplayFrontScreen " + bootState);

            populateDefaultLetterMatrix();
            setBoxVisibility(0.0);

            xDown = 0;
            yDown = 0;
            xUp = 0;
            yUp = 0;

        }


        function refreshDisplayReadyForLevel() {


            console.log("Ready for level");
            setBoxVisibility(0.0);


            wordID = 0;
            score = 0;
            wordListLen = levelWordList[level].length;
            //landscape.alpha = 0.0;
            displayFrontTitle.alpha = 1.0;
            displayFrontTitle.setText("Level " + level);
            displayFrontComment1.alpha = 1.0;
            displayFrontComment1.setText("tap to continue..")
            displayFrontComment2.alpha = 1.0;


            displayComment.alpha = 0.0;
            displayScore.alpha = 0.0;
            //displayNextLevelScore.alpha = 0.0;
            displayWordList.alpha = 0.0;
            displayUndo.alpha = 0.0;


            levelWordDisplay = [...levelWordList[level]];



            populateDefaultLetterMatrix();

            xDown = 0;
            yDown = 0;
            xUp = 0;
            yUp = 0;

        }

        function waitScreen() {

            displayFrontTitle.alpha = 1.0;
            displayFrontTitle.setText("Next level in..");
            displayFrontComment1.alpha = 1.0;


            var waitTime = getCalendarPhase();

            displayFrontComment1.setText("..."+waitTime);
            displayFrontComment2.alpha = 1.0;

            displayComment.alpha = 0.0;
            displayScore.alpha = 0.0;
            //displayNextLevelScore.alpha = 0.0;
            displayWordList.alpha = 0.0;
            displayUndo.alpha = 0.0;

        }

        function setBoxVisibility(alphaValue) {
            //hide boxes
            //console.log("setBoxVisibility", alphaValue);
            for (x = 0; x < 8; x++) {
                for (y = 0; y < 8; y++) {
                    boxMatrix[x][y].alpha = alphaValue;
                }
            }
        }

        function refreshDisplayPlayerWon() {

            populateDefaultLetterMatrix();
            setBoxVisibility(0);

            displayFrontTitle.alpha = 1.0;
            displayFrontTitle.setText("Congratulations - You have Won!");
            displayFrontComment1.alpha = 1.0;
            displayFrontComment1.setText("Tap to continue..")
            displayFrontComment2.alpha = 1.0;


            displayComment.alpha = 0.0;
            displayScore.alpha = 0.0;
            //displayNextLevelScore.alpha = 0.0;
            displayWordList.alpha = 0.0;
            displayUndo.alpha = 0.0;
            level = 0;

        }


        function colorFade (fromColor,toColor,increment){
            
            fromColor = fromColor.substring(1,3);

            aColor = parseInt(fromColor,16);
            aColor --;
            
            bColor = "#" + aColor.toString(16)+ aColor.toString(16)+ aColor.toString(16);

            return (bColor);
        }

        function getCalendarPhase() {
            /*
            get dateLevel from datediff
            get stored level 
            if levelStore >= dateLevel
                phase "waitscreen"
            if levelStore < dateLevel 
                phase level 
                level dateLevel
            */




                var firstDay = new Date('May 02, 2022 00:00:00');
                var currentDay = new Date() ;  //.setHours(0,0,0,0);

                levelStore = localStorage.getItem('wordga_level');
                currentDay.setDate(currentDay.getDate());  
                var dateDiff = Math.floor(currentDay  - firstDay);
                
                var dateLevel = Math.floor(dateDiff/ 86400000);
                //level = dateLevel;

                //console.log("Level store", levelStore, "Date level",dateLevel);

                if (dateLevel >=totalLevels) {
                    dateLevel = 0
                }

                if (levelStore >=dateLevel) {
                    phase = "waitScreen";

                }
                else if (levelStore< dateLevel) {
                    phase = "readyForLevel";
                    level = dateLevel;
                }

                return dateDiff;
        



            }


            function robot_setup() {
             
                console.log ("robot setup");  
                console.log(wordID);     
                console.log(wordListLen);
                console.log(levelWordList[0]);
                

                wordStartX[wordID] = 0;
                wordStartY[wordID] = 0;
                wordDirectionX[wordID] = 0;
                wordDirectionY[wordID] = 0;

                placeWords_Robot(wordID);

                console.log(totalScore);
            }

            function placeWords_Robot(upToWord) {

                score = 0;
                totalScore = 0;

                populateDefaultLetterMatrix(false);
                for (var a = 0; a < upToWord; a++) {

                    placeWord(levelWordList[level][a], wordStartX[a], wordStartY[a], wordDirectionX[a], wordDirectionY[a], 1, 1, 0,levelWordList[level][a].length,0);

                }
            }




            function isInt(value) {
             return !isNaN(value) && 
         parseInt(Number(value)) == value && 
         !isNaN(parseInt(value, 10));
}

    </script>
</body>

</html>
